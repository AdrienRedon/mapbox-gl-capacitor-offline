{"version":3,"file":"mapbox-gl-capacitor-offline.js","sources":["../node_modules/pbf/index.js","../node_modules/mapbox-gl/src/style/parse_glyph_pbf.js","../node_modules/mapbox-gl/src/util/actor.js","../node_modules/@mapbox/whoots-js/index.mjs","../node_modules/mapbox-gl/src/geo/lng_lat_bounds.js","../node_modules/mapbox-gl/src/geo/lng_lat.js","../node_modules/mapbox-gl/src/geo/mercator_coordinate.js","../node_modules/mapbox-gl/src/source/tile_id.js","../node_modules/mapbox-gl/src/data/dem_data.js","../node_modules/mapbox-gl/src/util/dictionary_coder.js","../node_modules/mapbox-gl/src/util/vectortile_to_geojson.js","../node_modules/mapbox-gl/src/source/source_state.js","../node_modules/mapbox-gl/src/data/feature_index.js","../node_modules/mapbox-gl/src/util/util.js","../node_modules/mapbox-gl/src/source/tile.js","../node_modules/mapbox-gl/src/data/bucket.js","../node_modules/mapbox-gl/src/style-spec/util/ref_properties.js","../node_modules/mapbox-gl/src/symbol/shaping.js","../node_modules/mapbox-gl/src/util/verticalize_punctuation.js","../node_modules/mapbox-gl/src/style-spec/group_by_layout.js","../node_modules/mapbox-gl/src/style/style_layer_index.js","../node_modules/mapbox-gl/src/symbol/check_max_angle.js","../node_modules/mapbox-gl/src/symbol/get_anchors.js","../node_modules/mapbox-gl/src/symbol/collision_feature.js","../node_modules/tinyqueue/index.js","../node_modules/mapbox-gl/src/util/find_pole_of_inaccessibility.js","../node_modules/murmurhash-js/murmurhash3_gc.js","../node_modules/murmurhash-js/murmurhash2_gc.js","../node_modules/murmurhash-js/index.js","../node_modules/mapbox-gl/src/symbol/symbol_layout.js","../node_modules/mapbox-gl/src/symbol/quads.js","../node_modules/mapbox-gl/src/symbol/clip_line.js","../node_modules/mapbox-gl/src/render/glyph_atlas.js","../node_modules/mapbox-gl/src/source/worker_tile.js","../node_modules/mapbox-gl/src/util/performance.js","../node_modules/mapbox-gl/src/source/vector_tile_worker_source.js","../node_modules/mapbox-gl/src/source/raster_dem_tile_worker_source.js","../node_modules/wgs84/index.js","../node_modules/@mapbox/geojson-area/index.js","../node_modules/@mapbox/geojson-rewind/index.js","../node_modules/mapbox-gl/src/source/geojson_wrapper.js","../node_modules/vt-pbf/lib/geojson_wrapper.js","../node_modules/vt-pbf/index.js","../node_modules/mapbox-gl/src/source/source_cache.js","../node_modules/mapbox-gl/src/render/draw_debug.js","../node_modules/mapbox-gl/src/render/painter.js","../node_modules/mapbox-gl/src/render/draw_symbol.js","../node_modules/mapbox-gl/src/render/draw_collision_debug.js","../node_modules/mapbox-gl/src/render/draw_circle.js","../node_modules/mapbox-gl/src/render/draw_heatmap.js","../node_modules/mapbox-gl/src/render/draw_line.js","../node_modules/@capacitor/core/dist/esm/web/filesystem.js","../node_modules/@capacitor/core/dist/esm/web/accessibility.js","../node_modules/@capacitor/core/dist/esm/util.js","../node_modules/@capacitor/core/dist/esm/web/geolocation.js","../node_modules/@capacitor/core/dist/esm/web/device.js","../node_modules/@capacitor/core/dist/esm/web/local-notifications.js","../node_modules/@capacitor/core/dist/esm/web/share.js","../node_modules/@capacitor/core/dist/esm/web/modals.js","../node_modules/@capacitor/core/dist/esm/web/motion.js","../node_modules/@capacitor/core/dist/esm/web/network.js","../node_modules/@capacitor/core/dist/esm/web/permissions.js","../node_modules/@capacitor/core/dist/esm/web/splash-screen.js","../node_modules/@capacitor/core/dist/esm/web/storage.js","../node_modules/@capacitor/core/dist/esm/web/toast.js","../node_modules/@capacitor/core/dist/esm/web/index.js","../src/mbtiles_source.js","../src/offline_map.js","../rollup/mapboxgl.js"],"sourcesContent":["'use strict';\n\nmodule.exports = Pbf;\n\nvar ieee754 = require('ieee754');\n\nfunction Pbf(buf) {\n    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);\n    this.pos = 0;\n    this.type = 0;\n    this.length = this.buf.length;\n}\n\nPbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum\nPbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64\nPbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields\nPbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32\n\nvar SHIFT_LEFT_32 = (1 << 16) * (1 << 16),\n    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;\n\nPbf.prototype = {\n\n    destroy: function() {\n        this.buf = null;\n    },\n\n    // === READING =================================================================\n\n    readFields: function(readField, result, end) {\n        end = end || this.length;\n\n        while (this.pos < end) {\n            var val = this.readVarint(),\n                tag = val >> 3,\n                startPos = this.pos;\n\n            this.type = val & 0x7;\n            readField(tag, result, this);\n\n            if (this.pos === startPos) this.skip(val);\n        }\n        return result;\n    },\n\n    readMessage: function(readField, result) {\n        return this.readFields(readField, result, this.readVarint() + this.pos);\n    },\n\n    readFixed32: function() {\n        var val = readUInt32(this.buf, this.pos);\n        this.pos += 4;\n        return val;\n    },\n\n    readSFixed32: function() {\n        var val = readInt32(this.buf, this.pos);\n        this.pos += 4;\n        return val;\n    },\n\n    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)\n\n    readFixed64: function() {\n        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;\n        this.pos += 8;\n        return val;\n    },\n\n    readSFixed64: function() {\n        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;\n        this.pos += 8;\n        return val;\n    },\n\n    readFloat: function() {\n        var val = ieee754.read(this.buf, this.pos, true, 23, 4);\n        this.pos += 4;\n        return val;\n    },\n\n    readDouble: function() {\n        var val = ieee754.read(this.buf, this.pos, true, 52, 8);\n        this.pos += 8;\n        return val;\n    },\n\n    readVarint: function(isSigned) {\n        var buf = this.buf,\n            val, b;\n\n        b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) return val;\n        b = buf[this.pos];   val |= (b & 0x0f) << 28;\n\n        return readVarintRemainder(val, isSigned, this);\n    },\n\n    readVarint64: function() { // for compatibility with v2.0.1\n        return this.readVarint(true);\n    },\n\n    readSVarint: function() {\n        var num = this.readVarint();\n        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding\n    },\n\n    readBoolean: function() {\n        return Boolean(this.readVarint());\n    },\n\n    readString: function() {\n        var end = this.readVarint() + this.pos,\n            str = readUtf8(this.buf, this.pos, end);\n        this.pos = end;\n        return str;\n    },\n\n    readBytes: function() {\n        var end = this.readVarint() + this.pos,\n            buffer = this.buf.subarray(this.pos, end);\n        this.pos = end;\n        return buffer;\n    },\n\n    // verbose for performance reasons; doesn't affect gzipped size\n\n    readPackedVarint: function(arr, isSigned) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readVarint(isSigned));\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readVarint(isSigned));\n        return arr;\n    },\n    readPackedSVarint: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readSVarint());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readSVarint());\n        return arr;\n    },\n    readPackedBoolean: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readBoolean());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readBoolean());\n        return arr;\n    },\n    readPackedFloat: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readFloat());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readFloat());\n        return arr;\n    },\n    readPackedDouble: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readDouble());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readDouble());\n        return arr;\n    },\n    readPackedFixed32: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readFixed32());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readFixed32());\n        return arr;\n    },\n    readPackedSFixed32: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed32());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readSFixed32());\n        return arr;\n    },\n    readPackedFixed64: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readFixed64());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readFixed64());\n        return arr;\n    },\n    readPackedSFixed64: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed64());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readSFixed64());\n        return arr;\n    },\n\n    skip: function(val) {\n        var type = val & 0x7;\n        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}\n        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;\n        else if (type === Pbf.Fixed32) this.pos += 4;\n        else if (type === Pbf.Fixed64) this.pos += 8;\n        else throw new Error('Unimplemented type: ' + type);\n    },\n\n    // === WRITING =================================================================\n\n    writeTag: function(tag, type) {\n        this.writeVarint((tag << 3) | type);\n    },\n\n    realloc: function(min) {\n        var length = this.length || 16;\n\n        while (length < this.pos + min) length *= 2;\n\n        if (length !== this.length) {\n            var buf = new Uint8Array(length);\n            buf.set(this.buf);\n            this.buf = buf;\n            this.length = length;\n        }\n    },\n\n    finish: function() {\n        this.length = this.pos;\n        this.pos = 0;\n        return this.buf.subarray(0, this.length);\n    },\n\n    writeFixed32: function(val) {\n        this.realloc(4);\n        writeInt32(this.buf, val, this.pos);\n        this.pos += 4;\n    },\n\n    writeSFixed32: function(val) {\n        this.realloc(4);\n        writeInt32(this.buf, val, this.pos);\n        this.pos += 4;\n    },\n\n    writeFixed64: function(val) {\n        this.realloc(8);\n        writeInt32(this.buf, val & -1, this.pos);\n        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);\n        this.pos += 8;\n    },\n\n    writeSFixed64: function(val) {\n        this.realloc(8);\n        writeInt32(this.buf, val & -1, this.pos);\n        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);\n        this.pos += 8;\n    },\n\n    writeVarint: function(val) {\n        val = +val || 0;\n\n        if (val > 0xfffffff || val < 0) {\n            writeBigVarint(val, this);\n            return;\n        }\n\n        this.realloc(4);\n\n        this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] =   (val >>> 7) & 0x7f;\n    },\n\n    writeSVarint: function(val) {\n        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);\n    },\n\n    writeBoolean: function(val) {\n        this.writeVarint(Boolean(val));\n    },\n\n    writeString: function(str) {\n        str = String(str);\n        this.realloc(str.length * 4);\n\n        this.pos++; // reserve 1 byte for short string length\n\n        var startPos = this.pos;\n        // write the string directly to the buffer and see how much was written\n        this.pos = writeUtf8(this.buf, str, this.pos);\n        var len = this.pos - startPos;\n\n        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);\n\n        // finally, write the message length in the reserved place and restore the position\n        this.pos = startPos - 1;\n        this.writeVarint(len);\n        this.pos += len;\n    },\n\n    writeFloat: function(val) {\n        this.realloc(4);\n        ieee754.write(this.buf, val, this.pos, true, 23, 4);\n        this.pos += 4;\n    },\n\n    writeDouble: function(val) {\n        this.realloc(8);\n        ieee754.write(this.buf, val, this.pos, true, 52, 8);\n        this.pos += 8;\n    },\n\n    writeBytes: function(buffer) {\n        var len = buffer.length;\n        this.writeVarint(len);\n        this.realloc(len);\n        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];\n    },\n\n    writeRawMessage: function(fn, obj) {\n        this.pos++; // reserve 1 byte for short message length\n\n        // write the message directly to the buffer and see how much was written\n        var startPos = this.pos;\n        fn(obj, this);\n        var len = this.pos - startPos;\n\n        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);\n\n        // finally, write the message length in the reserved place and restore the position\n        this.pos = startPos - 1;\n        this.writeVarint(len);\n        this.pos += len;\n    },\n\n    writeMessage: function(tag, fn, obj) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeRawMessage(fn, obj);\n    },\n\n    writePackedVarint:   function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedVarint, arr);   },\n    writePackedSVarint:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSVarint, arr);  },\n    writePackedBoolean:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedBoolean, arr);  },\n    writePackedFloat:    function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFloat, arr);    },\n    writePackedDouble:   function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedDouble, arr);   },\n    writePackedFixed32:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFixed32, arr);  },\n    writePackedSFixed32: function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSFixed32, arr); },\n    writePackedFixed64:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFixed64, arr);  },\n    writePackedSFixed64: function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSFixed64, arr); },\n\n    writeBytesField: function(tag, buffer) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeBytes(buffer);\n    },\n    writeFixed32Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeFixed32(val);\n    },\n    writeSFixed32Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeSFixed32(val);\n    },\n    writeFixed64Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeFixed64(val);\n    },\n    writeSFixed64Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeSFixed64(val);\n    },\n    writeVarintField: function(tag, val) {\n        this.writeTag(tag, Pbf.Varint);\n        this.writeVarint(val);\n    },\n    writeSVarintField: function(tag, val) {\n        this.writeTag(tag, Pbf.Varint);\n        this.writeSVarint(val);\n    },\n    writeStringField: function(tag, str) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeString(str);\n    },\n    writeFloatField: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeFloat(val);\n    },\n    writeDoubleField: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeDouble(val);\n    },\n    writeBooleanField: function(tag, val) {\n        this.writeVarintField(tag, Boolean(val));\n    }\n};\n\nfunction readVarintRemainder(l, s, p) {\n    var buf = p.buf,\n        h, b;\n\n    b = buf[p.pos++]; h  = (b & 0x70) >> 4;  if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 3;  if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 10; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 17; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 24; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x01) << 31; if (b < 0x80) return toNum(l, h, s);\n\n    throw new Error('Expected varint not more than 10 bytes');\n}\n\nfunction readPackedEnd(pbf) {\n    return pbf.type === Pbf.Bytes ?\n        pbf.readVarint() + pbf.pos : pbf.pos + 1;\n}\n\nfunction toNum(low, high, isSigned) {\n    if (isSigned) {\n        return high * 0x100000000 + (low >>> 0);\n    }\n\n    return ((high >>> 0) * 0x100000000) + (low >>> 0);\n}\n\nfunction writeBigVarint(val, pbf) {\n    var low, high;\n\n    if (val >= 0) {\n        low  = (val % 0x100000000) | 0;\n        high = (val / 0x100000000) | 0;\n    } else {\n        low  = ~(-val % 0x100000000);\n        high = ~(-val / 0x100000000);\n\n        if (low ^ 0xffffffff) {\n            low = (low + 1) | 0;\n        } else {\n            low = 0;\n            high = (high + 1) | 0;\n        }\n    }\n\n    if (val >= 0x10000000000000000 || val < -0x10000000000000000) {\n        throw new Error('Given varint doesn\\'t fit into 10 bytes');\n    }\n\n    pbf.realloc(10);\n\n    writeBigVarintLow(low, high, pbf);\n    writeBigVarintHigh(high, pbf);\n}\n\nfunction writeBigVarintLow(low, high, pbf) {\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos]   = low & 0x7f;\n}\n\nfunction writeBigVarintHigh(high, pbf) {\n    var lsb = (high & 0x07) << 4;\n\n    pbf.buf[pbf.pos++] |= lsb         | ((high >>>= 3) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f;\n}\n\nfunction makeRoomForExtraLength(startPos, len, pbf) {\n    var extraLen =\n        len <= 0x3fff ? 1 :\n        len <= 0x1fffff ? 2 :\n        len <= 0xfffffff ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));\n\n    // if 1 byte isn't enough for encoding message length, shift the data to the right\n    pbf.realloc(extraLen);\n    for (var i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];\n}\n\nfunction writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }\nfunction writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }\nfunction writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }\nfunction writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }\nfunction writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }\nfunction writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }\nfunction writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }\nfunction writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }\nfunction writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }\n\n// Buffer code below from https://github.com/feross/buffer, MIT-licensed\n\nfunction readUInt32(buf, pos) {\n    return ((buf[pos]) |\n        (buf[pos + 1] << 8) |\n        (buf[pos + 2] << 16)) +\n        (buf[pos + 3] * 0x1000000);\n}\n\nfunction writeInt32(buf, val, pos) {\n    buf[pos] = val;\n    buf[pos + 1] = (val >>> 8);\n    buf[pos + 2] = (val >>> 16);\n    buf[pos + 3] = (val >>> 24);\n}\n\nfunction readInt32(buf, pos) {\n    return ((buf[pos]) |\n        (buf[pos + 1] << 8) |\n        (buf[pos + 2] << 16)) +\n        (buf[pos + 3] << 24);\n}\n\nfunction readUtf8(buf, pos, end) {\n    var str = '';\n    var i = pos;\n\n    while (i < end) {\n        var b0 = buf[i];\n        var c = null; // codepoint\n        var bytesPerSequence =\n            b0 > 0xEF ? 4 :\n            b0 > 0xDF ? 3 :\n            b0 > 0xBF ? 2 : 1;\n\n        if (i + bytesPerSequence > end) break;\n\n        var b1, b2, b3;\n\n        if (bytesPerSequence === 1) {\n            if (b0 < 0x80) {\n                c = b0;\n            }\n        } else if (bytesPerSequence === 2) {\n            b1 = buf[i + 1];\n            if ((b1 & 0xC0) === 0x80) {\n                c = (b0 & 0x1F) << 0x6 | (b1 & 0x3F);\n                if (c <= 0x7F) {\n                    c = null;\n                }\n            }\n        } else if (bytesPerSequence === 3) {\n            b1 = buf[i + 1];\n            b2 = buf[i + 2];\n            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {\n                c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | (b2 & 0x3F);\n                if (c <= 0x7FF || (c >= 0xD800 && c <= 0xDFFF)) {\n                    c = null;\n                }\n            }\n        } else if (bytesPerSequence === 4) {\n            b1 = buf[i + 1];\n            b2 = buf[i + 2];\n            b3 = buf[i + 3];\n            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {\n                c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | (b3 & 0x3F);\n                if (c <= 0xFFFF || c >= 0x110000) {\n                    c = null;\n                }\n            }\n        }\n\n        if (c === null) {\n            c = 0xFFFD;\n            bytesPerSequence = 1;\n\n        } else if (c > 0xFFFF) {\n            c -= 0x10000;\n            str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);\n            c = 0xDC00 | c & 0x3FF;\n        }\n\n        str += String.fromCharCode(c);\n        i += bytesPerSequence;\n    }\n\n    return str;\n}\n\nfunction writeUtf8(buf, str, pos) {\n    for (var i = 0, c, lead; i < str.length; i++) {\n        c = str.charCodeAt(i); // code point\n\n        if (c > 0xD7FF && c < 0xE000) {\n            if (lead) {\n                if (c < 0xDC00) {\n                    buf[pos++] = 0xEF;\n                    buf[pos++] = 0xBF;\n                    buf[pos++] = 0xBD;\n                    lead = c;\n                    continue;\n                } else {\n                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;\n                    lead = null;\n                }\n            } else {\n                if (c > 0xDBFF || (i + 1 === str.length)) {\n                    buf[pos++] = 0xEF;\n                    buf[pos++] = 0xBF;\n                    buf[pos++] = 0xBD;\n                } else {\n                    lead = c;\n                }\n                continue;\n            }\n        } else if (lead) {\n            buf[pos++] = 0xEF;\n            buf[pos++] = 0xBF;\n            buf[pos++] = 0xBD;\n            lead = null;\n        }\n\n        if (c < 0x80) {\n            buf[pos++] = c;\n        } else {\n            if (c < 0x800) {\n                buf[pos++] = c >> 0x6 | 0xC0;\n            } else {\n                if (c < 0x10000) {\n                    buf[pos++] = c >> 0xC | 0xE0;\n                } else {\n                    buf[pos++] = c >> 0x12 | 0xF0;\n                    buf[pos++] = c >> 0xC & 0x3F | 0x80;\n                }\n                buf[pos++] = c >> 0x6 & 0x3F | 0x80;\n            }\n            buf[pos++] = c & 0x3F | 0x80;\n        }\n    }\n    return pos;\n}\n","// @flow\n\nimport { AlphaImage } from '../util/image';\n\nimport Protobuf from 'pbf';\nconst border = 3;\n\nimport type {StyleGlyph} from './style_glyph';\n\nfunction readFontstacks(tag: number, glyphs: Array<StyleGlyph>, pbf: Protobuf) {\n    if (tag === 1) {\n        pbf.readMessage(readFontstack, glyphs);\n    }\n}\n\nfunction readFontstack(tag: number, glyphs: Array<StyleGlyph>, pbf: Protobuf) {\n    if (tag === 3) {\n        const {id, bitmap, width, height, left, top, advance} = pbf.readMessage(readGlyph, {});\n        glyphs.push({\n            id,\n            bitmap: new AlphaImage({\n                width: width + 2 * border,\n                height: height + 2 * border\n            }, bitmap),\n            metrics: {width, height, left, top, advance}\n        });\n    }\n}\n\nfunction readGlyph(tag: number, glyph: Object, pbf: Protobuf) {\n    if (tag === 1) glyph.id = pbf.readVarint();\n    else if (tag === 2) glyph.bitmap = pbf.readBytes();\n    else if (tag === 3) glyph.width = pbf.readVarint();\n    else if (tag === 4) glyph.height = pbf.readVarint();\n    else if (tag === 5) glyph.left = pbf.readSVarint();\n    else if (tag === 6) glyph.top = pbf.readSVarint();\n    else if (tag === 7) glyph.advance = pbf.readVarint();\n}\n\nexport default function (data: ArrayBuffer | Uint8Array): Array<StyleGlyph> {\n    return new Protobuf(data).readFields(readFontstacks, []);\n}\n\nexport const GLYPH_PBF_BORDER = border;\n","// @flow\n\nimport { bindAll } from './util';\nimport { serialize, deserialize } from './web_worker_transfer';\n\nimport type {Transferable} from '../types/transferable';\nimport type {Cancelable} from '../types/cancelable';\n\n/**\n * An implementation of the [Actor design pattern](http://en.wikipedia.org/wiki/Actor_model)\n * that maintains the relationship between asynchronous tasks and the objects\n * that spin them off - in this case, tasks like parsing parts of styles,\n * owned by the styles\n *\n * @param {WebWorker} target\n * @param {WebWorker} parent\n * @param {string|number} mapId A unique identifier for the Map instance using this Actor.\n * @private\n */\nclass Actor {\n    target: any;\n    parent: any;\n    mapId: string;\n    callbacks: any;\n    callbackID: number;\n    name: string;\n\n    constructor(target: any, parent: any, mapId: any) {\n        this.target = target;\n        this.parent = parent;\n        this.mapId = mapId;\n        this.callbacks = {};\n        this.callbackID = 0;\n        bindAll(['receive'], this);\n        this.target.addEventListener('message', this.receive, false);\n    }\n\n    /**\n     * Sends a message from a main-thread map to a Worker or from a Worker back to\n     * a main-thread map instance.\n     *\n     * @param type The name of the target method to invoke or '[source-type].[source-name].name' for a method on a WorkerSource.\n     * @param targetMapId A particular mapId to which to send this message.\n     * @private\n     */\n    send(type: string, data: mixed, callback: ?Function, targetMapId: ?string): ?Cancelable {\n        const id = callback ? `${this.mapId}:${this.callbackID++}` : null;\n        if (callback) this.callbacks[id] = callback;\n        const buffers: Array<Transferable> = [];\n        this.target.postMessage({\n            targetMapId,\n            sourceMapId: this.mapId,\n            type,\n            id: String(id),\n            data: serialize(data, buffers)\n        }, buffers);\n        if (callback) {\n            return {\n                cancel: () => this.target.postMessage({\n                    targetMapId,\n                    sourceMapId: this.mapId,\n                    type: '<cancel>',\n                    id: String(id)\n                })\n            };\n        }\n    }\n\n    receive(message: Object) {\n        const data = message.data,\n            id = data.id;\n        let callback;\n\n        if (data.targetMapId && this.mapId !== data.targetMapId)\n            return;\n\n        const done = (err, data) => {\n            delete this.callbacks[id];\n            const buffers: Array<Transferable> = [];\n            this.target.postMessage({\n                sourceMapId: this.mapId,\n                type: '<response>',\n                id: String(id),\n                error: err ? serialize(err) : null,\n                data: serialize(data, buffers)\n            }, buffers);\n        };\n\n        if (data.type === '<response>' || data.type === '<cancel>') {\n            callback = this.callbacks[data.id];\n            delete this.callbacks[data.id];\n            if (callback && data.error) {\n                callback(deserialize(data.error));\n            } else if (callback) {\n                callback(null, deserialize(data.data));\n            }\n        } else if (typeof data.id !== 'undefined' && this.parent[data.type]) {\n            // data.type == 'loadTile', 'removeTile', etc.\n            // Add a placeholder so that we can discover when the done callback was called already.\n            this.callbacks[data.id] = null;\n            const cancelable = this.parent[data.type](data.sourceMapId, deserialize(data.data), done);\n            if (cancelable && this.callbacks[data.id] === null) {\n                // Only add the cancelable callback if the done callback wasn't already called.\n                // Otherwise we will never be able to delete it.\n                this.callbacks[data.id]  = cancelable;\n            }\n        } else if (typeof data.id !== 'undefined' && this.parent.getWorkerSource) {\n            // data.type == sourcetype.method\n            const keys = data.type.split('.');\n            const params = (deserialize(data.data): any);\n            const workerSource = (this.parent: any).getWorkerSource(data.sourceMapId, keys[0], params.source);\n            workerSource[keys[1]](params, done);\n        } else {\n            this.parent[data.type](deserialize(data.data));\n        }\n    }\n\n    remove() {\n        this.target.removeEventListener('message', this.receive, false);\n    }\n}\n\nexport default Actor;\n","export { getURL, getTileBBox, getMercCoords };\n\n\n/**\n * getURL\n *\n * @param    {String}  baseUrl  Base url of the WMS server\n * @param    {String}  layer    Layer name\n * @param    {Number}  x        Tile coordinate x\n * @param    {Number}  y        Tile coordinate y\n * @param    {Number}  z        Tile zoom\n * @param    {Object}  [options]\n * @param    {String}  [options.format='image/png']\n * @param    {String}  [options.service='WMS']\n * @param    {String}  [options.version='1.1.1']\n * @param    {String}  [options.request='GetMap']\n * @param    {String}  [options.srs='EPSG:3857']\n * @param    {Number}  [options.width='256']\n * @param    {Number}  [options.height='256']\n * @returns  {String}  url\n * @example\n * var baseUrl = 'http://geodata.state.nj.us/imagerywms/Natural2015';\n * var layer = 'Natural2015';\n * var url = whoots.getURL(baseUrl, layer, 154308, 197167, 19);\n */\nfunction getURL(baseUrl, layer, x, y, z, options) {\n    options = options || {};\n\n    var url = baseUrl + '?' + [\n        'bbox='    + getTileBBox(x, y, z),\n        'format='  + (options.format || 'image/png'),\n        'service=' + (options.service || 'WMS'),\n        'version=' + (options.version || '1.1.1'),\n        'request=' + (options.request || 'GetMap'),\n        'srs='     + (options.srs || 'EPSG:3857'),\n        'width='   + (options.width || 256),\n        'height='  + (options.height || 256),\n        'layers='  + layer\n    ].join('&');\n\n    return url;\n}\n\n\n/**\n * getTileBBox\n *\n * @param    {Number}  x  Tile coordinate x\n * @param    {Number}  y  Tile coordinate y\n * @param    {Number}  z  Tile zoom\n * @returns  {String}  String of the bounding box\n */\nfunction getTileBBox(x, y, z) {\n    // for Google/OSM tile scheme we need to alter the y\n    y = (Math.pow(2, z) - y - 1);\n\n    var min = getMercCoords(x * 256, y * 256, z),\n        max = getMercCoords((x + 1) * 256, (y + 1) * 256, z);\n\n    return min[0] + ',' + min[1] + ',' + max[0] + ',' + max[1];\n}\n\n\n/**\n * getMercCoords\n *\n * @param    {Number}  x  Pixel coordinate x\n * @param    {Number}  y  Pixel coordinate y\n * @param    {Number}  z  Tile zoom\n * @returns  {Array}   [x, y]\n */\nfunction getMercCoords(x, y, z) {\n    var resolution = (2 * Math.PI * 6378137 / 256) / Math.pow(2, z),\n        merc_x = (x * resolution - 2 * Math.PI  * 6378137 / 2.0),\n        merc_y = (y * resolution - 2 * Math.PI  * 6378137 / 2.0);\n\n    return [merc_x, merc_y];\n}\n","// @flow\n\nimport LngLat from './lng_lat';\n\nimport type {LngLatLike} from './lng_lat';\n\n/**\n * A `LngLatBounds` object represents a geographical bounding box,\n * defined by its southwest and northeast points in longitude and latitude.\n *\n * If no arguments are provided to the constructor, a `null` bounding box is created.\n *\n * Note that any Mapbox GL method that accepts a `LngLatBounds` object as an argument or option\n * can also accept an `Array` of two {@link LngLatLike} constructs and will perform an implicit conversion.\n * This flexible type is documented as {@link LngLatBoundsLike}.\n *\n * @param {LngLatLike} [sw] The southwest corner of the bounding box.\n * @param {LngLatLike} [ne] The northeast corner of the bounding box.\n * @example\n * var sw = new mapboxgl.LngLat(-73.9876, 40.7661);\n * var ne = new mapboxgl.LngLat(-73.9397, 40.8002);\n * var llb = new mapboxgl.LngLatBounds(sw, ne);\n */\nclass LngLatBounds {\n    _ne: LngLat;\n    _sw: LngLat;\n\n    // This constructor is too flexible to type. It should not be so flexible.\n    constructor(sw: any, ne: any) {\n        if (!sw) {\n            // noop\n        } else if (ne) {\n            this.setSouthWest(sw).setNorthEast(ne);\n        } else if (sw.length === 4) {\n            this.setSouthWest([sw[0], sw[1]]).setNorthEast([sw[2], sw[3]]);\n        } else {\n            this.setSouthWest(sw[0]).setNorthEast(sw[1]);\n        }\n    }\n\n    /**\n     * Set the northeast corner of the bounding box\n     *\n     * @param {LngLatLike} ne\n     * @returns {LngLatBounds} `this`\n     */\n    setNorthEast(ne: LngLatLike) {\n        this._ne = ne instanceof LngLat ? new LngLat(ne.lng, ne.lat) : LngLat.convert(ne);\n        return this;\n    }\n\n    /**\n     * Set the southwest corner of the bounding box\n     *\n     * @param {LngLatLike} sw\n     * @returns {LngLatBounds} `this`\n     */\n    setSouthWest(sw: LngLatLike) {\n        this._sw = sw instanceof LngLat ? new LngLat(sw.lng, sw.lat) : LngLat.convert(sw);\n        return this;\n    }\n\n    /**\n     * Extend the bounds to include a given LngLat or LngLatBounds.\n     *\n     * @param {LngLat|LngLatBounds} obj object to extend to\n     * @returns {LngLatBounds} `this`\n     */\n    extend(obj: LngLat | LngLatBounds) {\n        const sw = this._sw,\n            ne = this._ne;\n        let sw2, ne2;\n\n        if (obj instanceof LngLat) {\n            sw2 = obj;\n            ne2 = obj;\n\n        } else if (obj instanceof LngLatBounds) {\n            sw2 = obj._sw;\n            ne2 = obj._ne;\n\n            if (!sw2 || !ne2) return this;\n\n        } else {\n            if (Array.isArray(obj)) {\n                if (obj.every(Array.isArray)) {\n                    return this.extend(LngLatBounds.convert(obj));\n                } else {\n                    return this.extend(LngLat.convert(obj));\n                }\n            }\n            return this;\n        }\n\n        if (!sw && !ne) {\n            this._sw = new LngLat(sw2.lng, sw2.lat);\n            this._ne = new LngLat(ne2.lng, ne2.lat);\n\n        } else {\n            sw.lng = Math.min(sw2.lng, sw.lng);\n            sw.lat = Math.min(sw2.lat, sw.lat);\n            ne.lng = Math.max(ne2.lng, ne.lng);\n            ne.lat = Math.max(ne2.lat, ne.lat);\n        }\n\n        return this;\n    }\n\n    /**\n     * Returns the geographical coordinate equidistant from the bounding box's corners.\n     *\n     * @returns {LngLat} The bounding box's center.\n     * @example\n     * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n     * llb.getCenter(); // = LngLat {lng: -73.96365, lat: 40.78315}\n     */\n    getCenter(): LngLat {\n        return new LngLat((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);\n    }\n\n    /**\n     * Returns the southwest corner of the bounding box.\n     *\n     * @returns {LngLat} The southwest corner of the bounding box.\n     */\n    getSouthWest(): LngLat { return this._sw; }\n\n    /**\n    * Returns the northeast corner of the bounding box.\n    *\n    * @returns {LngLat} The northeast corner of the bounding box.\n     */\n    getNorthEast(): LngLat { return this._ne; }\n\n    /**\n    * Returns the northwest corner of the bounding box.\n    *\n    * @returns {LngLat} The northwest corner of the bounding box.\n     */\n    getNorthWest(): LngLat { return new LngLat(this.getWest(), this.getNorth()); }\n\n    /**\n    * Returns the southeast corner of the bounding box.\n    *\n    * @returns {LngLat} The southeast corner of the bounding box.\n     */\n    getSouthEast(): LngLat { return new LngLat(this.getEast(), this.getSouth()); }\n\n    /**\n    * Returns the west edge of the bounding box.\n    *\n    * @returns {number} The west edge of the bounding box.\n     */\n    getWest(): number { return this._sw.lng; }\n\n    /**\n    * Returns the south edge of the bounding box.\n    *\n    * @returns {number} The south edge of the bounding box.\n     */\n    getSouth(): number { return this._sw.lat; }\n\n    /**\n    * Returns the east edge of the bounding box.\n    *\n    * @returns {number} The east edge of the bounding box.\n     */\n    getEast(): number { return this._ne.lng; }\n\n    /**\n    * Returns the north edge of the bounding box.\n    *\n    * @returns {number} The north edge of the bounding box.\n     */\n    getNorth(): number { return this._ne.lat; }\n\n    /**\n     * Returns the bounding box represented as an array.\n     *\n     * @returns {Array<Array<number>>} The bounding box represented as an array, consisting of the\n     *   southwest and northeast coordinates of the bounding represented as arrays of numbers.\n     * @example\n     * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n     * llb.toArray(); // = [[-73.9876, 40.7661], [-73.9397, 40.8002]]\n     */\n    toArray() {\n        return [this._sw.toArray(), this._ne.toArray()];\n    }\n\n    /**\n     * Return the bounding box represented as a string.\n     *\n     * @returns {string} The bounding box represents as a string of the format\n     *   `'LngLatBounds(LngLat(lng, lat), LngLat(lng, lat))'`.\n     * @example\n     * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n     * llb.toString(); // = \"LngLatBounds(LngLat(-73.9876, 40.7661), LngLat(-73.9397, 40.8002))\"\n     */\n    toString() {\n        return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;\n    }\n\n    /**\n     * Check if the bounding box is an empty/`null`-type box.\n     *\n     * @returns {boolean} True if bounds have been defined, otherwise false.\n     */\n    isEmpty() {\n        return !(this._sw && this._ne);\n    }\n\n    /**\n     * Converts an array to a `LngLatBounds` object.\n     *\n     * If a `LngLatBounds` object is passed in, the function returns it unchanged.\n     *\n     * Internally, the function calls `LngLat#convert` to convert arrays to `LngLat` values.\n     *\n     * @param {LngLatBoundsLike} input An array of two coordinates to convert, or a `LngLatBounds` object to return.\n     * @returns {LngLatBounds} A new `LngLatBounds` object, if a conversion occurred, or the original `LngLatBounds` object.\n     * @example\n     * var arr = [[-73.9876, 40.7661], [-73.9397, 40.8002]];\n     * var llb = mapboxgl.LngLatBounds.convert(arr);\n     * llb;   // = LngLatBounds {_sw: LngLat {lng: -73.9876, lat: 40.7661}, _ne: LngLat {lng: -73.9397, lat: 40.8002}}\n     */\n    static convert(input: LngLatBoundsLike): LngLatBounds {\n        if (!input || input instanceof LngLatBounds) return input;\n        return new LngLatBounds(input);\n    }\n}\n\n/**\n * A {@link LngLatBounds} object, an array of {@link LngLatLike} objects in [sw, ne] order,\n * or an array of numbers in [west, south, east, north] order.\n *\n * @typedef {LngLatBounds | [LngLatLike, LngLatLike] | [number, number, number, number]} LngLatBoundsLike\n * @example\n * var v1 = new mapboxgl.LngLatBounds(\n *   new mapboxgl.LngLat(-73.9876, 40.7661),\n *   new mapboxgl.LngLat(-73.9397, 40.8002)\n * );\n * var v2 = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002])\n * var v3 = [[-73.9876, 40.7661], [-73.9397, 40.8002]];\n */\nexport type LngLatBoundsLike = LngLatBounds | [LngLatLike, LngLatLike] | [number, number, number, number];\n\nexport default LngLatBounds;\n","// @flow\n\nimport { wrap } from '../util/util';\nimport LngLatBounds from './lng_lat_bounds';\n\n/**\n * A `LngLat` object represents a given longitude and latitude coordinate, measured in degrees.\n *\n * Mapbox GL uses longitude, latitude coordinate order (as opposed to latitude, longitude) to match GeoJSON.\n *\n * Note that any Mapbox GL method that accepts a `LngLat` object as an argument or option\n * can also accept an `Array` of two numbers and will perform an implicit conversion.\n * This flexible type is documented as {@link LngLatLike}.\n *\n * @param {number} lng Longitude, measured in degrees.\n * @param {number} lat Latitude, measured in degrees.\n * @example\n * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);\n * @see [Get coordinates of the mouse pointer](https://www.mapbox.com/mapbox-gl-js/example/mouse-position/)\n * @see [Display a popup](https://www.mapbox.com/mapbox-gl-js/example/popup/)\n * @see [Highlight features within a bounding box](https://www.mapbox.com/mapbox-gl-js/example/using-box-queryrenderedfeatures/)\n * @see [Create a timeline animation](https://www.mapbox.com/mapbox-gl-js/example/timeline-animation/)\n */\nclass LngLat {\n    lng: number;\n    lat: number;\n\n    constructor(lng: number, lat: number) {\n        if (isNaN(lng) || isNaN(lat)) {\n            throw new Error(`Invalid LngLat object: (${lng}, ${lat})`);\n        }\n        this.lng = +lng;\n        this.lat = +lat;\n        if (this.lat > 90 || this.lat < -90) {\n            throw new Error('Invalid LngLat latitude value: must be between -90 and 90');\n        }\n    }\n\n    /**\n     * Returns a new `LngLat` object whose longitude is wrapped to the range (-180, 180).\n     *\n     * @returns {LngLat} The wrapped `LngLat` object.\n     * @example\n     * var ll = new mapboxgl.LngLat(286.0251, 40.7736);\n     * var wrapped = ll.wrap();\n     * wrapped.lng; // = -73.9749\n     */\n    wrap() {\n        return new LngLat(wrap(this.lng, -180, 180), this.lat);\n    }\n\n    /**\n     * Returns the coordinates represented as an array of two numbers.\n     *\n     * @returns {Array<number>} The coordinates represeted as an array of longitude and latitude.\n     * @example\n     * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);\n     * ll.toArray(); // = [-73.9749, 40.7736]\n     */\n    toArray() {\n        return [this.lng, this.lat];\n    }\n\n    /**\n     * Returns the coordinates represent as a string.\n     *\n     * @returns {string} The coordinates represented as a string of the format `'LngLat(lng, lat)'`.\n     * @example\n     * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);\n     * ll.toString(); // = \"LngLat(-73.9749, 40.7736)\"\n     */\n    toString() {\n        return `LngLat(${this.lng}, ${this.lat})`;\n    }\n\n    /**\n     * Returns a `LngLatBounds` from the coordinates extended by a given `radius`.\n     *\n     * @param {number} [radius=0] Distance in meters from the coordinates to extend the bounds.\n     * @returns {LngLatBounds} A new `LngLatBounds` object representing the coordinates extended by the `radius`.\n     * @example\n     * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);\n     * ll.toBounds(100).toArray(); // = [[-73.97501862141328, 40.77351016847229], [-73.97478137858673, 40.77368983152771]]\n     */\n    toBounds(radius?: number = 0) {\n        const earthCircumferenceInMetersAtEquator = 40075017;\n        const latAccuracy = 360 * radius / earthCircumferenceInMetersAtEquator,\n            lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);\n\n        return new LngLatBounds(new LngLat(this.lng - lngAccuracy, this.lat - latAccuracy),\n            new LngLat(this.lng + lngAccuracy, this.lat + latAccuracy));\n    }\n\n    /**\n     * Converts an array of two numbers or an object with `lng` and `lat` or `lon` and `lat` properties\n     * to a `LngLat` object.\n     *\n     * If a `LngLat` object is passed in, the function returns it unchanged.\n     *\n     * @param {LngLatLike} input An array of two numbers or object to convert, or a `LngLat` object to return.\n     * @returns {LngLat} A new `LngLat` object, if a conversion occurred, or the original `LngLat` object.\n     * @example\n     * var arr = [-73.9749, 40.7736];\n     * var ll = mapboxgl.LngLat.convert(arr);\n     * ll;   // = LngLat {lng: -73.9749, lat: 40.7736}\n     */\n    static convert(input: LngLatLike): LngLat {\n        if (input instanceof LngLat) {\n            return input;\n        }\n        if (Array.isArray(input) && (input.length === 2 || input.length === 3)) {\n            return new LngLat(Number(input[0]), Number(input[1]));\n        }\n        if (!Array.isArray(input) && typeof input === 'object' && input !== null) {\n            return new LngLat(\n                // flow can't refine this to have one of lng or lat, so we have to cast to any\n                Number('lng' in input ? (input: any).lng : (input: any).lon),\n                Number(input.lat)\n            );\n        }\n        throw new Error(\"`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]\");\n    }\n}\n\n/**\n * A {@link LngLat} object, an array of two numbers representing longitude and latitude,\n * or an object with `lng` and `lat` or `lon` and `lat` properties.\n *\n * @typedef {LngLat | {lng: number, lat: number} | {lon: number, lat: number} | [number, number]} LngLatLike\n * @example\n * var v1 = new mapboxgl.LngLat(-122.420679, 37.772537);\n * var v2 = [-122.420679, 37.772537];\n * var v3 = {lon: -122.420679, lat: 37.772537};\n */\nexport type LngLatLike = LngLat | {lng: number, lat: number} | {lon: number, lat: number} | [number, number];\n\nexport default LngLat;\n","// @flow\n\nimport LngLat from '../geo/lng_lat';\nimport type {LngLatLike} from '../geo/lng_lat';\n\n/*\n * The circumference of the world in meters at the given latitude.\n */\nfunction circumferenceAtLatitude(latitude: number) {\n    const circumference = 2 * Math.PI * 6378137;\n    return circumference * Math.cos(latitude * Math.PI / 180);\n}\n\nexport function mercatorXfromLng(lng: number) {\n    return (180 + lng) / 360;\n}\n\nexport function mercatorYfromLat(lat: number) {\n    return (180 - (180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360)))) / 360;\n}\n\nexport function mercatorZfromAltitude(altitude: number, lat: number) {\n    return altitude / circumferenceAtLatitude(lat);\n}\n\nexport function lngFromMercatorX(x: number) {\n    return x * 360 - 180;\n}\n\nexport function latFromMercatorY(y: number) {\n    const y2 = 180 - y * 360;\n    return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;\n}\n\nexport function altitudeFromMercatorZ(z: number, y: number) {\n    return z * circumferenceAtLatitude(latFromMercatorY(y));\n}\n\n/**\n * A `MercatorCoordinate` object represents a projected three dimensional position.\n *\n * `MercatorCoordinate` uses the web mercator projection ([EPSG:3857](https://epsg.io/3857)) with slightly different units:\n * - the size of 1 unit is the width of the projected world instead of the \"mercator meter\"\n * - the origin of the coordinate space is at the north-west corner instead of the middle\n *\n * For example, `MercatorCoordinate(0, 0, 0)` is the north-west corner of the mercator world and\n * `MercatorCoordinate(1, 1, 0)` is the south-east corner. If you are familiar with\n * [vector tiles](https://github.com/mapbox/vector-tile-spec) it may be helpful to think\n * of the coordinate space as the `0/0/0` tile with an extent of `1`.\n *\n * The `z` dimension of `MercatorCoordinate` is conformal. A cube in the mercator coordinate space would be rendered as a cube.\n *\n * @param {number} x The x component of the position.\n * @param {number} y The y component of the position.\n * @param {number} z The z component of the position.\n * @example\n * var nullIsland = new mapboxgl.MercatorCoordinate(0.5, 0.5, 0);\n *\n * @see [Add a custom style layer](https://www.mapbox.com/mapbox-gl-js/example/custom-style-layer/)\n */\nclass MercatorCoordinate {\n    x: number;\n    y: number;\n    z: number;\n\n    constructor(x: number, y: number, z: number = 0) {\n        this.x = +x;\n        this.y = +y;\n        this.z = +z;\n    }\n\n    /**\n     * Project a `LngLat` to a `MercatorCoordinate`.\n     *\n     * @param {LngLatLike} lngLatLike The location to project.\n     * @param {number} altitude The altitude in meters of the position.\n     * @returns {MercatorCoordinate} The projected mercator coordinate.\n     * @example\n     * var coord = mapboxgl.MercatorCoordinate.fromLngLat({ lng: 0, lat: 0}, 0);\n     * coord; // MercatorCoordinate(0.5, 0.5, 0)\n     */\n    static fromLngLat(lngLatLike: LngLatLike, altitude: number = 0) {\n        const lngLat = LngLat.convert(lngLatLike);\n\n        return new MercatorCoordinate(\n                mercatorXfromLng(lngLat.lng),\n                mercatorYfromLat(lngLat.lat),\n                mercatorZfromAltitude(altitude, lngLat.lat));\n    }\n\n    /**\n     * Returns the `LngLat` for the coordinate.\n     *\n     * @returns {LngLat} The `LngLat` object.\n     * @example\n     * var coord = new mapboxgl.MercatorCoordinate(0.5, 0.5, 0);\n     * var latLng = coord.toLngLat(); // LngLat(0, 0)\n     */\n    toLngLat() {\n        return new LngLat(\n                lngFromMercatorX(this.x),\n                latFromMercatorY(this.y));\n    }\n\n    /**\n     * Returns the altitude in meters of the coordinate.\n     *\n     * @returns {number} The altitude in meters.\n     * @example\n     * var coord = new mapboxgl.MercatorCoordinate(0, 0, 0.02);\n     * coord.toAltitude(); // 6914.281956295339\n     */\n    toAltitude() {\n        return altitudeFromMercatorZ(this.z, this.y);\n    }\n}\n\nexport default MercatorCoordinate;\n","// @flow\n\nimport {getTileBBox} from '@mapbox/whoots-js';\nimport EXTENT from '../data/extent';\nimport Point from '@mapbox/point-geometry';\nimport MercatorCoordinate from '../geo/mercator_coordinate';\n\nimport assert from 'assert';\nimport { register } from '../util/web_worker_transfer';\n\nexport class CanonicalTileID {\n    z: number;\n    x: number;\n    y: number;\n    key: number;\n\n    constructor(z: number, x: number, y: number) {\n        assert(z >= 0 && z <= 25);\n        assert(x >= 0 && x < Math.pow(2, z));\n        assert(y >= 0 && y < Math.pow(2, z));\n        this.z = z;\n        this.x = x;\n        this.y = y;\n        this.key = calculateKey(0, z, x, y);\n    }\n\n    equals(id: CanonicalTileID) {\n        return this.z === id.z && this.x === id.x && this.y === id.y;\n    }\n\n    // given a list of urls, choose a url template and return a tile URL\n    url(urls: Array<string>, scheme: ?string) {\n        const bbox = getTileBBox(this.x, this.y, this.z);\n        const quadkey = getQuadkey(this.z, this.x, this.y);\n\n        return urls[(this.x + this.y) % urls.length]\n            .replace('{prefix}', (this.x % 16).toString(16) + (this.y % 16).toString(16))\n            .replace('{z}', String(this.z))\n            .replace('{x}', String(this.x))\n            .replace('{y}', String(scheme === 'tms' ? (Math.pow(2, this.z) - this.y - 1) : this.y))\n            .replace('{quadkey}', quadkey)\n            .replace('{bbox-epsg-3857}', bbox);\n    }\n\n    getTilePoint(coord: MercatorCoordinate) {\n        const tilesAtZoom = Math.pow(2, this.z);\n        return new Point(\n            (coord.x * tilesAtZoom - this.x) * EXTENT,\n            (coord.y * tilesAtZoom - this.y) * EXTENT);\n    }\n}\n\nexport class UnwrappedTileID {\n    wrap: number;\n    canonical: CanonicalTileID;\n    key: number;\n\n    constructor(wrap: number, canonical: CanonicalTileID) {\n        this.wrap = wrap;\n        this.canonical = canonical;\n        this.key = calculateKey(wrap, canonical.z, canonical.x, canonical.y);\n    }\n}\n\nexport class OverscaledTileID {\n    overscaledZ: number;\n    wrap: number;\n    canonical: CanonicalTileID;\n    key: number;\n    posMatrix: Float32Array;\n\n    constructor(overscaledZ: number, wrap: number, z: number, x: number, y: number) {\n        assert(overscaledZ >= z);\n        this.overscaledZ = overscaledZ;\n        this.wrap = wrap;\n        this.canonical = new CanonicalTileID(z, +x, +y);\n        this.key = calculateKey(wrap, overscaledZ, x, y);\n    }\n\n    equals(id: OverscaledTileID) {\n        return this.overscaledZ === id.overscaledZ && this.wrap === id.wrap && this.canonical.equals(id.canonical);\n    }\n\n    scaledTo(targetZ: number) {\n        assert(targetZ <= this.overscaledZ);\n        const zDifference = this.canonical.z - targetZ;\n        if (targetZ > this.canonical.z) {\n            return new OverscaledTileID(targetZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);\n        } else {\n            return new OverscaledTileID(targetZ, this.wrap, targetZ, this.canonical.x >> zDifference, this.canonical.y >> zDifference);\n        }\n    }\n\n    isChildOf(parent: OverscaledTileID) {\n        if (parent.wrap !== this.wrap) {\n            // We can't be a child if we're in a different world copy\n            return false;\n        }\n        const zDifference = this.canonical.z - parent.canonical.z;\n        // We're first testing for z == 0, to avoid a 32 bit shift, which is undefined.\n        return parent.overscaledZ === 0 || (\n            parent.overscaledZ < this.overscaledZ &&\n                parent.canonical.x === (this.canonical.x >> zDifference) &&\n                parent.canonical.y === (this.canonical.y >> zDifference));\n    }\n\n    children(sourceMaxZoom: number) {\n        if (this.overscaledZ >= sourceMaxZoom) {\n            // return a single tile coord representing a an overscaled tile\n            return [new OverscaledTileID(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];\n        }\n\n        const z = this.canonical.z + 1;\n        const x = this.canonical.x * 2;\n        const y = this.canonical.y * 2;\n        return [\n            new OverscaledTileID(z, this.wrap, z, x, y),\n            new OverscaledTileID(z, this.wrap, z, x + 1, y),\n            new OverscaledTileID(z, this.wrap, z, x, y + 1),\n            new OverscaledTileID(z, this.wrap, z, x + 1, y + 1)\n        ];\n    }\n\n    isLessThan(rhs: OverscaledTileID) {\n        if (this.wrap < rhs.wrap) return true;\n        if (this.wrap > rhs.wrap) return false;\n\n        if (this.overscaledZ < rhs.overscaledZ) return true;\n        if (this.overscaledZ > rhs.overscaledZ) return false;\n\n        if (this.canonical.x < rhs.canonical.x) return true;\n        if (this.canonical.x > rhs.canonical.x) return false;\n\n        if (this.canonical.y < rhs.canonical.y) return true;\n        return false;\n    }\n\n    wrapped() {\n        return new OverscaledTileID(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);\n    }\n\n    unwrapTo(wrap: number) {\n        return new OverscaledTileID(this.overscaledZ, wrap, this.canonical.z, this.canonical.x, this.canonical.y);\n    }\n\n    overscaleFactor() {\n        return Math.pow(2, this.overscaledZ - this.canonical.z);\n    }\n\n    toUnwrapped() {\n        return new UnwrappedTileID(this.wrap, this.canonical);\n    }\n\n    toString() {\n        return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;\n    }\n\n    getTilePoint(coord: MercatorCoordinate) {\n        return this.canonical.getTilePoint(new MercatorCoordinate(coord.x - this.wrap, coord.y));\n    }\n}\n\nfunction calculateKey(wrap: number, z: number, x: number, y: number) {\n    wrap *= 2;\n    if (wrap < 0) wrap = wrap * -1 - 1;\n    const dim = 1 << z;\n    return ((dim * dim * wrap + dim * y + x) * 32) + z;\n}\n\n\nfunction getQuadkey(z, x, y) {\n    let quadkey = '', mask;\n    for (let i = z; i > 0; i--) {\n        mask = 1 << (i - 1);\n        quadkey += ((x & mask ? 1 : 0) + (y & mask ? 2 : 0));\n    }\n    return quadkey;\n}\n\nregister('CanonicalTileID', CanonicalTileID);\nregister('OverscaledTileID', OverscaledTileID, {omit: ['posMatrix']});\n","// @flow\nimport { RGBAImage } from '../util/image';\n\nimport { warnOnce } from '../util/util';\nimport { register } from '../util/web_worker_transfer';\n\n// DEMData is a data structure for decoding, backfilling, and storing elevation data for processing in the hillshade shaders\n// data can be populated either from a pngraw image tile or from serliazed data sent back from a worker. When data is initially\n// loaded from a image tile, we decode the pixel values using the appropriate decoding formula, but we store the\n// elevation data as an Int32 value. we add 65536 (2^16) to eliminate negative values and enable the use of\n// integer overflow when creating the texture used in the hillshadePrepare step.\n\n// DEMData also handles the backfilling of data from a tile's neighboring tiles. This is necessary because we use a pixel's 8\n// surrounding pixel values to compute the slope at that pixel, and we cannot accurately calculate the slope at pixels on a\n// tile's edge without backfilling from neighboring tiles.\n\nexport default class DEMData {\n    uid: string;\n    data: Int32Array;\n    stride: number;\n    dim: number;\n\n    constructor(uid: string, data: RGBAImage, encoding: \"mapbox\" | \"terrarium\") {\n        this.uid = uid;\n        if (data.height !== data.width) throw new RangeError('DEM tiles must be square');\n        if (encoding && encoding !== \"mapbox\" && encoding !== \"terrarium\") return warnOnce(\n            `\"${encoding}\" is not a valid encoding type. Valid types include \"mapbox\" and \"terrarium\".`\n        );\n        const dim = this.dim = data.height;\n        this.stride = this.dim + 2;\n        this.data = new Int32Array(this.stride * this.stride);\n\n        const pixels = data.data;\n        const unpack = encoding === \"terrarium\" ? this._unpackTerrarium : this._unpackMapbox;\n        for (let y = 0; y < dim; y++) {\n            for (let x = 0; x < dim; x++) {\n                const i = y * dim + x;\n                const j = i * 4;\n                this.set(x, y, unpack(pixels[j], pixels[j + 1], pixels[j + 2]));\n            }\n        }\n\n        // in order to avoid flashing seams between tiles, here we are initially populating a 1px border of pixels around the image\n        // with the data of the nearest pixel from the image. this data is eventually replaced when the tile's neighboring\n        // tiles are loaded and the accurate data can be backfilled using DEMData#backfillBorder\n        for (let x = 0; x < dim; x++) {\n            // left vertical border\n            this.set(-1, x, this.get(0, x));\n            // right vertical border\n            this.set(dim, x, this.get(dim - 1, x));\n            // left horizontal border\n            this.set(x, -1, this.get(x, 0));\n            // right horizontal border\n            this.set(x, dim, this.get(x, dim - 1));\n        }\n        // corners\n        this.set(-1, -1, this.get(0, 0));\n        this.set(dim, -1, this.get(dim - 1, 0));\n        this.set(-1, dim, this.get(0, dim - 1));\n        this.set(dim, dim, this.get(dim - 1, dim - 1));\n    }\n\n    set(x: number, y: number, value: number) {\n        this.data[this._idx(x, y)] = value + 65536;\n    }\n\n    get(x: number, y: number) {\n        return this.data[this._idx(x, y)] - 65536;\n    }\n\n    _idx(x: number, y: number) {\n        if (x < -1 || x >= this.dim + 1 ||  y < -1 || y >= this.dim + 1) throw new RangeError('out of range source coordinates for DEM data');\n        return (y + 1) * this.stride + (x + 1);\n    }\n\n    _unpackMapbox(r: number, g: number, b: number) {\n        // unpacking formula for mapbox.terrain-rgb:\n        // https://www.mapbox.com/help/access-elevation-data/#mapbox-terrain-rgb\n        return ((r * 256 * 256 + g * 256.0 + b) / 10.0 - 10000.0);\n    }\n\n    _unpackTerrarium(r: number, g: number, b: number) {\n        // unpacking formula for mapzen terrarium:\n        // https://aws.amazon.com/public-datasets/terrain/\n        return ((r * 256 + g + b / 256) - 32768.0);\n    }\n\n    getPixels() {\n        return new RGBAImage({width: this.stride, height: this.stride}, new Uint8Array(this.data.buffer));\n    }\n\n    backfillBorder(borderTile: DEMData, dx: number, dy: number) {\n        if (this.dim !== borderTile.dim) throw new Error('dem dimension mismatch');\n\n        let xMin = dx * this.dim,\n            xMax = dx * this.dim + this.dim,\n            yMin = dy * this.dim,\n            yMax = dy * this.dim + this.dim;\n\n        switch (dx) {\n        case -1:\n            xMin = xMax - 1;\n            break;\n        case 1:\n            xMax = xMin + 1;\n            break;\n        }\n\n        switch (dy) {\n        case -1:\n            yMin = yMax - 1;\n            break;\n        case 1:\n            yMax = yMin + 1;\n            break;\n        }\n\n        const ox = -dx * this.dim;\n        const oy = -dy * this.dim;\n        for (let y = yMin; y < yMax; y++) {\n            for (let x = xMin; x < xMax; x++) {\n                this.set(x, y, borderTile.get(x + ox, y + oy));\n            }\n        }\n    }\n}\n\nregister('DEMData', DEMData);\n","// @flow\n\nimport assert from 'assert';\n\nclass DictionaryCoder {\n    _stringToNumber: { [string]: number };\n    _numberToString: Array<string>;\n\n    constructor(strings: Array<string>) {\n        this._stringToNumber = {};\n        this._numberToString = [];\n        for (let i = 0; i < strings.length; i++) {\n            const string = strings[i];\n            this._stringToNumber[string] = i;\n            this._numberToString[i] = string;\n        }\n    }\n\n    encode(string: string) {\n        assert(string in this._stringToNumber);\n        return this._stringToNumber[string];\n    }\n\n    decode(n: number) {\n        assert(n < this._numberToString.length);\n        return this._numberToString[n];\n    }\n}\n\nexport default DictionaryCoder;\n","// @flow\nimport type {GeoJSONGeometry} from '@mapbox/geojson-types';\n\nclass Feature {\n    type: 'Feature';\n    _geometry: ?GeoJSONGeometry;\n    properties: {};\n    id: number | string | void;\n\n    _vectorTileFeature: VectorTileFeature;\n\n    constructor(vectorTileFeature: VectorTileFeature, z: number, x: number, y: number) {\n        this.type = 'Feature';\n\n        this._vectorTileFeature = vectorTileFeature;\n        (vectorTileFeature: any)._z = z;\n        (vectorTileFeature: any)._x = x;\n        (vectorTileFeature: any)._y = y;\n\n        this.properties = vectorTileFeature.properties;\n\n        if (vectorTileFeature.id != null) {\n            this.id = vectorTileFeature.id;\n        }\n    }\n\n    get geometry(): ?GeoJSONGeometry {\n        if (this._geometry === undefined) {\n            this._geometry = this._vectorTileFeature.toGeoJSON(\n                (this._vectorTileFeature: any)._x,\n                (this._vectorTileFeature: any)._y,\n                (this._vectorTileFeature: any)._z).geometry;\n        }\n        return this._geometry;\n    }\n\n    set geometry(g: ?GeoJSONGeometry) {\n        this._geometry = g;\n    }\n\n    toJSON() {\n        const json = {\n            geometry: this.geometry\n        };\n        for (const i in this) {\n            if (i === '_geometry' || i === '_vectorTileFeature') continue;\n            json[i] = (this: any)[i];\n        }\n        return json;\n    }\n}\n\nexport default Feature;\n","// @flow\n\nimport { extend } from '../util/util';\nimport Tile from './tile';\nimport type {FeatureState} from '../style-spec/expression';\n\nexport type FeatureStates = {[feature_id: string]: FeatureState};\nexport type LayerFeatureStates = {[layer: string]: FeatureStates};\n\n/**\n * SourceFeatureState manages the state and pending changes\n * to features in a source, separated by source layer.\n * stateChanges and deletedStates batch all changes to the tile (updates and removes, respectively)\n * between coalesce() events. addFeatureState() and removeFeatureState() also update their counterpart's\n * list of changes, such that coalesce() can apply the proper state changes while agnostic to the order of operations.\n * In deletedStates, all null's denote complete removal of state at that scope\n * @private\n*/\nclass SourceFeatureState {\n    state: LayerFeatureStates;\n    stateChanges: LayerFeatureStates;\n    deletedStates: {};\n\n    constructor() {\n        this.state = {};\n        this.stateChanges = {};\n        this.deletedStates = {};\n    }\n\n    updateState(sourceLayer: string, featureId: number, newState: Object) {\n        const feature = String(featureId);\n        this.stateChanges[sourceLayer] = this.stateChanges[sourceLayer] || {};\n        this.stateChanges[sourceLayer][feature] = this.stateChanges[sourceLayer][feature] || {};\n        extend(this.stateChanges[sourceLayer][feature], newState);\n\n        if (this.deletedStates[sourceLayer] === null) {\n            this.deletedStates[sourceLayer] = {};\n            for (const ft in this.state[sourceLayer]) {\n                if (ft !== feature) this.deletedStates[sourceLayer][ft] = null;\n            }\n        } else {\n            const featureDeletionQueued = this.deletedStates[sourceLayer] && this.deletedStates[sourceLayer][feature] === null;\n            if (featureDeletionQueued) {\n                this.deletedStates[sourceLayer][feature] = {};\n                for (const prop in this.state[sourceLayer][feature]) {\n                    if (!newState[prop]) this.deletedStates[sourceLayer][feature][prop] = null;\n                }\n            } else {\n                for (const key in newState) {\n                    const deletionInQueue = this.deletedStates[sourceLayer] && this.deletedStates[sourceLayer][feature] && this.deletedStates[sourceLayer][feature][key] === null;\n                    if (deletionInQueue) delete this.deletedStates[sourceLayer][feature][key];\n                }\n            }\n        }\n    }\n\n    removeFeatureState(sourceLayer: string, featureId?: number, key?: string) {\n        const sourceLayerDeleted = this.deletedStates[sourceLayer] === null;\n        if (sourceLayerDeleted) return;\n\n        const feature = String(featureId);\n\n        this.deletedStates[sourceLayer] = this.deletedStates[sourceLayer] || {};\n\n        if (key && featureId) {\n            if (this.deletedStates[sourceLayer][feature] !== null) {\n                this.deletedStates[sourceLayer][feature] = this.deletedStates[sourceLayer][feature] || {};\n                this.deletedStates[sourceLayer][feature][key] = null;\n            }\n        } else if (featureId) {\n            const updateInQueue = this.stateChanges[sourceLayer] && this.stateChanges[sourceLayer][feature];\n            if (updateInQueue) {\n                this.deletedStates[sourceLayer][feature] = {};\n                for (key in this.stateChanges[sourceLayer][feature]) this.deletedStates[sourceLayer][feature][key] = null;\n\n            } else {\n                this.deletedStates[sourceLayer][feature] = null;\n            }\n        } else {\n            this.deletedStates[sourceLayer] = null;\n        }\n\n    }\n\n    getState(sourceLayer: string, featureId: number) {\n        const feature = String(featureId);\n        const base = this.state[sourceLayer] || {};\n        const changes = this.stateChanges[sourceLayer] || {};\n\n        const reconciledState = extend({}, base[feature], changes[feature]);\n\n        //return empty object if the whole source layer is awaiting deletion\n        if (this.deletedStates[sourceLayer] === null) return {};\n        else if (this.deletedStates[sourceLayer]) {\n            const featureDeletions = this.deletedStates[sourceLayer][featureId];\n            if (featureDeletions === null) return {};\n            for (const prop in featureDeletions) delete reconciledState[prop];\n        }\n        return reconciledState;\n    }\n\n    initializeTileState(tile: Tile, painter: any) {\n        tile.setFeatureState(this.state, painter);\n    }\n\n    coalesceChanges(tiles: {[any]: Tile}, painter: any) {\n        //track changes with full state objects, but only for features that got modified\n        const featuresChanged: LayerFeatureStates = {};\n\n        for (const sourceLayer in this.stateChanges) {\n            this.state[sourceLayer]  = this.state[sourceLayer] || {};\n            const layerStates = {};\n            for (const feature in this.stateChanges[sourceLayer]) {\n                if (!this.state[sourceLayer][feature]) this.state[sourceLayer][feature] = {};\n                extend(this.state[sourceLayer][feature], this.stateChanges[sourceLayer][feature]);\n                layerStates[feature] = this.state[sourceLayer][feature];\n            }\n            featuresChanged[sourceLayer] = layerStates;\n        }\n\n        for (const sourceLayer in this.deletedStates) {\n            this.state[sourceLayer]  = this.state[sourceLayer] || {};\n            const layerStates = {};\n\n            if (this.deletedStates[sourceLayer] === null) {\n                for (const ft in this.state[sourceLayer]) layerStates[ft] = {};\n                this.state[sourceLayer] = {};\n            } else {\n                for (const feature in this.deletedStates[sourceLayer]) {\n                    const deleteWholeFeatureState = this.deletedStates[sourceLayer][feature] === null;\n                    if (deleteWholeFeatureState) this.state[sourceLayer][feature] = {};\n                    else {\n                        for (const key of Object.keys(this.deletedStates[sourceLayer][feature])) {\n                            delete this.state[sourceLayer][feature][key];\n                        }\n                    }\n                    layerStates[feature] = this.state[sourceLayer][feature];\n                }\n            }\n\n            featuresChanged[sourceLayer] = featuresChanged[sourceLayer] || {};\n            extend(featuresChanged[sourceLayer], layerStates);\n        }\n\n        this.stateChanges = {};\n        this.deletedStates = {};\n\n        if (Object.keys(featuresChanged).length === 0) return;\n\n        for (const id in tiles) {\n            const tile = tiles[id];\n            tile.setFeatureState(featuresChanged, painter);\n        }\n    }\n}\n\nexport default SourceFeatureState;\n","// @flow\n\nimport Point from '@mapbox/point-geometry';\n\nimport loadGeometry from './load_geometry';\nimport EXTENT from './extent';\nimport featureFilter from '../style-spec/feature_filter';\nimport Grid from 'grid-index';\nimport DictionaryCoder from '../util/dictionary_coder';\nimport vt from '@mapbox/vector-tile';\nimport Protobuf from 'pbf';\nimport GeoJSONFeature from '../util/vectortile_to_geojson';\nimport { arraysIntersect } from '../util/util';\nimport { OverscaledTileID } from '../source/tile_id';\nimport { register } from '../util/web_worker_transfer';\nimport EvaluationParameters from '../style/evaluation_parameters';\nimport SourceFeatureState from '../source/source_state';\nimport {polygonIntersectsBox} from '../util/intersection_tests';\n\nimport type StyleLayer from '../style/style_layer';\nimport type {FeatureFilter} from '../style-spec/feature_filter';\nimport type Transform from '../geo/transform';\nimport type {FilterSpecification} from '../style-spec/types';\n\nimport { FeatureIndexArray } from './array_types';\n\ntype QueryParameters = {\n    scale: number,\n    pixelPosMatrix: Float32Array,\n    transform: Transform,\n    tileSize: number,\n    queryGeometry: Array<Point>,\n    cameraQueryGeometry: Array<Point>,\n    queryPadding: number,\n    params: {\n        filter: FilterSpecification,\n        layers: Array<string>,\n    }\n}\n\nclass FeatureIndex {\n    tileID: OverscaledTileID;\n    x: number;\n    y: number;\n    z: number;\n    grid: Grid;\n    grid3D: Grid;\n    featureIndexArray: FeatureIndexArray;\n\n    rawTileData: ArrayBuffer;\n    bucketLayerIDs: Array<Array<string>>;\n\n    vtLayers: {[string]: VectorTileLayer};\n    sourceLayerCoder: DictionaryCoder;\n\n    constructor(tileID: OverscaledTileID,\n                grid?: Grid,\n                featureIndexArray?: FeatureIndexArray) {\n        this.tileID = tileID;\n        this.x = tileID.canonical.x;\n        this.y = tileID.canonical.y;\n        this.z = tileID.canonical.z;\n        this.grid = grid || new Grid(EXTENT, 16, 0);\n        this.grid3D = new Grid(EXTENT, 16, 0);\n        this.featureIndexArray = featureIndexArray || new FeatureIndexArray();\n    }\n\n    insert(feature: VectorTileFeature, geometry: Array<Array<Point>>, featureIndex: number, sourceLayerIndex: number, bucketIndex: number, is3D?: boolean) {\n        const key = this.featureIndexArray.length;\n        this.featureIndexArray.emplaceBack(featureIndex, sourceLayerIndex, bucketIndex);\n\n        const grid = is3D ? this.grid3D : this.grid;\n\n        for (let r = 0; r < geometry.length; r++) {\n            const ring = geometry[r];\n\n            const bbox = [Infinity, Infinity, -Infinity, -Infinity];\n            for (let i = 0; i < ring.length; i++) {\n                const p = ring[i];\n                bbox[0] = Math.min(bbox[0], p.x);\n                bbox[1] = Math.min(bbox[1], p.y);\n                bbox[2] = Math.max(bbox[2], p.x);\n                bbox[3] = Math.max(bbox[3], p.y);\n            }\n\n            if (bbox[0] < EXTENT &&\n                bbox[1] < EXTENT &&\n                bbox[2] >= 0 &&\n                bbox[3] >= 0) {\n                grid.insert(key, bbox[0], bbox[1], bbox[2], bbox[3]);\n            }\n        }\n    }\n\n    loadVTLayers(): {[string]: VectorTileLayer} {\n        if (!this.vtLayers) {\n            this.vtLayers = new vt.VectorTile(new Protobuf(this.rawTileData)).layers;\n            this.sourceLayerCoder = new DictionaryCoder(this.vtLayers ? Object.keys(this.vtLayers).sort() : ['_geojsonTileLayer']);\n        }\n        return this.vtLayers;\n    }\n\n    // Finds non-symbol features in this tile at a particular position.\n    query(args: QueryParameters, styleLayers: {[string]: StyleLayer}, sourceFeatureState: SourceFeatureState): {[string]: Array<{ featureIndex: number, feature: GeoJSONFeature }>} {\n        this.loadVTLayers();\n\n        const params = args.params || {},\n            pixelsToTileUnits = EXTENT / args.tileSize / args.scale,\n            filter = featureFilter(params.filter);\n\n        const queryGeometry = args.queryGeometry;\n        const queryPadding = args.queryPadding * pixelsToTileUnits;\n\n        const bounds = getBounds(queryGeometry);\n        const matching = this.grid.query(bounds.minX - queryPadding, bounds.minY - queryPadding, bounds.maxX + queryPadding, bounds.maxY + queryPadding);\n\n        const cameraBounds = getBounds(args.cameraQueryGeometry);\n        const matching3D = this.grid3D.query(\n                cameraBounds.minX - queryPadding, cameraBounds.minY - queryPadding, cameraBounds.maxX + queryPadding, cameraBounds.maxY + queryPadding,\n                (bx1, by1, bx2, by2) => {\n                    return polygonIntersectsBox(args.cameraQueryGeometry, bx1 - queryPadding, by1 - queryPadding, bx2 + queryPadding, by2 + queryPadding);\n                });\n\n        for (const key of matching3D) {\n            matching.push(key);\n        }\n\n        matching.sort(topDownFeatureComparator);\n\n        const result = {};\n        let previousIndex;\n        for (let k = 0; k < matching.length; k++) {\n            const index = matching[k];\n\n            // don't check the same feature more than once\n            if (index === previousIndex) continue;\n            previousIndex = index;\n\n            const match = this.featureIndexArray.get(index);\n            let featureGeometry = null;\n            this.loadMatchingFeature(\n                result,\n                match.bucketIndex,\n                match.sourceLayerIndex,\n                match.featureIndex,\n                filter,\n                params.layers,\n                styleLayers,\n                (feature: VectorTileFeature, styleLayer: StyleLayer) => {\n                    if (!featureGeometry) {\n                        featureGeometry = loadGeometry(feature);\n                    }\n                    let featureState = {};\n                    if (feature.id) {\n                        // `feature-state` expression evaluation requires feature state to be available\n                        featureState = sourceFeatureState.getState(styleLayer.sourceLayer || '_geojsonTileLayer', feature.id);\n                    }\n                    return styleLayer.queryIntersectsFeature(queryGeometry, feature, featureState, featureGeometry, this.z, args.transform, pixelsToTileUnits, args.pixelPosMatrix);\n                }\n            );\n        }\n\n        return result;\n    }\n\n    loadMatchingFeature(\n        result: {[string]: Array<{ featureIndex: number, feature: GeoJSONFeature }>},\n        bucketIndex: number,\n        sourceLayerIndex: number,\n        featureIndex: number,\n        filter: FeatureFilter,\n        filterLayerIDs: Array<string>,\n        styleLayers: {[string]: StyleLayer},\n        intersectionTest?: (feature: VectorTileFeature, styleLayer: StyleLayer) => boolean | number) {\n\n        const layerIDs = this.bucketLayerIDs[bucketIndex];\n        if (filterLayerIDs && !arraysIntersect(filterLayerIDs, layerIDs))\n            return;\n\n        const sourceLayerName = this.sourceLayerCoder.decode(sourceLayerIndex);\n        const sourceLayer = this.vtLayers[sourceLayerName];\n        const feature = sourceLayer.feature(featureIndex);\n\n        if (!filter(new EvaluationParameters(this.tileID.overscaledZ), feature))\n            return;\n\n        for (let l = 0; l < layerIDs.length; l++) {\n            const layerID = layerIDs[l];\n\n            if (filterLayerIDs && filterLayerIDs.indexOf(layerID) < 0) {\n                continue;\n            }\n\n            const styleLayer = styleLayers[layerID];\n            if (!styleLayer) continue;\n\n            const intersectionZ = !intersectionTest || intersectionTest(feature, styleLayer);\n            if (!intersectionZ) {\n                // Only applied for non-symbol features\n                continue;\n            }\n\n            const geojsonFeature = new GeoJSONFeature(feature, this.z, this.x, this.y);\n            (geojsonFeature: any).layer = styleLayer.serialize();\n            let layerResult = result[layerID];\n            if (layerResult === undefined) {\n                layerResult = result[layerID] = [];\n            }\n            layerResult.push({ featureIndex, feature: geojsonFeature, intersectionZ });\n        }\n    }\n\n    // Given a set of symbol indexes that have already been looked up,\n    // return a matching set of GeoJSONFeatures\n    lookupSymbolFeatures(symbolFeatureIndexes: Array<number>,\n                         bucketIndex: number,\n                         sourceLayerIndex: number,\n                         filterSpec: FilterSpecification,\n                         filterLayerIDs: Array<string>,\n                         styleLayers: {[string]: StyleLayer}) {\n        const result = {};\n        this.loadVTLayers();\n\n        const filter = featureFilter(filterSpec);\n\n        for (const symbolFeatureIndex of symbolFeatureIndexes) {\n            this.loadMatchingFeature(\n                result,\n                bucketIndex,\n                sourceLayerIndex,\n                symbolFeatureIndex,\n                filter,\n                filterLayerIDs,\n                styleLayers\n            );\n\n        }\n        return result;\n    }\n\n    hasLayer(id: string) {\n        for (const layerIDs of this.bucketLayerIDs) {\n            for (const layerID of layerIDs) {\n                if (id === layerID) return true;\n            }\n        }\n\n        return false;\n    }\n}\n\nregister(\n    'FeatureIndex',\n    FeatureIndex,\n    { omit: ['rawTileData', 'sourceLayerCoder'] }\n);\n\nexport default FeatureIndex;\n\nfunction getBounds(geometry: Array<Point>) {\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    for (const p of geometry) {\n        minX = Math.min(minX, p.x);\n        minY = Math.min(minY, p.y);\n        maxX = Math.max(maxX, p.x);\n        maxY = Math.max(maxY, p.y);\n    }\n    return { minX, minY, maxX, maxY };\n}\n\nfunction topDownFeatureComparator(a, b) {\n    return b - a;\n}\n","// @flow\n\nimport UnitBezier from '@mapbox/unitbezier';\n\nimport Point from '@mapbox/point-geometry';\nimport window from './window';\n\nimport type {Callback} from '../types/callback';\n\n/**\n * @module util\n * @private\n */\n\n/**\n * Given a value `t` that varies between 0 and 1, return\n * an interpolation function that eases between 0 and 1 in a pleasing\n * cubic in-out fashion.\n *\n * @private\n */\nexport function easeCubicInOut(t: number): number {\n    if (t <= 0) return 0;\n    if (t >= 1) return 1;\n    const t2 = t * t,\n        t3 = t2 * t;\n    return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);\n}\n\n/**\n * Given given (x, y), (x1, y1) control points for a bezier curve,\n * return a function that interpolates along that curve.\n *\n * @param p1x control point 1 x coordinate\n * @param p1y control point 1 y coordinate\n * @param p2x control point 2 x coordinate\n * @param p2y control point 2 y coordinate\n * @private\n */\nexport function bezier(p1x: number, p1y: number, p2x: number, p2y: number): (t: number) => number {\n    const bezier = new UnitBezier(p1x, p1y, p2x, p2y);\n    return function(t: number) {\n        return bezier.solve(t);\n    };\n}\n\n/**\n * A default bezier-curve powered easing function with\n * control points (0.25, 0.1) and (0.25, 1)\n *\n * @private\n */\nexport const ease = bezier(0.25, 0.1, 0.25, 1);\n\n/**\n * constrain n to the given range via min + max\n *\n * @param n value\n * @param min the minimum value to be returned\n * @param max the maximum value to be returned\n * @returns the clamped value\n * @private\n */\nexport function clamp(n: number, min: number, max: number): number {\n    return Math.min(max, Math.max(min, n));\n}\n\n/**\n * constrain n to the given range, excluding the minimum, via modular arithmetic\n *\n * @param n value\n * @param min the minimum value to be returned, exclusive\n * @param max the maximum value to be returned, inclusive\n * @returns constrained number\n * @private\n */\nexport function wrap(n: number, min: number, max: number): number {\n    const d = max - min;\n    const w = ((n - min) % d + d) % d + min;\n    return (w === min) ? max : w;\n}\n\n/*\n * Call an asynchronous function on an array of arguments,\n * calling `callback` with the completed results of all calls.\n *\n * @param array input to each call of the async function.\n * @param fn an async function with signature (data, callback)\n * @param callback a callback run after all async work is done.\n * called with an array, containing the results of each async call.\n * @private\n */\nexport function asyncAll<Item, Result>(\n    array: Array<Item>,\n    fn: (item: Item, fnCallback: Callback<Result>) => void,\n    callback: Callback<Array<Result>>\n) {\n    if (!array.length) { return callback(null, []); }\n    let remaining = array.length;\n    const results = new Array(array.length);\n    let error = null;\n    array.forEach((item, i) => {\n        fn(item, (err, result) => {\n            if (err) error = err;\n            results[i] = ((result: any): Result); // https://github.com/facebook/flow/issues/2123\n            if (--remaining === 0) callback(error, results);\n        });\n    });\n}\n\n/*\n * Polyfill for Object.values. Not fully spec compliant, but we don't\n * need it to be.\n *\n * @private\n */\nexport function values<T>(obj: {[key: string]: T}): Array<T> {\n    const result = [];\n    for (const k in obj) {\n        result.push(obj[k]);\n    }\n    return result;\n}\n\n/*\n * Compute the difference between the keys in one object and the keys\n * in another object.\n *\n * @returns keys difference\n * @private\n */\nexport function keysDifference<S, T>(obj: {[key: string]: S}, other: {[key: string]: T}): Array<string> {\n    const difference = [];\n    for (const i in obj) {\n        if (!(i in other)) {\n            difference.push(i);\n        }\n    }\n    return difference;\n}\n\n/**\n * Given a destination object and optionally many source objects,\n * copy all properties from the source objects into the destination.\n * The last source object given overrides properties from previous\n * source objects.\n *\n * @param dest destination object\n * @param sources sources from which properties are pulled\n * @private\n */\nexport function extend(dest: Object, ...sources: Array<?Object>): Object {\n    for (const src of sources) {\n        for (const k in src) {\n            dest[k] = src[k];\n        }\n    }\n    return dest;\n}\n\n/**\n * Given an object and a number of properties as strings, return version\n * of that object with only those properties.\n *\n * @param src the object\n * @param properties an array of property names chosen\n * to appear on the resulting object.\n * @returns object with limited properties.\n * @example\n * var foo = { name: 'Charlie', age: 10 };\n * var justName = pick(foo, ['name']);\n * // justName = { name: 'Charlie' }\n * @private\n */\nexport function pick(src: Object, properties: Array<string>): Object {\n    const result = {};\n    for (let i = 0; i < properties.length; i++) {\n        const k = properties[i];\n        if (k in src) {\n            result[k] = src[k];\n        }\n    }\n    return result;\n}\n\nlet id = 1;\n\n/**\n * Return a unique numeric id, starting at 1 and incrementing with\n * each call.\n *\n * @returns unique numeric id.\n * @private\n */\nexport function uniqueId(): number {\n    return id++;\n}\n\n/**\n * Return a random UUID (v4). Taken from: https://gist.github.com/jed/982883\n * @private\n */\nexport function uuid(): string {\n    function b(a) {\n        return a ? (a ^ Math.random() * 16 >> a / 4).toString(16) :\n        //$FlowFixMe: Flow doesn't like the implied array literal conversion here\n            ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, b);\n    }\n    return b();\n}\n\n/**\n * Validate a string to match UUID(v4) of the\n * form: xxxxxxxx-xxxx-4xxx-[89ab]xxx-xxxxxxxxxxxx\n * @param str string to validate.\n * @private\n */\nexport function validateUuid(str: ?string): boolean {\n    return str ? /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(str) : false;\n}\n\n/**\n * Given an array of member function names as strings, replace all of them\n * with bound versions that will always refer to `context` as `this`. This\n * is useful for classes where otherwise event bindings would reassign\n * `this` to the evented object or some other value: this lets you ensure\n * the `this` value always.\n *\n * @param fns list of member function names\n * @param context the context value\n * @example\n * function MyClass() {\n *   bindAll(['ontimer'], this);\n *   this.name = 'Tom';\n * }\n * MyClass.prototype.ontimer = function() {\n *   alert(this.name);\n * };\n * var myClass = new MyClass();\n * setTimeout(myClass.ontimer, 100);\n * @private\n */\nexport function bindAll(fns: Array<string>, context: Object): void {\n    fns.forEach((fn) => {\n        if (!context[fn]) { return; }\n        context[fn] = context[fn].bind(context);\n    });\n}\n\n/**\n * Determine if a string ends with a particular substring\n *\n * @private\n */\nexport function endsWith(string: string, suffix: string): boolean {\n    return string.indexOf(suffix, string.length - suffix.length) !== -1;\n}\n\n/**\n * Create an object by mapping all the values of an existing object while\n * preserving their keys.\n *\n * @private\n */\nexport function mapObject(input: Object, iterator: Function, context?: Object): Object {\n    const output = {};\n    for (const key in input) {\n        output[key] = iterator.call(context || this, input[key], key, input);\n    }\n    return output;\n}\n\n/**\n * Create an object by filtering out values of an existing object.\n *\n * @private\n */\nexport function filterObject(input: Object, iterator: Function, context?: Object): Object {\n    const output = {};\n    for (const key in input) {\n        if (iterator.call(context || this, input[key], key, input)) {\n            output[key] = input[key];\n        }\n    }\n    return output;\n}\n\nimport deepEqual from '../style-spec/util/deep_equal';\nexport { deepEqual };\n\n/**\n * Deeply clones two objects.\n *\n * @private\n */\nexport function clone<T>(input: T): T {\n    if (Array.isArray(input)) {\n        return input.map(clone);\n    } else if (typeof input === 'object' && input) {\n        return ((mapObject(input, clone): any): T);\n    } else {\n        return input;\n    }\n}\n\n/**\n * Check if two arrays have at least one common element.\n *\n * @private\n */\nexport function arraysIntersect<T>(a: Array<T>, b: Array<T>): boolean {\n    for (let l = 0; l < a.length; l++) {\n        if (b.indexOf(a[l]) >= 0) return true;\n    }\n    return false;\n}\n\n/**\n * Print a warning message to the console and ensure duplicate warning messages\n * are not printed.\n *\n * @private\n */\nconst warnOnceHistory: {[key: string]: boolean} = {};\n\nexport function warnOnce(message: string): void {\n    if (!warnOnceHistory[message]) {\n        // console isn't defined in some WebWorkers, see #2558\n        if (typeof console !== \"undefined\") console.warn(message);\n        warnOnceHistory[message] = true;\n    }\n}\n\n/**\n * Indicates if the provided Points are in a counter clockwise (true) or clockwise (false) order\n *\n * @private\n * @returns true for a counter clockwise set of points\n */\n// http://bryceboe.com/2006/10/23/line-segment-intersection-algorithm/\nexport function isCounterClockwise(a: Point, b: Point, c: Point): boolean {\n    return (c.y - a.y) * (b.x - a.x) > (b.y - a.y) * (c.x - a.x);\n}\n\n/**\n * Returns the signed area for the polygon ring.  Postive areas are exterior rings and\n * have a clockwise winding.  Negative areas are interior rings and have a counter clockwise\n * ordering.\n *\n * @private\n * @param ring Exterior or interior ring\n */\nexport function calculateSignedArea(ring: Array<Point>): number {\n    let sum = 0;\n    for (let i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {\n        p1 = ring[i];\n        p2 = ring[j];\n        sum += (p2.x - p1.x) * (p1.y + p2.y);\n    }\n    return sum;\n}\n\n/**\n * Detects closed polygons, first + last point are equal\n *\n * @private\n * @param points array of points\n * @return true if the points are a closed polygon\n */\nexport function isClosedPolygon(points: Array<Point>): boolean {\n    // If it is 2 points that are the same then it is a point\n    // If it is 3 points with start and end the same then it is a line\n    if (points.length < 4)\n        return false;\n\n    const p1 = points[0];\n    const p2 = points[points.length - 1];\n\n    if (Math.abs(p1.x - p2.x) > 0 ||\n        Math.abs(p1.y - p2.y) > 0) {\n        return false;\n    }\n\n    // polygon simplification can produce polygons with zero area and more than 3 points\n    return Math.abs(calculateSignedArea(points)) > 0.01;\n}\n\n/**\n * Converts spherical coordinates to cartesian coordinates.\n *\n * @private\n * @param spherical Spherical coordinates, in [radial, azimuthal, polar]\n * @return cartesian coordinates in [x, y, z]\n */\n\nexport function sphericalToCartesian([r, azimuthal, polar]: [number, number, number]): {x: number, y: number, z: number} {\n    // We abstract \"north\"/\"up\" (compass-wise) to be 0 when really this is 90 (/2):\n    // correct for that here\n    azimuthal += 90;\n\n    // Convert azimuthal and polar angles to radians\n    azimuthal *= Math.PI / 180;\n    polar *= Math.PI / 180;\n\n    return {\n        x: r * Math.cos(azimuthal) * Math.sin(polar),\n        y: r * Math.sin(azimuthal) * Math.sin(polar),\n        z: r * Math.cos(polar)\n    };\n}\n\n/**\n * Parses data from 'Cache-Control' headers.\n *\n * @private\n * @param cacheControl Value of 'Cache-Control' header\n * @return object containing parsed header info.\n */\n\nexport function parseCacheControl(cacheControl: string): Object {\n    // Taken from [Wreck](https://github.com/hapijs/wreck)\n    const re = /(?:^|(?:\\s*\\,\\s*))([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)(?:\\=(?:([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)|(?:\\\"((?:[^\"\\\\]|\\\\.)*)\\\")))?/g;\n\n    const header = {};\n    cacheControl.replace(re, ($0, $1, $2, $3) => {\n        const value = $2 || $3;\n        header[$1] = value ? value.toLowerCase() : true;\n        return '';\n    });\n\n    if (header['max-age']) {\n        const maxAge = parseInt(header['max-age'], 10);\n        if (isNaN(maxAge)) delete header['max-age'];\n        else header['max-age'] = maxAge;\n    }\n\n    return header;\n}\n\nexport function storageAvailable(type: string): boolean {\n    try {\n        const storage = window[type];\n        storage.setItem('_mapbox_test_', 1);\n        storage.removeItem('_mapbox_test_');\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\n\n// The following methods are from https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_Unicode_Problem\n//Unicode compliant base64 encoder for strings\nexport function b64EncodeUnicode(str: string) {\n    return window.btoa(\n        encodeURIComponent(str).replace(/%([0-9A-F]{2})/g,\n            (match, p1) => {\n                return String.fromCharCode(Number('0x' + p1)); //eslint-disable-line\n            }\n        )\n    );\n}\n\n\n// Unicode compliant decoder for base64-encoded strings\nexport function b64DecodeUnicode(str: string) {\n    return decodeURIComponent(window.atob(str).split('').map((c) => {\n        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2); //eslint-disable-line\n    }).join(''));\n}\n","// @flow\n\nimport { uniqueId, deepEqual, parseCacheControl } from '../util/util';\nimport { deserialize as deserializeBucket } from '../data/bucket';\nimport FeatureIndex from '../data/feature_index';\nimport GeoJSONFeature from '../util/vectortile_to_geojson';\nimport featureFilter from '../style-spec/feature_filter';\nimport SymbolBucket from '../data/bucket/symbol_bucket';\nimport { RasterBoundsArray, CollisionBoxArray } from '../data/array_types';\nimport rasterBoundsAttributes from '../data/raster_bounds_attributes';\nimport EXTENT from '../data/extent';\nimport Point from '@mapbox/point-geometry';\nimport Texture from '../render/texture';\nimport SegmentVector from '../data/segment';\nimport { TriangleIndexArray } from '../data/index_array_type';\nimport browser from '../util/browser';\nimport EvaluationParameters from '../style/evaluation_parameters';\nimport SourceFeatureState from '../source/source_state';\n\nconst CLOCK_SKEW_RETRY_TIMEOUT = 30000;\n\nimport type {Bucket} from '../data/bucket';\nimport type StyleLayer from '../style/style_layer';\nimport type {WorkerTileResult} from './worker_source';\nimport type DEMData from '../data/dem_data';\nimport type {AlphaImage} from '../util/image';\nimport type ImageAtlas from '../render/image_atlas';\nimport type Mask from '../render/tile_mask';\nimport type Context from '../gl/context';\nimport type IndexBuffer from '../gl/index_buffer';\nimport type VertexBuffer from '../gl/vertex_buffer';\nimport type {OverscaledTileID} from './tile_id';\nimport type Framebuffer from '../gl/framebuffer';\nimport type {PerformanceResourceTiming} from '../types/performance_resource_timing';\nimport type Transform from '../geo/transform';\nimport type {LayerFeatureStates} from './source_state';\nimport type {Cancelable} from '../types/cancelable';\nimport type {FilterSpecification} from '../style-spec/types';\n\nexport type TileState =\n    | 'loading'   // Tile data is in the process of loading.\n    | 'loaded'    // Tile data has been loaded. Tile can be rendered.\n    | 'reloading' // Tile data has been loaded and is being updated. Tile can be rendered.\n    | 'unloaded'  // Tile data has been deleted.\n    | 'errored'   // Tile data was not loaded because of an error.\n    | 'expired';  /* Tile data was previously loaded, but has expired per its\n                   * HTTP headers and is in the process of refreshing. */\n\n/**\n * A tile object is the combination of a Coordinate, which defines\n * its place, as well as a unique ID and data tracking for its content\n *\n * @private\n */\nclass Tile {\n    tileID: OverscaledTileID;\n    uid: number;\n    uses: number;\n    tileSize: number;\n    buckets: {[string]: Bucket};\n    latestFeatureIndex: ?FeatureIndex;\n    latestRawTileData: ?ArrayBuffer;\n    imageAtlas: ?ImageAtlas;\n    imageAtlasTexture: Texture;\n    glyphAtlasImage: ?AlphaImage;\n    glyphAtlasTexture: Texture;\n    expirationTime: any;\n    expiredRequestCount: number;\n    state: TileState;\n    timeAdded: any;\n    fadeEndTime: any;\n    collisionBoxArray: ?CollisionBoxArray;\n    redoWhenDone: boolean;\n    showCollisionBoxes: boolean;\n    placementSource: any;\n    workerID: number | void;\n    vtLayers: {[string]: VectorTileLayer};\n    mask: Mask;\n\n    neighboringTiles: ?Object;\n    dem: ?DEMData;\n    aborted: ?boolean;\n    maskedBoundsBuffer: ?VertexBuffer;\n    maskedIndexBuffer: ?IndexBuffer;\n    segments: ?SegmentVector;\n    needsHillshadePrepare: ?boolean;\n    request: ?Cancelable;\n    texture: any;\n    fbo: ?Framebuffer;\n    demTexture: ?Texture;\n    refreshedUponExpiration: boolean;\n    reloadCallback: any;\n    resourceTiming: ?Array<PerformanceResourceTiming>;\n    queryPadding: number;\n\n    symbolFadeHoldUntil: ?number;\n    hasSymbolBuckets: boolean;\n\n    /**\n     * @param {OverscaledTileID} tileID\n     * @param size\n     */\n    constructor(tileID: OverscaledTileID, size: number) {\n        this.tileID = tileID;\n        this.uid = uniqueId();\n        this.uses = 0;\n        this.tileSize = size;\n        this.buckets = {};\n        this.expirationTime = null;\n        this.queryPadding = 0;\n        this.hasSymbolBuckets = false;\n\n        // Counts the number of times a response was already expired when\n        // received. We're using this to add a delay when making a new request\n        // so we don't have to keep retrying immediately in case of a server\n        // serving expired tiles.\n        this.expiredRequestCount = 0;\n\n        this.state = 'loading';\n    }\n\n    registerFadeDuration(duration: number) {\n        const fadeEndTime = duration + this.timeAdded;\n        if (fadeEndTime < browser.now()) return;\n        if (this.fadeEndTime && fadeEndTime < this.fadeEndTime) return;\n\n        this.fadeEndTime = fadeEndTime;\n    }\n\n    wasRequested() {\n        return this.state === 'errored' || this.state === 'loaded' || this.state === 'reloading';\n    }\n\n    /**\n     * Given a data object with a 'buffers' property, load it into\n     * this tile's elementGroups and buffers properties and set loaded\n     * to true. If the data is null, like in the case of an empty\n     * GeoJSON tile, no-op but still set loaded to true.\n     * @param {Object} data\n     * @param painter\n     * @returns {undefined}\n     * @private\n     */\n    loadVectorData(data: WorkerTileResult, painter: any, justReloaded: ?boolean) {\n        if (this.hasData()) {\n            this.unloadVectorData();\n        }\n\n        this.state = 'loaded';\n\n        // empty GeoJSON tile\n        if (!data) {\n            this.collisionBoxArray = new CollisionBoxArray();\n            return;\n        }\n\n        if (data.featureIndex) {\n            this.latestFeatureIndex = data.featureIndex;\n            if (data.rawTileData) {\n                // Only vector tiles have rawTileData, and they won't update it for\n                // 'reloadTile'\n                this.latestRawTileData = data.rawTileData;\n                this.latestFeatureIndex.rawTileData = data.rawTileData;\n            } else if (this.latestRawTileData) {\n                // If rawTileData hasn't updated, hold onto a pointer to the last\n                // one we received\n                this.latestFeatureIndex.rawTileData = this.latestRawTileData;\n            }\n        }\n        this.collisionBoxArray = data.collisionBoxArray;\n        this.buckets = deserializeBucket(data.buckets, painter.style);\n\n        this.hasSymbolBuckets = false;\n        for (const id in this.buckets) {\n            const bucket = this.buckets[id];\n            if (bucket instanceof SymbolBucket) {\n                this.hasSymbolBuckets = true;\n                if (justReloaded) {\n                    bucket.justReloaded = true;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        this.queryPadding = 0;\n        for (const id in this.buckets) {\n            const bucket = this.buckets[id];\n            this.queryPadding = Math.max(this.queryPadding, painter.style.getLayer(id).queryRadius(bucket));\n        }\n\n        if (data.imageAtlas) {\n            this.imageAtlas = data.imageAtlas;\n        }\n        if (data.glyphAtlasImage) {\n            this.glyphAtlasImage = data.glyphAtlasImage;\n        }\n    }\n\n    /**\n     * Release any data or WebGL resources referenced by this tile.\n     * @returns {undefined}\n     * @private\n     */\n    unloadVectorData() {\n        for (const id in this.buckets) {\n            this.buckets[id].destroy();\n        }\n        this.buckets = {};\n\n        if (this.imageAtlasTexture) {\n            this.imageAtlasTexture.destroy();\n        }\n\n        if (this.imageAtlas) {\n            this.imageAtlas = null;\n        }\n\n        if (this.glyphAtlasTexture) {\n            this.glyphAtlasTexture.destroy();\n        }\n\n        this.latestFeatureIndex = null;\n        this.state = 'unloaded';\n    }\n\n    unloadDEMData() {\n        this.dem = null;\n        this.neighboringTiles = null;\n        this.state = 'unloaded';\n    }\n\n    getBucket(layer: StyleLayer) {\n        return this.buckets[layer.id];\n    }\n\n    upload(context: Context) {\n        for (const id in this.buckets) {\n            const bucket = this.buckets[id];\n            if (bucket.uploadPending()) {\n                bucket.upload(context);\n            }\n        }\n\n        const gl = context.gl;\n        if (this.imageAtlas && !this.imageAtlas.uploaded) {\n            this.imageAtlasTexture = new Texture(context, this.imageAtlas.image, gl.RGBA);\n            this.imageAtlas.uploaded = true;\n        }\n\n        if (this.glyphAtlasImage) {\n            this.glyphAtlasTexture = new Texture(context, this.glyphAtlasImage, gl.ALPHA);\n            this.glyphAtlasImage = null;\n        }\n    }\n\n    // Queries non-symbol features rendered for this tile.\n    // Symbol features are queried globally\n    queryRenderedFeatures(layers: {[string]: StyleLayer},\n                          sourceFeatureState: SourceFeatureState,\n                          queryGeometry: Array<Point>,\n                          cameraQueryGeometry: Array<Point>,\n                          scale: number,\n                          params: { filter: FilterSpecification, layers: Array<string> },\n                          transform: Transform,\n                          maxPitchScaleFactor: number,\n                          pixelPosMatrix: Float32Array): {[string]: Array<{ featureIndex: number, feature: GeoJSONFeature }>} {\n        if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData)\n            return {};\n\n        return this.latestFeatureIndex.query({\n            queryGeometry,\n            cameraQueryGeometry,\n            scale,\n            tileSize: this.tileSize,\n            pixelPosMatrix,\n            transform,\n            params,\n            queryPadding: this.queryPadding * maxPitchScaleFactor\n        }, layers, sourceFeatureState);\n    }\n\n    querySourceFeatures(result: Array<GeoJSONFeature>, params: any) {\n        if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData) return;\n\n        const vtLayers = this.latestFeatureIndex.loadVTLayers();\n\n        const sourceLayer = params ? params.sourceLayer : '';\n        const layer = vtLayers._geojsonTileLayer || vtLayers[sourceLayer];\n\n        if (!layer) return;\n\n        const filter = featureFilter(params && params.filter);\n        const {z, x, y} = this.tileID.canonical;\n        const coord = {z, x, y};\n\n        for (let i = 0; i < layer.length; i++) {\n            const feature = layer.feature(i);\n            if (filter(new EvaluationParameters(this.tileID.overscaledZ), feature)) {\n                const geojsonFeature = new GeoJSONFeature(feature, z, x, y);\n                (geojsonFeature: any).tile = coord;\n                result.push(geojsonFeature);\n            }\n        }\n    }\n\n    clearMask() {\n        if (this.segments) {\n            this.segments.destroy();\n            delete this.segments;\n        }\n        if (this.maskedBoundsBuffer) {\n            this.maskedBoundsBuffer.destroy();\n            delete this.maskedBoundsBuffer;\n        }\n        if (this.maskedIndexBuffer) {\n            this.maskedIndexBuffer.destroy();\n            delete this.maskedIndexBuffer;\n        }\n    }\n\n    setMask(mask: Mask, context: Context) {\n\n        // don't redo buffer work if the mask is the same;\n        if (deepEqual(this.mask, mask)) return;\n\n        this.mask = mask;\n        this.clearMask();\n\n        // We want to render the full tile, and keeping the segments/vertices/indices empty means\n        // using the global shared buffers for covering the entire tile.\n        if (deepEqual(mask, {'0': true})) return;\n\n        const maskedBoundsArray = new RasterBoundsArray();\n        const indexArray = new TriangleIndexArray();\n\n        this.segments = new SegmentVector();\n        // Create a new segment so that we will upload (empty) buffers even when there is nothing to\n        // draw for this tile.\n        this.segments.prepareSegment(0, maskedBoundsArray, indexArray);\n\n        const maskArray = Object.keys(mask);\n        for (let i = 0; i < maskArray.length; i++) {\n            const maskCoord = mask[maskArray[i]];\n            const vertexExtent = EXTENT >> maskCoord.z;\n            const tlVertex = new Point(maskCoord.x * vertexExtent, maskCoord.y * vertexExtent);\n            const brVertex = new Point(tlVertex.x + vertexExtent, tlVertex.y + vertexExtent);\n\n            // not sure why flow is complaining here because it doesn't complain at L401\n            const segment = (this.segments: any).prepareSegment(4, maskedBoundsArray, indexArray);\n\n            maskedBoundsArray.emplaceBack(tlVertex.x, tlVertex.y, tlVertex.x, tlVertex.y);\n            maskedBoundsArray.emplaceBack(brVertex.x, tlVertex.y, brVertex.x, tlVertex.y);\n            maskedBoundsArray.emplaceBack(tlVertex.x, brVertex.y, tlVertex.x, brVertex.y);\n            maskedBoundsArray.emplaceBack(brVertex.x, brVertex.y, brVertex.x, brVertex.y);\n\n            const offset = segment.vertexLength;\n            // 0, 1, 2\n            // 1, 2, 3\n            indexArray.emplaceBack(offset, offset + 1, offset + 2);\n            indexArray.emplaceBack(offset + 1, offset + 2, offset + 3);\n\n            segment.vertexLength += 4;\n            segment.primitiveLength += 2;\n        }\n\n        this.maskedBoundsBuffer = context.createVertexBuffer(maskedBoundsArray, rasterBoundsAttributes.members);\n        this.maskedIndexBuffer = context.createIndexBuffer(indexArray);\n    }\n\n    hasData() {\n        return this.state === 'loaded' || this.state === 'reloading' || this.state === 'expired';\n    }\n\n    patternsLoaded() {\n        return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;\n    }\n\n    setExpiryData(data: any) {\n        const prior = this.expirationTime;\n\n        if (data.cacheControl) {\n            const parsedCC = parseCacheControl(data.cacheControl);\n            if (parsedCC['max-age']) this.expirationTime = Date.now() + parsedCC['max-age'] * 1000;\n        } else if (data.expires) {\n            this.expirationTime = new Date(data.expires).getTime();\n        }\n\n        if (this.expirationTime) {\n            const now = Date.now();\n            let isExpired = false;\n\n            if (this.expirationTime > now) {\n                isExpired = false;\n            } else if (!prior) {\n                isExpired = true;\n            } else if (this.expirationTime < prior) {\n                // Expiring date is going backwards:\n                // fall back to exponential backoff\n                isExpired = true;\n\n            } else {\n                const delta = this.expirationTime - prior;\n\n                if (!delta) {\n                    // Server is serving the same expired resource over and over: fall\n                    // back to exponential backoff.\n                    isExpired = true;\n\n                } else {\n                    // Assume that either the client or the server clock is wrong and\n                    // try to interpolate a valid expiration date (from the client POV)\n                    // observing a minimum timeout.\n                    this.expirationTime = now + Math.max(delta, CLOCK_SKEW_RETRY_TIMEOUT);\n\n                }\n            }\n\n            if (isExpired) {\n                this.expiredRequestCount++;\n                this.state = 'expired';\n            } else {\n                this.expiredRequestCount = 0;\n            }\n        }\n    }\n\n    getExpiryTimeout() {\n        if (this.expirationTime) {\n            if (this.expiredRequestCount) {\n                return 1000 * (1 << Math.min(this.expiredRequestCount - 1, 31));\n            } else {\n                // Max value for `setTimeout` implementations is a 32 bit integer; cap this accordingly\n                return Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);\n            }\n        }\n    }\n\n    setFeatureState(states: LayerFeatureStates, painter: any) {\n        if (!this.latestFeatureIndex ||\n            !this.latestFeatureIndex.rawTileData ||\n            Object.keys(states).length === 0) {\n            return;\n        }\n\n        const vtLayers = this.latestFeatureIndex.loadVTLayers();\n\n        for (const id in this.buckets) {\n            const bucket = this.buckets[id];\n            // Buckets are grouped by common source-layer\n            const sourceLayerId = bucket.layers[0]['sourceLayer'] || '_geojsonTileLayer';\n            const sourceLayer = vtLayers[sourceLayerId];\n            const sourceLayerStates = states[sourceLayerId];\n            if (!sourceLayer || !sourceLayerStates || Object.keys(sourceLayerStates).length === 0) continue;\n\n            bucket.update(sourceLayerStates, sourceLayer, this.imageAtlas && this.imageAtlas.patternPositions || {});\n            if (painter && painter.style) {\n                this.queryPadding = Math.max(this.queryPadding, painter.style.getLayer(id).queryRadius(bucket));\n            }\n        }\n    }\n\n    holdingForFade(): boolean {\n        return this.symbolFadeHoldUntil !== undefined;\n    }\n\n    symbolFadeFinished(): boolean {\n        return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < browser.now();\n    }\n\n    clearFadeHold() {\n        this.symbolFadeHoldUntil = undefined;\n    }\n\n    setHoldDuration(duration: number) {\n        this.symbolFadeHoldUntil = browser.now() + duration;\n    }\n}\n\nexport default Tile;\n","// @flow\n\nimport type {CollisionBoxArray} from './array_types';\nimport type Style from '../style/style';\nimport type {TypedStyleLayer} from '../style/style_layer/typed_style_layer';\nimport type FeatureIndex from './feature_index';\nimport type Context from '../gl/context';\nimport type {FeatureStates} from '../source/source_state';\nimport type {ImagePosition} from '../render/image_atlas';\n\nexport type BucketParameters<Layer: TypedStyleLayer> = {\n    index: number,\n    layers: Array<Layer>,\n    zoom: number,\n    pixelRatio: number,\n    overscaling: number,\n    collisionBoxArray: CollisionBoxArray,\n    sourceLayerIndex: number,\n    sourceID: string\n}\n\nexport type PopulateParameters = {\n    featureIndex: FeatureIndex,\n    iconDependencies: {},\n    patternDependencies: {},\n    glyphDependencies: {}\n}\n\nexport type IndexedFeature = {\n    feature: VectorTileFeature,\n    index: number,\n    sourceLayerIndex: number,\n}\n\nexport type BucketFeature = {|\n    index: number,\n    sourceLayerIndex: number,\n    geometry: Array<Array<Point>>,\n    properties: Object,\n    type: 1 | 2 | 3,\n    id?: any,\n    +patterns: {[string]: {\"min\": string, \"mid\": string, \"max\": string}}\n|};\n\n/**\n * The `Bucket` interface is the single point of knowledge about turning vector\n * tiles into WebGL buffers.\n *\n * `Bucket` is an abstract interface. An implementation exists for each style layer type.\n * Create a bucket via the `StyleLayer#createBucket` method.\n *\n * The concrete bucket types, using layout options from the style layer,\n * transform feature geometries into vertex and index data for use by the\n * vertex shader.  They also (via `ProgramConfiguration`) use feature\n * properties and the zoom level to populate the attributes needed for\n * data-driven styling.\n *\n * Buckets are designed to be built on a worker thread and then serialized and\n * transferred back to the main thread for rendering.  On the worker side, a\n * bucket's vertex, index, and attribute data is stored in `bucket.arrays:\n * ArrayGroup`.  When a bucket's data is serialized and sent back to the main\n * thread, is gets deserialized (using `new Bucket(serializedBucketData)`, with\n * the array data now stored in `bucket.buffers: BufferGroup`.  BufferGroups\n * hold the same data as ArrayGroups, but are tuned for consumption by WebGL.\n *\n * @private\n */\nexport interface Bucket {\n    layerIds: Array<string>;\n    hasPattern: boolean;\n    +layers: Array<any>;\n    +stateDependentLayers: Array<any>;\n    +stateDependentLayerIds: Array<string>;\n    populate(features: Array<IndexedFeature>, options: PopulateParameters): void;\n    update(states: FeatureStates, vtLayer: VectorTileLayer, imagePositions: {[string]: ImagePosition}): void;\n    isEmpty(): boolean;\n\n    upload(context: Context): void;\n    uploadPending(): boolean;\n\n    /**\n     * Release the WebGL resources associated with the buffers. Note that because\n     * buckets are shared between layers having the same layout properties, they\n     * must be destroyed in groups (all buckets for a tile, or all symbol buckets).\n     *\n     * @private\n     */\n    destroy(): void;\n}\n\nexport function deserialize(input: Array<Bucket>, style: Style): {[string]: Bucket} {\n    const output = {};\n\n    // Guard against the case where the map's style has been set to null while\n    // this bucket has been parsing.\n    if (!style) return output;\n\n    for (const bucket of input) {\n        const layers = bucket.layerIds\n            .map((id) => style.getLayer(id))\n            .filter(Boolean);\n\n        if (layers.length === 0) {\n            continue;\n        }\n\n        // look up StyleLayer objects from layer ids (since we don't\n        // want to waste time serializing/copying them from the worker)\n        (bucket: any).layers = layers;\n        if ((bucket: any).stateDependentLayerIds) {\n            (bucket: any).stateDependentLayers = (bucket: any).stateDependentLayerIds.map((lId) => layers.filter((l) => l.id === lId)[0]);\n        }\n        for (const layer of layers) {\n            output[layer.id] = bucket;\n        }\n    }\n\n    return output;\n}\n","\nexport default ['type', 'source', 'source-layer', 'minzoom', 'maxzoom', 'filter', 'layout'];\n","// @flow\n\nimport {\n    charHasUprightVerticalOrientation,\n    charAllowsIdeographicBreaking\n} from '../util/script_detection';\nimport verticalizePunctuation from '../util/verticalize_punctuation';\nimport { plugin as rtlTextPlugin } from '../source/rtl_text_plugin';\n\nimport type {StyleGlyph} from '../style/style_glyph';\nimport type {ImagePosition} from '../render/image_atlas';\nimport Formatted from '../style-spec/expression/types/formatted';\n\nconst WritingMode = {\n    horizontal: 1,\n    vertical: 2,\n    horizontalOnly: 3\n};\n\nexport { shapeText, shapeIcon, WritingMode };\n\n// The position of a glyph relative to the text's anchor point.\nexport type PositionedGlyph = {\n    glyph: number,\n    x: number,\n    y: number,\n    vertical: boolean,\n    scale: number,\n    fontStack: string\n};\n\n// A collection of positioned glyphs and some metadata\nexport type Shaping = {\n    positionedGlyphs: Array<PositionedGlyph>,\n    top: number,\n    bottom: number,\n    left: number,\n    right: number,\n    writingMode: 1 | 2\n};\n\ntype SymbolAnchor = 'center' | 'left' | 'right' | 'top' | 'bottom' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';\ntype TextJustify = 'left' | 'center' | 'right';\n\nclass TaggedString {\n    text: string;\n    sectionIndex: Array<number> // maps each character in 'text' to its corresponding entry in 'sections'\n    sections: Array<{ scale: number, fontStack: string }>\n\n    constructor() {\n        this.text = \"\";\n        this.sectionIndex = [];\n        this.sections = [];\n    }\n\n    static fromFeature(text: Formatted, defaultFontStack: string) {\n        const result = new TaggedString();\n        for (let i = 0; i < text.sections.length; i++) {\n            const section = text.sections[i];\n            result.sections.push({\n                scale: section.scale || 1,\n                fontStack: section.fontStack || defaultFontStack\n            });\n            result.text += section.text;\n            for (let j = 0; j < section.text.length; j++) {\n                result.sectionIndex.push(i);\n            }\n        }\n        return result;\n    }\n\n    length(): number {\n        return this.text.length;\n    }\n\n    getSection(index: number): { scale: number, fontStack: string } {\n        return this.sections[this.sectionIndex[index]];\n    }\n\n    getCharCode(index: number): number {\n        return this.text.charCodeAt(index);\n    }\n\n    verticalizePunctuation() {\n        this.text = verticalizePunctuation(this.text);\n    }\n\n    trim() {\n        let beginningWhitespace = 0;\n        for (let i = 0;\n            i < this.text.length && whitespace[this.text.charCodeAt(i)];\n            i++) {\n            beginningWhitespace++;\n        }\n        let trailingWhitespace = this.text.length;\n        for (let i = this.text.length - 1;\n            i >= 0 && i >= beginningWhitespace && whitespace[this.text.charCodeAt(i)];\n            i--) {\n            trailingWhitespace--;\n        }\n        this.text = this.text.substring(beginningWhitespace, trailingWhitespace);\n        this.sectionIndex = this.sectionIndex.slice(beginningWhitespace, trailingWhitespace);\n    }\n\n    substring(start: number, end: number): TaggedString {\n        const substring = new TaggedString();\n        substring.text = this.text.substring(start, end);\n        substring.sectionIndex = this.sectionIndex.slice(start, end);\n        substring.sections = this.sections;\n        return substring;\n    }\n\n    toString(): string {\n        return this.text;\n    }\n\n    getMaxScale() {\n        return this.sectionIndex.reduce((max, index) => Math.max(max, this.sections[index].scale), 0);\n    }\n}\n\nfunction breakLines(input: TaggedString, lineBreakPoints: Array<number>): Array<TaggedString> {\n    const lines = [];\n    const text = input.text;\n    let start = 0;\n    for (const lineBreak of lineBreakPoints) {\n        lines.push(input.substring(start, lineBreak));\n        start = lineBreak;\n    }\n\n    if (start < text.length) {\n        lines.push(input.substring(start, text.length));\n    }\n    return lines;\n}\n\nfunction shapeText(text: Formatted,\n                   glyphs: {[string]: {[number]: ?StyleGlyph}},\n                   defaultFontStack: string,\n                   maxWidth: number,\n                   lineHeight: number,\n                   textAnchor: SymbolAnchor,\n                   textJustify: TextJustify,\n                   spacing: number,\n                   translate: [number, number],\n                   verticalHeight: number,\n                   writingMode: 1 | 2): Shaping | false {\n    const logicalInput = TaggedString.fromFeature(text, defaultFontStack);\n\n    if (writingMode === WritingMode.vertical) {\n        logicalInput.verticalizePunctuation();\n    }\n\n    const positionedGlyphs = [];\n    const shaping = {\n        positionedGlyphs,\n        text: logicalInput,\n        top: translate[1],\n        bottom: translate[1],\n        left: translate[0],\n        right: translate[0],\n        writingMode\n    };\n\n    let lines: Array<TaggedString>;\n\n    const {processBidirectionalText, processStyledBidirectionalText} = rtlTextPlugin;\n    if (processBidirectionalText && logicalInput.sections.length === 1) {\n        // Bidi doesn't have to be style-aware\n        lines = [];\n        const untaggedLines =\n            processBidirectionalText(logicalInput.toString(),\n                                     determineLineBreaks(logicalInput, spacing, maxWidth, glyphs));\n        for (const line of untaggedLines) {\n            const taggedLine = new TaggedString();\n            taggedLine.text = line;\n            taggedLine.sections = logicalInput.sections;\n            for (let i = 0; i < line.length; i++) {\n                taggedLine.sectionIndex.push(0);\n            }\n            lines.push(taggedLine);\n        }\n    } else if (processStyledBidirectionalText) {\n        // Need version of mapbox-gl-rtl-text with style support for combining RTL text\n        // with formatting\n        lines = [];\n        const processedLines =\n            processStyledBidirectionalText(logicalInput.text,\n                                           logicalInput.sectionIndex,\n                                           determineLineBreaks(logicalInput, spacing, maxWidth, glyphs));\n        for (const line of processedLines) {\n            const taggedLine = new TaggedString();\n            taggedLine.text = line[0];\n            taggedLine.sectionIndex = line[1];\n            taggedLine.sections = logicalInput.sections;\n            lines.push(taggedLine);\n        }\n    } else {\n        lines = breakLines(logicalInput, determineLineBreaks(logicalInput, spacing, maxWidth, glyphs));\n    }\n\n    shapeLines(shaping, glyphs, lines, lineHeight, textAnchor, textJustify, writingMode, spacing, verticalHeight);\n\n    if (!positionedGlyphs.length)\n        return false;\n\n    shaping.text = shaping.text.toString();\n    return shaping;\n}\n\n// using computed properties due to https://github.com/facebook/flow/issues/380\n/* eslint no-useless-computed-key: 0 */\n\nconst whitespace: {[number]: boolean} = {\n    [0x09]: true, // tab\n    [0x0a]: true, // newline\n    [0x0b]: true, // vertical tab\n    [0x0c]: true, // form feed\n    [0x0d]: true, // carriage return\n    [0x20]: true, // space\n};\n\nconst breakable: {[number]: boolean} = {\n    [0x0a]:   true, // newline\n    [0x20]:   true, // space\n    [0x26]:   true, // ampersand\n    [0x28]:   true, // left parenthesis\n    [0x29]:   true, // right parenthesis\n    [0x2b]:   true, // plus sign\n    [0x2d]:   true, // hyphen-minus\n    [0x2f]:   true, // solidus\n    [0xad]:   true, // soft hyphen\n    [0xb7]:   true, // middle dot\n    [0x200b]: true, // zero-width space\n    [0x2010]: true, // hyphen\n    [0x2013]: true, // en dash\n    [0x2027]: true  // interpunct\n    // Many other characters may be reasonable breakpoints\n    // Consider \"neutral orientation\" characters at scriptDetection.charHasNeutralVerticalOrientation\n    // See https://github.com/mapbox/mapbox-gl-js/issues/3658\n};\n\nfunction determineAverageLineWidth(logicalInput: TaggedString,\n                                   spacing: number,\n                                   maxWidth: number,\n                                   glyphMap: {[string]: {[number]: ?StyleGlyph}}) {\n    let totalWidth = 0;\n\n    for (let index = 0; index < logicalInput.length(); index++) {\n        const section = logicalInput.getSection(index);\n        const positions = glyphMap[section.fontStack];\n        const glyph = positions && positions[logicalInput.getCharCode(index)];\n        if (!glyph)\n            continue;\n        totalWidth += glyph.metrics.advance * section.scale + spacing;\n    }\n\n    const lineCount = Math.max(1, Math.ceil(totalWidth / maxWidth));\n    return totalWidth / lineCount;\n}\n\nfunction calculateBadness(lineWidth: number,\n                          targetWidth: number,\n                          penalty: number,\n                          isLastBreak: boolean) {\n    const raggedness = Math.pow(lineWidth - targetWidth, 2);\n    if (isLastBreak) {\n        // Favor finals lines shorter than average over longer than average\n        if (lineWidth < targetWidth) {\n            return raggedness / 2;\n        } else {\n            return raggedness * 2;\n        }\n    }\n\n    return raggedness + Math.abs(penalty) * penalty;\n}\n\nfunction calculatePenalty(codePoint: number, nextCodePoint: number) {\n    let penalty = 0;\n    // Force break on newline\n    if (codePoint === 0x0a) {\n        penalty -= 10000;\n    }\n    // Penalize open parenthesis at end of line\n    if (codePoint === 0x28 || codePoint === 0xff08) {\n        penalty += 50;\n    }\n\n    // Penalize close parenthesis at beginning of line\n    if (nextCodePoint === 0x29 || nextCodePoint === 0xff09) {\n        penalty += 50;\n    }\n    return penalty;\n}\n\ntype Break = {\n    index: number,\n    x: number,\n    priorBreak: ?Break,\n    badness: number\n};\n\nfunction evaluateBreak(breakIndex: number,\n                       breakX: number,\n                       targetWidth: number,\n                       potentialBreaks: Array<Break>,\n                       penalty: number,\n                       isLastBreak: boolean): Break {\n    // We could skip evaluating breaks where the line length (breakX - priorBreak.x) > maxWidth\n    //  ...but in fact we allow lines longer than maxWidth (if there's no break points)\n    //  ...and when targetWidth and maxWidth are close, strictly enforcing maxWidth can give\n    //     more lopsided results.\n\n    let bestPriorBreak: ?Break = null;\n    let bestBreakBadness = calculateBadness(breakX, targetWidth, penalty, isLastBreak);\n\n    for (const potentialBreak of potentialBreaks) {\n        const lineWidth = breakX - potentialBreak.x;\n        const breakBadness =\n            calculateBadness(lineWidth, targetWidth, penalty, isLastBreak) + potentialBreak.badness;\n        if (breakBadness <= bestBreakBadness) {\n            bestPriorBreak = potentialBreak;\n            bestBreakBadness = breakBadness;\n        }\n    }\n\n    return {\n        index: breakIndex,\n        x: breakX,\n        priorBreak: bestPriorBreak,\n        badness: bestBreakBadness\n    };\n}\n\nfunction leastBadBreaks(lastLineBreak: ?Break): Array<number> {\n    if (!lastLineBreak) {\n        return [];\n    }\n    return leastBadBreaks(lastLineBreak.priorBreak).concat(lastLineBreak.index);\n}\n\nfunction determineLineBreaks(logicalInput: TaggedString,\n                             spacing: number,\n                             maxWidth: number,\n                             glyphMap: {[string]: {[number]: ?StyleGlyph}}): Array<number> {\n    if (!maxWidth)\n        return [];\n\n    if (!logicalInput)\n        return [];\n\n    const potentialLineBreaks = [];\n    const targetWidth = determineAverageLineWidth(logicalInput, spacing, maxWidth, glyphMap);\n\n    let currentX = 0;\n\n    for (let i = 0; i < logicalInput.length(); i++) {\n        const section = logicalInput.getSection(i);\n        const codePoint = logicalInput.getCharCode(i);\n        const positions = glyphMap[section.fontStack];\n        const glyph = positions && positions[codePoint];\n\n        if (glyph && !whitespace[codePoint])\n            currentX += glyph.metrics.advance * section.scale + spacing;\n\n        // Ideographic characters, spaces, and word-breaking punctuation that often appear without\n        // surrounding spaces.\n        if ((i < logicalInput.length() - 1) &&\n            (breakable[codePoint] ||\n                charAllowsIdeographicBreaking(codePoint))) {\n\n            potentialLineBreaks.push(\n                evaluateBreak(\n                    i + 1,\n                    currentX,\n                    targetWidth,\n                    potentialLineBreaks,\n                    calculatePenalty(codePoint, logicalInput.getCharCode(i + 1)),\n                    false));\n        }\n    }\n\n    return leastBadBreaks(\n        evaluateBreak(\n            logicalInput.length(),\n            currentX,\n            targetWidth,\n            potentialLineBreaks,\n            0,\n            true));\n}\n\nfunction getAnchorAlignment(anchor: SymbolAnchor) {\n    let horizontalAlign = 0.5, verticalAlign = 0.5;\n\n    switch (anchor) {\n    case 'right':\n    case 'top-right':\n    case 'bottom-right':\n        horizontalAlign = 1;\n        break;\n    case 'left':\n    case 'top-left':\n    case 'bottom-left':\n        horizontalAlign = 0;\n        break;\n    }\n\n    switch (anchor) {\n    case 'bottom':\n    case 'bottom-right':\n    case 'bottom-left':\n        verticalAlign = 1;\n        break;\n    case 'top':\n    case 'top-right':\n    case 'top-left':\n        verticalAlign = 0;\n        break;\n    }\n\n    return { horizontalAlign, verticalAlign };\n}\n\nfunction shapeLines(shaping: Shaping,\n                    glyphMap: {[string]: {[number]: ?StyleGlyph}},\n                    lines: Array<TaggedString>,\n                    lineHeight: number,\n                    textAnchor: SymbolAnchor,\n                    textJustify: TextJustify,\n                    writingMode: 1 | 2,\n                    spacing: number,\n                    verticalHeight: number) {\n    // the y offset *should* be part of the font metadata\n    const yOffset = -17;\n\n    let x = 0;\n    let y = yOffset;\n\n    let maxLineLength = 0;\n    const positionedGlyphs = shaping.positionedGlyphs;\n\n    const justify =\n        textJustify === 'right' ? 1 :\n        textJustify === 'left' ? 0 : 0.5;\n\n    for (const line of lines) {\n        line.trim();\n\n        const lineMaxScale = line.getMaxScale();\n\n        if (!line.length()) {\n            y += lineHeight; // Still need a line feed after empty line\n            continue;\n        }\n\n        const lineStartIndex = positionedGlyphs.length;\n        for (let i = 0; i < line.length(); i++) {\n            const section = line.getSection(i);\n            const codePoint = line.getCharCode(i);\n            // We don't know the baseline, but since we're laying out\n            // at 24 points, we can calculate how much it will move when\n            // we scale up or down.\n            const baselineOffset = (lineMaxScale - section.scale) * 24;\n            const positions = glyphMap[section.fontStack];\n            const glyph = positions && positions[codePoint];\n\n            if (!glyph) continue;\n\n            if (!charHasUprightVerticalOrientation(codePoint) || writingMode === WritingMode.horizontal) {\n                positionedGlyphs.push({glyph: codePoint, x, y: y + baselineOffset, vertical: false, scale: section.scale, fontStack: section.fontStack});\n                x += glyph.metrics.advance * section.scale + spacing;\n            } else {\n                positionedGlyphs.push({glyph: codePoint, x, y: baselineOffset, vertical: true, scale: section.scale, fontStack: section.fontStack});\n                x += verticalHeight * section.scale + spacing;\n            }\n        }\n\n        // Only justify if we placed at least one glyph\n        if (positionedGlyphs.length !== lineStartIndex) {\n            const lineLength = x - spacing;\n            maxLineLength = Math.max(lineLength, maxLineLength);\n\n            justifyLine(positionedGlyphs, glyphMap, lineStartIndex, positionedGlyphs.length - 1, justify);\n        }\n\n        x = 0;\n        y += lineHeight * lineMaxScale;\n    }\n\n    const {horizontalAlign, verticalAlign} = getAnchorAlignment(textAnchor);\n    align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, lines.length);\n\n    // Calculate the bounding box\n    const height = y - yOffset;\n\n    shaping.top += -verticalAlign * height;\n    shaping.bottom = shaping.top + height;\n    shaping.left += -horizontalAlign * maxLineLength;\n    shaping.right = shaping.left + maxLineLength;\n}\n\n// justify right = 1, left = 0, center = 0.5\nfunction justifyLine(positionedGlyphs: Array<PositionedGlyph>,\n                     glyphMap: {[string]: {[number]: ?StyleGlyph}},\n                     start: number,\n                     end: number,\n                     justify: 1 | 0 | 0.5) {\n    if (!justify)\n        return;\n\n    const lastPositionedGlyph = positionedGlyphs[end];\n    const positions = glyphMap[lastPositionedGlyph.fontStack];\n    const glyph = positions && positions[lastPositionedGlyph.glyph];\n    if (glyph) {\n        const lastAdvance = glyph.metrics.advance * lastPositionedGlyph.scale;\n        const lineIndent = (positionedGlyphs[end].x + lastAdvance) * justify;\n\n        for (let j = start; j <= end; j++) {\n            positionedGlyphs[j].x -= lineIndent;\n        }\n    }\n}\n\nfunction align(positionedGlyphs: Array<PositionedGlyph>,\n               justify: number,\n               horizontalAlign: number,\n               verticalAlign: number,\n               maxLineLength: number,\n               lineHeight: number,\n               lineCount: number) {\n    const shiftX = (justify - horizontalAlign) * maxLineLength;\n    const shiftY = (-verticalAlign * lineCount + 0.5) * lineHeight;\n\n    for (let j = 0; j < positionedGlyphs.length; j++) {\n        positionedGlyphs[j].x += shiftX;\n        positionedGlyphs[j].y += shiftY;\n    }\n}\n\nexport type PositionedIcon = {\n    image: ImagePosition,\n    top: number,\n    bottom: number,\n    left: number,\n    right: number\n};\n\nfunction shapeIcon(image: ImagePosition, iconOffset: [number, number], iconAnchor: SymbolAnchor): PositionedIcon {\n    const {horizontalAlign, verticalAlign} = getAnchorAlignment(iconAnchor);\n    const dx = iconOffset[0];\n    const dy = iconOffset[1];\n    const x1 = dx - image.displaySize[0] * horizontalAlign;\n    const x2 = x1 + image.displaySize[0];\n    const y1 = dy - image.displaySize[1] * verticalAlign;\n    const y2 = y1 + image.displaySize[1];\n    return {image, top: y1, bottom: y2, left: x1, right: x2};\n}\n","// @flow\n\nimport {\n    charHasRotatedVerticalOrientation,\n} from './script_detection';\n\nexport const verticalizedCharacterMap = {\n    '!': '',\n    '#': '',\n    '$': '',\n    '%': '',\n    '&': '',\n    '(': '',\n    ')': '',\n    '*': '',\n    '+': '',\n    ',': '',\n    '-': '',\n    '.': '',\n    '/': '',\n    ':': '',\n    ';': '',\n    '<': '',\n    '=': '',\n    '>': '',\n    '?': '',\n    '@': '',\n    '[': '',\n    '\\\\': '',\n    ']': '',\n    '^': '',\n    '_': '',\n    '`': '',\n    '{': '',\n    '|': '',\n    '}': '',\n    '~': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': ''\n};\n\nexport default function verticalizePunctuation(input: string) {\n    let output = '';\n\n    for (let i = 0; i < input.length; i++) {\n        const nextCharCode = input.charCodeAt(i + 1) || null;\n        const prevCharCode = input.charCodeAt(i - 1) || null;\n\n        const canReplacePunctuation = (\n            (!nextCharCode || !charHasRotatedVerticalOrientation(nextCharCode) || verticalizedCharacterMap[input[i + 1]]) &&\n            (!prevCharCode || !charHasRotatedVerticalOrientation(prevCharCode) || verticalizedCharacterMap[input[i - 1]])\n        );\n\n        if (canReplacePunctuation && verticalizedCharacterMap[input[i]]) {\n            output += verticalizedCharacterMap[input[i]];\n        } else {\n            output += input[i];\n        }\n    }\n\n    return output;\n}\n\n","\nimport refProperties from './util/ref_properties';\n\nfunction stringify(obj) {\n    const type = typeof obj;\n    if (type === 'number' || type === 'boolean' || type === 'string' || obj === undefined || obj === null)\n        return JSON.stringify(obj);\n\n    if (Array.isArray(obj)) {\n        let str = '[';\n        for (const val of obj) {\n            str += `${stringify(val)},`;\n        }\n        return `${str}]`;\n    }\n\n    const keys = Object.keys(obj).sort();\n\n    let str = '{';\n    for (let i = 0; i < keys.length; i++) {\n        str += `${JSON.stringify(keys[i])}:${stringify(obj[keys[i]])},`;\n    }\n    return `${str}}`;\n}\n\nfunction getKey(layer) {\n    let key = '';\n    for (const k of refProperties) {\n        key += `/${stringify(layer[k])}`;\n    }\n    return key;\n}\n\nexport default groupByLayout;\n\n/**\n * Given an array of layers, return an array of arrays of layers where all\n * layers in each group have identical layout-affecting properties. These\n * are the properties that were formerly used by explicit `ref` mechanism\n * for layers: 'type', 'source', 'source-layer', 'minzoom', 'maxzoom',\n * 'filter', and 'layout'.\n *\n * The input is not modified. The output layers are references to the\n * input layers.\n *\n * @private\n * @param {Array<Layer>} layers\n * @returns {Array<Array<Layer>>}\n */\nfunction groupByLayout(layers) {\n    const groups = {};\n\n    for (let i = 0; i < layers.length; i++) {\n        const k = getKey(layers[i]);\n        let group = groups[k];\n        if (!group) {\n            group = groups[k] = [];\n        }\n        group.push(layers[i]);\n    }\n\n    const result = [];\n\n    for (const k in groups) {\n        result.push(groups[k]);\n    }\n\n    return result;\n}\n","// @flow\n\nimport StyleLayer from './style_layer';\nimport createStyleLayer from './create_style_layer';\n\nimport { values } from '../util/util';\nimport featureFilter from '../style-spec/feature_filter';\nimport groupByLayout from '../style-spec/group_by_layout';\n\nimport type {TypedStyleLayer} from './style_layer/typed_style_layer';\nimport type {LayerSpecification} from '../style-spec/types';\n\nexport type LayerConfigs = { [string]: LayerSpecification };\nexport type Family<Layer: TypedStyleLayer> = Array<Layer>;\n\nclass StyleLayerIndex {\n    familiesBySource: { [source: string]: { [sourceLayer: string]: Array<Family<*>> } };\n\n    _layerConfigs: LayerConfigs;\n    _layers: { [string]: StyleLayer };\n\n    constructor(layerConfigs: ?Array<LayerSpecification>) {\n        if (layerConfigs) {\n            this.replace(layerConfigs);\n        }\n    }\n\n    replace(layerConfigs: Array<LayerSpecification>) {\n        this._layerConfigs = {};\n        this._layers = {};\n        this.update(layerConfigs, []);\n    }\n\n    update(layerConfigs: Array<LayerSpecification>, removedIds: Array<string>) {\n        for (const layerConfig of layerConfigs) {\n            this._layerConfigs[layerConfig.id] = layerConfig;\n\n            const layer = this._layers[layerConfig.id] = createStyleLayer(layerConfig);\n            layer._featureFilter = featureFilter(layer.filter);\n        }\n        for (const id of removedIds) {\n            delete this._layerConfigs[id];\n            delete this._layers[id];\n        }\n\n        this.familiesBySource = {};\n\n        const groups = groupByLayout(values(this._layerConfigs));\n\n        for (const layerConfigs of groups) {\n            const layers = layerConfigs.map((layerConfig) => this._layers[layerConfig.id]);\n\n            const layer = layers[0];\n            if (layer.visibility === 'none') {\n                continue;\n            }\n\n            const sourceId = layer.source || '';\n            let sourceGroup = this.familiesBySource[sourceId];\n            if (!sourceGroup) {\n                sourceGroup = this.familiesBySource[sourceId] = {};\n            }\n\n            const sourceLayerId = layer.sourceLayer || '_geojsonTileLayer';\n            let sourceLayerFamilies = sourceGroup[sourceLayerId];\n            if (!sourceLayerFamilies) {\n                sourceLayerFamilies = sourceGroup[sourceLayerId] = [];\n            }\n\n            sourceLayerFamilies.push(layers);\n        }\n    }\n}\n\nexport default StyleLayerIndex;\n","// @flow\n\nexport default checkMaxAngle;\n\nimport type Point from '@mapbox/point-geometry';\nimport type Anchor from './anchor';\n\n/**\n * Labels placed around really sharp angles aren't readable. Check if any\n * part of the potential label has a combined angle that is too big.\n *\n * @param line\n * @param anchor The point on the line around which the label is anchored.\n * @param labelLength The length of the label in geometry units.\n * @param windowSize The check fails if the combined angles within a part of the line that is `windowSize` long is too big.\n * @param maxAngle The maximum combined angle that any window along the label is allowed to have.\n *\n * @returns {boolean} whether the label should be placed\n * @private\n */\nfunction checkMaxAngle(line: Array<Point>, anchor: Anchor, labelLength: number, windowSize: number, maxAngle: number) {\n\n    // horizontal labels always pass\n    if (anchor.segment === undefined) return true;\n\n    let p = anchor;\n    let index = anchor.segment + 1;\n    let anchorDistance = 0;\n\n    // move backwards along the line to the first segment the label appears on\n    while (anchorDistance > -labelLength / 2) {\n        index--;\n\n        // there isn't enough room for the label after the beginning of the line\n        if (index < 0) return false;\n\n        anchorDistance -= line[index].dist(p);\n        p = line[index];\n    }\n\n    anchorDistance += line[index].dist(line[index + 1]);\n    index++;\n\n    // store recent corners and their total angle difference\n    const recentCorners = [];\n    let recentAngleDelta = 0;\n\n    // move forwards by the length of the label and check angles along the way\n    while (anchorDistance < labelLength / 2) {\n        const prev = line[index - 1];\n        const current = line[index];\n        const next = line[index + 1];\n\n        // there isn't enough room for the label before the end of the line\n        if (!next) return false;\n\n        let angleDelta = prev.angleTo(current) - current.angleTo(next);\n        // restrict angle to -pi..pi range\n        angleDelta = Math.abs(((angleDelta + 3 * Math.PI) % (Math.PI * 2)) - Math.PI);\n\n        recentCorners.push({\n            distance: anchorDistance,\n            angleDelta\n        });\n        recentAngleDelta += angleDelta;\n\n        // remove corners that are far enough away from the list of recent anchors\n        while (anchorDistance - recentCorners[0].distance > windowSize) {\n            recentAngleDelta -= recentCorners.shift().angleDelta;\n        }\n\n        // the sum of angles within the window area exceeds the maximum allowed value. check fails.\n        if (recentAngleDelta > maxAngle) return false;\n\n        index++;\n        anchorDistance += current.dist(next);\n    }\n\n    // no part of the line had an angle greater than the maximum allowed. check passes.\n    return true;\n}\n","// @flow\n\nimport { number as interpolate } from '../style-spec/util/interpolate';\n\nimport Anchor from '../symbol/anchor';\nimport checkMaxAngle from './check_max_angle';\n\nimport type Point from '@mapbox/point-geometry';\nimport type {Shaping, PositionedIcon} from './shaping';\n\nexport { getAnchors, getCenterAnchor };\n\nfunction getLineLength(line: Array<Point>): number {\n    let lineLength = 0;\n    for (let k = 0; k < line.length - 1; k++) {\n        lineLength += line[k].dist(line[k + 1]);\n    }\n    return lineLength;\n}\n\nfunction getAngleWindowSize(shapedText: ?Shaping,\n                            glyphSize: number,\n                            boxScale: number): number {\n    return shapedText ?\n        3 / 5 * glyphSize * boxScale :\n        0;\n}\n\nfunction getShapedLabelLength(shapedText: ?Shaping, shapedIcon: ?PositionedIcon): number {\n    return Math.max(\n        shapedText ? shapedText.right - shapedText.left : 0,\n        shapedIcon ? shapedIcon.right - shapedIcon.left : 0);\n}\n\nfunction getCenterAnchor(line: Array<Point>,\n                         maxAngle: number,\n                         shapedText: ?Shaping,\n                         shapedIcon: ?PositionedIcon,\n                         glyphSize: number,\n                         boxScale: number) {\n    const angleWindowSize = getAngleWindowSize(shapedText, glyphSize, boxScale);\n    const labelLength = getShapedLabelLength(shapedText, shapedIcon) * boxScale;\n\n    let prevDistance = 0;\n    const centerDistance = getLineLength(line) / 2;\n\n    for (let i = 0; i < line.length - 1; i++) {\n\n        const a = line[i],\n            b = line[i + 1];\n\n        const segmentDistance = a.dist(b);\n\n        if (prevDistance + segmentDistance > centerDistance) {\n            // The center is on this segment\n            const t = (centerDistance - prevDistance) / segmentDistance,\n                x = interpolate(a.x, b.x, t),\n                y = interpolate(a.y, b.y, t);\n\n            const anchor = new Anchor(x, y, b.angleTo(a), i);\n            anchor._round();\n            if (!angleWindowSize || checkMaxAngle(line, anchor, labelLength, angleWindowSize, maxAngle)) {\n                return anchor;\n            } else {\n                return;\n            }\n        }\n\n        prevDistance += segmentDistance;\n    }\n}\n\nfunction getAnchors(line: Array<Point>,\n                    spacing: number,\n                    maxAngle: number,\n                    shapedText: ?Shaping,\n                    shapedIcon: ?PositionedIcon,\n                    glyphSize: number,\n                    boxScale: number,\n                    overscaling: number,\n                    tileExtent: number) {\n\n    // Resample a line to get anchor points for labels and check that each\n    // potential label passes text-max-angle check and has enough froom to fit\n    // on the line.\n\n    const angleWindowSize = getAngleWindowSize(shapedText, glyphSize, boxScale);\n    const shapedLabelLength = getShapedLabelLength(shapedText, shapedIcon);\n    const labelLength = shapedLabelLength * boxScale;\n\n    // Is the line continued from outside the tile boundary?\n    const isLineContinued = line[0].x === 0 || line[0].x === tileExtent || line[0].y === 0 || line[0].y === tileExtent;\n\n    // Is the label long, relative to the spacing?\n    // If so, adjust the spacing so there is always a minimum space of `spacing / 4` between label edges.\n    if (spacing - labelLength < spacing / 4) {\n        spacing = labelLength + spacing / 4;\n    }\n\n    // Offset the first anchor by:\n    // Either half the label length plus a fixed extra offset if the line is not continued\n    // Or half the spacing if the line is continued.\n\n    // For non-continued lines, add a bit of fixed extra offset to avoid collisions at T intersections.\n    const fixedExtraOffset = glyphSize * 2;\n\n    const offset = !isLineContinued ?\n        ((shapedLabelLength / 2 + fixedExtraOffset) * boxScale * overscaling) % spacing :\n        (spacing / 2 * overscaling) % spacing;\n\n    return resample(line, offset, spacing, angleWindowSize, maxAngle, labelLength, isLineContinued, false, tileExtent);\n}\n\n\nfunction resample(line, offset, spacing, angleWindowSize, maxAngle, labelLength, isLineContinued, placeAtMiddle, tileExtent) {\n\n    const halfLabelLength = labelLength / 2;\n    const lineLength = getLineLength(line);\n\n    let distance = 0,\n        markedDistance = offset - spacing;\n\n    let anchors = [];\n\n    for (let i = 0; i < line.length - 1; i++) {\n\n        const a = line[i],\n            b = line[i + 1];\n\n        const segmentDist = a.dist(b),\n            angle = b.angleTo(a);\n\n        while (markedDistance + spacing < distance + segmentDist) {\n            markedDistance += spacing;\n\n            const t = (markedDistance - distance) / segmentDist,\n                x = interpolate(a.x, b.x, t),\n                y = interpolate(a.y, b.y, t);\n\n            // Check that the point is within the tile boundaries and that\n            // the label would fit before the beginning and end of the line\n            // if placed at this point.\n            if (x >= 0 && x < tileExtent && y >= 0 && y < tileExtent &&\n                    markedDistance - halfLabelLength >= 0 &&\n                    markedDistance + halfLabelLength <= lineLength) {\n                const anchor = new Anchor(x, y, angle, i);\n                anchor._round();\n\n                if (!angleWindowSize || checkMaxAngle(line, anchor, labelLength, angleWindowSize, maxAngle)) {\n                    anchors.push(anchor);\n                }\n            }\n        }\n\n        distance += segmentDist;\n    }\n\n    if (!placeAtMiddle && !anchors.length && !isLineContinued) {\n        // The first attempt at finding anchors at which labels can be placed failed.\n        // Try again, but this time just try placing one anchor at the middle of the line.\n        // This has the most effect for short lines in overscaled tiles, since the\n        // initial offset used in overscaled tiles is calculated to align labels with positions in\n        // parent tiles instead of placing the label as close to the beginning as possible.\n        anchors = resample(line, distance / 2, spacing, angleWindowSize, maxAngle, labelLength, isLineContinued, true, tileExtent);\n    }\n\n    return anchors;\n}\n","// @flow\n\nimport type {CollisionBoxArray} from '../data/array_types';\nimport Point from '@mapbox/point-geometry';\nimport type Anchor from './anchor';\n\n/**\n * A CollisionFeature represents the area of the tile covered by a single label.\n * It is used with CollisionIndex to check if the label overlaps with any\n * previous labels. A CollisionFeature is mostly just a set of CollisionBox\n * objects.\n *\n * @private\n */\nclass CollisionFeature {\n    boxStartIndex: number;\n    boxEndIndex: number;\n\n    /**\n     * Create a CollisionFeature, adding its collision box data to the given collisionBoxArray in the process.\n     *\n     * @param line The geometry the label is placed on.\n     * @param anchor The point along the line around which the label is anchored.\n     * @param shaped The text or icon shaping results.\n     * @param boxScale A magic number used to convert from glyph metrics units to geometry units.\n     * @param padding The amount of padding to add around the label edges.\n     * @param alignLine Whether the label is aligned with the line or the viewport.\n     */\n    constructor(collisionBoxArray: CollisionBoxArray,\n                line: Array<Point>,\n                anchor: Anchor,\n                featureIndex: number,\n                sourceLayerIndex: number,\n                bucketIndex: number,\n                shaped: Object,\n                boxScale: number,\n                padding: number,\n                alignLine: boolean,\n                overscaling: number,\n                rotate: number) {\n        let y1 = shaped.top * boxScale - padding;\n        let y2 = shaped.bottom * boxScale + padding;\n        let x1 = shaped.left * boxScale - padding;\n        let x2 = shaped.right * boxScale + padding;\n\n        this.boxStartIndex = collisionBoxArray.length;\n\n        if (alignLine) {\n\n            let height = y2 - y1;\n            const length = x2 - x1;\n\n            if (height > 0) {\n                // set minimum box height to avoid very many small labels\n                height = Math.max(10 * boxScale, height);\n\n                this._addLineCollisionCircles(collisionBoxArray, line, anchor, (anchor.segment: any), length, height, featureIndex, sourceLayerIndex, bucketIndex, overscaling);\n            }\n\n        } else {\n            if (rotate) {\n                // Account for *-rotate in point collision boxes\n                // See https://github.com/mapbox/mapbox-gl-js/issues/6075\n                // Doesn't account for icon-text-fit\n\n                const tl = new Point(x1, y1);\n                const tr = new Point(x2, y1);\n                const bl = new Point(x1, y2);\n                const br = new Point(x2, y2);\n\n                const rotateRadians = rotate * Math.PI / 180;\n\n                tl._rotate(rotateRadians);\n                tr._rotate(rotateRadians);\n                bl._rotate(rotateRadians);\n                br._rotate(rotateRadians);\n\n                // Collision features require an \"on-axis\" geometry,\n                // so take the envelope of the rotated geometry\n                // (may be quite large for wide labels rotated 45 degrees)\n                x1 = Math.min(tl.x, tr.x, bl.x, br.x);\n                x2 = Math.max(tl.x, tr.x, bl.x, br.x);\n                y1 = Math.min(tl.y, tr.y, bl.y, br.y);\n                y2 = Math.max(tl.y, tr.y, bl.y, br.y);\n            }\n            collisionBoxArray.emplaceBack(anchor.x, anchor.y, x1, y1, x2, y2, featureIndex, sourceLayerIndex, bucketIndex,\n                0, 0);\n        }\n\n        this.boxEndIndex = collisionBoxArray.length;\n    }\n\n    /**\n     * Create a set of CollisionBox objects for a line.\n     *\n     * @param labelLength The length of the label in geometry units.\n     * @param anchor The point along the line around which the label is anchored.\n     * @param boxSize The size of the collision boxes that will be created.\n     * @private\n     */\n    _addLineCollisionCircles(collisionBoxArray: CollisionBoxArray,\n                           line: Array<Point>,\n                           anchor: Anchor,\n                           segment: number,\n                           labelLength: number,\n                           boxSize: number,\n                           featureIndex: number,\n                           sourceLayerIndex: number,\n                           bucketIndex: number,\n                           overscaling: number) {\n        const step = boxSize / 2;\n        const nBoxes = Math.floor(labelLength / step) || 1;\n        // We calculate line collision circles out to 300% of what would normally be our\n        // max size, to allow collision detection to work on labels that expand as\n        // they move into the distance\n        // Vertically oriented labels in the distant field can extend past this padding\n        // This is a noticeable problem in overscaled tiles where the pitch 0-based\n        // symbol spacing will put labels very close together in a pitched map.\n        // To reduce the cost of adding extra collision circles, we slowly increase\n        // them for overscaled tiles.\n        const overscalingPaddingFactor = 1 + .4 * Math.log(overscaling) / Math.LN2;\n        const nPitchPaddingBoxes = Math.floor(nBoxes * overscalingPaddingFactor / 2);\n\n        // offset the center of the first box by half a box so that the edge of the\n        // box is at the edge of the label.\n        const firstBoxOffset = -boxSize / 2;\n\n        let p = anchor;\n        let index = segment + 1;\n        let anchorDistance = firstBoxOffset;\n        const labelStartDistance = -labelLength / 2;\n        const paddingStartDistance = labelStartDistance - labelLength / 4;\n        // move backwards along the line to the first segment the label appears on\n        do {\n            index--;\n\n            if (index < 0) {\n                if (anchorDistance > labelStartDistance) {\n                    // there isn't enough room for the label after the beginning of the line\n                    // checkMaxAngle should have already caught this\n                    return;\n                } else {\n                    // The line doesn't extend far enough back for all of our padding,\n                    // but we got far enough to show the label under most conditions.\n                    index = 0;\n                    break;\n                }\n            } else {\n                anchorDistance -= line[index].dist(p);\n                p = line[index];\n            }\n        } while (anchorDistance > paddingStartDistance);\n\n        let segmentLength = line[index].dist(line[index + 1]);\n\n        for (let i = -nPitchPaddingBoxes; i < nBoxes + nPitchPaddingBoxes; i++) {\n\n            // the distance the box will be from the anchor\n            const boxOffset = i * step;\n            let boxDistanceToAnchor = labelStartDistance + boxOffset;\n\n            // make the distance between pitch padding boxes bigger\n            if (boxOffset < 0) boxDistanceToAnchor += boxOffset;\n            if (boxOffset > labelLength) boxDistanceToAnchor += boxOffset - labelLength;\n\n            if (boxDistanceToAnchor < anchorDistance) {\n                // The line doesn't extend far enough back for this box, skip it\n                // (This could allow for line collisions on distant tiles)\n                continue;\n            }\n\n            // the box is not on the current segment. Move to the next segment.\n            while (anchorDistance + segmentLength < boxDistanceToAnchor) {\n                anchorDistance += segmentLength;\n                index++;\n\n                // There isn't enough room before the end of the line.\n                if (index + 1 >= line.length) {\n                    return;\n                }\n\n                segmentLength = line[index].dist(line[index + 1]);\n            }\n\n            // the distance the box will be from the beginning of the segment\n            const segmentBoxDistance = boxDistanceToAnchor - anchorDistance;\n\n            const p0 = line[index];\n            const p1 = line[index + 1];\n            const boxAnchorPoint = p1.sub(p0)._unit()._mult(segmentBoxDistance)._add(p0)._round();\n\n            // If the box is within boxSize of the anchor, force the box to be used\n            // (so even 0-width labels use at least one box)\n            // Otherwise, the .8 multiplication gives us a little bit of conservative\n            // padding in choosing which boxes to use (see CollisionIndex#placedCollisionCircles)\n            const paddedAnchorDistance = Math.abs(boxDistanceToAnchor - firstBoxOffset) < step ?\n                0 :\n                (boxDistanceToAnchor - firstBoxOffset) * 0.8;\n\n            collisionBoxArray.emplaceBack(boxAnchorPoint.x, boxAnchorPoint.y,\n                -boxSize / 2, -boxSize / 2, boxSize / 2, boxSize / 2,\n                featureIndex, sourceLayerIndex, bucketIndex,\n                boxSize / 2, paddedAnchorDistance);\n        }\n    }\n}\n\nexport default CollisionFeature;\n","\nexport default class TinyQueue {\n    constructor(data = [], compare = defaultCompare) {\n        this.data = data;\n        this.length = this.data.length;\n        this.compare = compare;\n\n        if (this.length > 0) {\n            for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n        }\n    }\n\n    push(item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    }\n\n    pop() {\n        if (this.length === 0) return undefined;\n\n        const top = this.data[0];\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = this.data[this.length];\n            this._down(0);\n        }\n        this.data.pop();\n\n        return top;\n    }\n\n    peek() {\n        return this.data[0];\n    }\n\n    _up(pos) {\n        const {data, compare} = this;\n        const item = data[pos];\n\n        while (pos > 0) {\n            const parent = (pos - 1) >> 1;\n            const current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    }\n\n    _down(pos) {\n        const {data, compare} = this;\n        const halfLength = this.length >> 1;\n        const item = data[pos];\n\n        while (pos < halfLength) {\n            let left = (pos << 1) + 1;\n            let best = data[left];\n            const right = left + 1;\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","// @flow\n\nimport Queue from 'tinyqueue';\n\nimport Point from '@mapbox/point-geometry';\nimport { distToSegmentSquared } from './intersection_tests';\n\n/**\n * Finds an approximation of a polygon's Pole Of Inaccessibiliy https://en.wikipedia.org/wiki/Pole_of_inaccessibility\n * This is a copy of http://github.com/mapbox/polylabel adapted to use Points\n *\n * @param polygonRings first item in array is the outer ring followed optionally by the list of holes, should be an element of the result of util/classify_rings\n * @param precision Specified in input coordinate units. If 0 returns after first run, if > 0 repeatedly narrows the search space until the radius of the area searched for the best pole is less than precision\n * @param debug Print some statistics to the console during execution\n * @returns Pole of Inaccessibiliy.\n * @private\n */\nexport default function (polygonRings: Array<Array<Point>>, precision?: number = 1, debug?: boolean = false): Point {\n    // find the bounding box of the outer ring\n    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n    const outerRing = polygonRings[0];\n    for (let i = 0; i < outerRing.length; i++) {\n        const p = outerRing[i];\n        if (!i || p.x < minX) minX = p.x;\n        if (!i || p.y < minY) minY = p.y;\n        if (!i || p.x > maxX) maxX = p.x;\n        if (!i || p.y > maxY) maxY = p.y;\n    }\n\n    const width = maxX - minX;\n    const height = maxY - minY;\n    const cellSize = Math.min(width, height);\n    let h = cellSize / 2;\n\n    // a priority queue of cells in order of their \"potential\" (max distance to polygon)\n    const cellQueue = new Queue([], compareMax);\n\n    if (cellSize === 0) return new Point(minX, minY);\n\n    // cover polygon with initial cells\n    for (let x = minX; x < maxX; x += cellSize) {\n        for (let y = minY; y < maxY; y += cellSize) {\n            cellQueue.push(new Cell(x + h, y + h, h, polygonRings));\n        }\n    }\n\n    // take centroid as the first best guess\n    let bestCell = getCentroidCell(polygonRings);\n    let numProbes = cellQueue.length;\n\n    while (cellQueue.length) {\n        // pick the most promising cell from the queue\n        const cell = cellQueue.pop();\n\n        // update the best cell if we found a better one\n        if (cell.d > bestCell.d || !bestCell.d) {\n            bestCell = cell;\n            if (debug) console.log('found best %d after %d probes', Math.round(1e4 * cell.d) / 1e4, numProbes);\n        }\n\n        // do not drill down further if there's no chance of a better solution\n        if (cell.max - bestCell.d <= precision) continue;\n\n        // split the cell into four cells\n        h = cell.h / 2;\n        cellQueue.push(new Cell(cell.p.x - h, cell.p.y - h, h, polygonRings));\n        cellQueue.push(new Cell(cell.p.x + h, cell.p.y - h, h, polygonRings));\n        cellQueue.push(new Cell(cell.p.x - h, cell.p.y + h, h, polygonRings));\n        cellQueue.push(new Cell(cell.p.x + h, cell.p.y + h, h, polygonRings));\n        numProbes += 4;\n    }\n\n    if (debug) {\n        console.log(`num probes: ${numProbes}`);\n        console.log(`best distance: ${bestCell.d}`);\n    }\n\n    return bestCell.p;\n}\n\nfunction compareMax(a, b) {\n    return b.max - a.max;\n}\n\nfunction Cell(x, y, h, polygon) {\n    this.p = new Point(x, y);\n    this.h = h; // half the cell size\n    this.d = pointToPolygonDist(this.p, polygon); // distance from cell center to polygon\n    this.max = this.d + this.h * Math.SQRT2; // max distance to polygon within a cell\n}\n\n// signed distance from point to polygon outline (negative if point is outside)\nfunction pointToPolygonDist(p, polygon) {\n    let inside = false;\n    let minDistSq = Infinity;\n\n    for (let k = 0; k < polygon.length; k++) {\n        const ring = polygon[k];\n\n        for (let i = 0, len = ring.length, j = len - 1; i < len; j = i++) {\n            const a = ring[i];\n            const b = ring[j];\n\n            if ((a.y > p.y !== b.y > p.y) &&\n                (p.x < (b.x - a.x) * (p.y - a.y) / (b.y - a.y) + a.x)) inside = !inside;\n\n            minDistSq = Math.min(minDistSq, distToSegmentSquared(p, a, b));\n        }\n    }\n\n    return (inside ? 1 : -1) * Math.sqrt(minDistSq);\n}\n\n// get polygon centroid\nfunction getCentroidCell(polygon) {\n    let area = 0;\n    let x = 0;\n    let y = 0;\n    const points = polygon[0];\n    for (let i = 0, len = points.length, j = len - 1; i < len; j = i++) {\n        const a = points[i];\n        const b = points[j];\n        const f = a.x * b.y - b.x * a.y;\n        x += (a.x + b.x) * f;\n        y += (a.y + b.y) * f;\n        area += f * 3;\n    }\n    return new Cell(x / area, y / area, 0, polygon);\n}\n","/**\n * JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)\n * \n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/murmurhash-js\n * @author <a href=\"mailto:aappleby@gmail.com\">Austin Appleby</a>\n * @see http://sites.google.com/site/murmurhash/\n * \n * @param {string} key ASCII only\n * @param {number} seed Positive integer only\n * @return {number} 32-bit positive integer hash \n */\n\nfunction murmurhash3_32_gc(key, seed) {\n\tvar remainder, bytes, h1, h1b, c1, c1b, c2, c2b, k1, i;\n\t\n\tremainder = key.length & 3; // key.length % 4\n\tbytes = key.length - remainder;\n\th1 = seed;\n\tc1 = 0xcc9e2d51;\n\tc2 = 0x1b873593;\n\ti = 0;\n\t\n\twhile (i < bytes) {\n\t  \tk1 = \n\t  \t  ((key.charCodeAt(i) & 0xff)) |\n\t  \t  ((key.charCodeAt(++i) & 0xff) << 8) |\n\t  \t  ((key.charCodeAt(++i) & 0xff) << 16) |\n\t  \t  ((key.charCodeAt(++i) & 0xff) << 24);\n\t\t++i;\n\t\t\n\t\tk1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;\n\t\tk1 = (k1 << 15) | (k1 >>> 17);\n\t\tk1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;\n\n\t\th1 ^= k1;\n        h1 = (h1 << 13) | (h1 >>> 19);\n\t\th1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;\n\t\th1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));\n\t}\n\t\n\tk1 = 0;\n\t\n\tswitch (remainder) {\n\t\tcase 3: k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;\n\t\tcase 2: k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;\n\t\tcase 1: k1 ^= (key.charCodeAt(i) & 0xff);\n\t\t\n\t\tk1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;\n\t\tk1 = (k1 << 15) | (k1 >>> 17);\n\t\tk1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;\n\t\th1 ^= k1;\n\t}\n\t\n\th1 ^= key.length;\n\n\th1 ^= h1 >>> 16;\n\th1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;\n\th1 ^= h1 >>> 13;\n\th1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;\n\th1 ^= h1 >>> 16;\n\n\treturn h1 >>> 0;\n}\n\nif(typeof module !== \"undefined\") {\n  module.exports = murmurhash3_32_gc\n}","/**\n * JS Implementation of MurmurHash2\n * \n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/murmurhash-js\n * @author <a href=\"mailto:aappleby@gmail.com\">Austin Appleby</a>\n * @see http://sites.google.com/site/murmurhash/\n * \n * @param {string} str ASCII only\n * @param {number} seed Positive integer only\n * @return {number} 32-bit positive integer hash\n */\n\nfunction murmurhash2_32_gc(str, seed) {\n  var\n    l = str.length,\n    h = seed ^ l,\n    i = 0,\n    k;\n  \n  while (l >= 4) {\n  \tk = \n  \t  ((str.charCodeAt(i) & 0xff)) |\n  \t  ((str.charCodeAt(++i) & 0xff) << 8) |\n  \t  ((str.charCodeAt(++i) & 0xff) << 16) |\n  \t  ((str.charCodeAt(++i) & 0xff) << 24);\n    \n    k = (((k & 0xffff) * 0x5bd1e995) + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16));\n    k ^= k >>> 24;\n    k = (((k & 0xffff) * 0x5bd1e995) + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16));\n\n\th = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16)) ^ k;\n\n    l -= 4;\n    ++i;\n  }\n  \n  switch (l) {\n  case 3: h ^= (str.charCodeAt(i + 2) & 0xff) << 16;\n  case 2: h ^= (str.charCodeAt(i + 1) & 0xff) << 8;\n  case 1: h ^= (str.charCodeAt(i) & 0xff);\n          h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16));\n  }\n\n  h ^= h >>> 13;\n  h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16));\n  h ^= h >>> 15;\n\n  return h >>> 0;\n}\n\nif(typeof module !== undefined) {\n  module.exports = murmurhash2_32_gc\n}\n","var murmur3 = require(\"./murmurhash3_gc.js\")\nvar murmur2 = require(\"./murmurhash2_gc.js\")\n\nmodule.exports = murmur3\nmodule.exports.murmur3 = murmur3\nmodule.exports.murmur2 = murmur2\n","// @flow\n\nimport Anchor from './anchor';\n\nimport { getAnchors, getCenterAnchor } from './get_anchors';\nimport clipLine from './clip_line';\nimport { shapeText, shapeIcon, WritingMode } from './shaping';\nimport { getGlyphQuads, getIconQuads } from './quads';\nimport CollisionFeature from './collision_feature';\nimport { warnOnce } from '../util/util';\nimport {\n    allowsVerticalWritingMode,\n    allowsLetterSpacing\n} from '../util/script_detection';\nimport findPoleOfInaccessibility from '../util/find_pole_of_inaccessibility';\nimport classifyRings from '../util/classify_rings';\nimport EXTENT from '../data/extent';\nimport SymbolBucket from '../data/bucket/symbol_bucket';\nimport EvaluationParameters from '../style/evaluation_parameters';\nimport {SIZE_PACK_FACTOR} from './symbol_size';\n\nimport type {Shaping, PositionedIcon} from './shaping';\nimport type {CollisionBoxArray} from '../data/array_types';\nimport type {SymbolFeature} from '../data/bucket/symbol_bucket';\nimport type {StyleImage} from '../style/style_image';\nimport type {StyleGlyph} from '../style/style_glyph';\nimport type SymbolStyleLayer from '../style/style_layer/symbol_style_layer';\nimport type {ImagePosition} from '../render/image_atlas';\nimport type {GlyphPosition} from '../render/glyph_atlas';\nimport type {PossiblyEvaluatedPropertyValue} from '../style/properties';\n\nimport Point from '@mapbox/point-geometry';\nimport murmur3 from 'murmurhash-js';\n\n// The symbol layout process needs `text-size` evaluated at up to five different zoom levels, and\n// `icon-size` at up to three:\n//\n//   1. `text-size` at the zoom level of the bucket. Used to calculate a per-feature size for source `text-size`\n//       expressions, and to calculate the box dimensions for icon-text-fit.\n//   2. `icon-size` at the zoom level of the bucket. Used to calculate a per-feature size for source `icon-size`\n//       expressions.\n//   3. `text-size` and `icon-size` at the zoom level of the bucket, plus one. Used to calculate collision boxes.\n//   4. `text-size` at zoom level 18. Used for something line-symbol-placement-related.\n//   5.  For composite `*-size` expressions: two zoom levels of curve stops that \"cover\" the zoom level of the\n//       bucket. These go into a vertex buffer and are used by the shader to interpolate the size at render time.\n//\n// (1) and (2) are stored in `bucket.layers[0].layout`. The remainder are below.\n//\ntype Sizes = {\n    layoutTextSize: PossiblyEvaluatedPropertyValue<number>, // (3)\n    layoutIconSize: PossiblyEvaluatedPropertyValue<number>, // (3)\n    textMaxSize: PossiblyEvaluatedPropertyValue<number>,    // (4)\n    compositeTextSizes: [PossiblyEvaluatedPropertyValue<number>, PossiblyEvaluatedPropertyValue<number>], // (5)\n    compositeIconSizes: [PossiblyEvaluatedPropertyValue<number>, PossiblyEvaluatedPropertyValue<number>], // (5)\n};\n\nexport function performSymbolLayout(bucket: SymbolBucket,\n                             glyphMap: {[string]: {[number]: ?StyleGlyph}},\n                             glyphPositions: {[string]: {[number]: GlyphPosition}},\n                             imageMap: {[string]: StyleImage},\n                             imagePositions: {[string]: ImagePosition},\n                             showCollisionBoxes: boolean) {\n    bucket.createArrays();\n\n    const tileSize = 512 * bucket.overscaling;\n    bucket.tilePixelRatio = EXTENT / tileSize;\n    bucket.compareText = {};\n    bucket.iconsNeedLinear = false;\n\n    const layout = bucket.layers[0].layout;\n    const unevaluatedLayoutValues = bucket.layers[0]._unevaluatedLayout._values;\n\n    const sizes = {};\n\n    if (bucket.textSizeData.functionType === 'composite') {\n        const {min, max} = bucket.textSizeData.zoomRange;\n        sizes.compositeTextSizes = [\n            unevaluatedLayoutValues['text-size'].possiblyEvaluate(new EvaluationParameters(min)),\n            unevaluatedLayoutValues['text-size'].possiblyEvaluate(new EvaluationParameters(max))\n        ];\n    }\n\n    if (bucket.iconSizeData.functionType === 'composite') {\n        const {min, max} = bucket.iconSizeData.zoomRange;\n        sizes.compositeIconSizes = [\n            unevaluatedLayoutValues['icon-size'].possiblyEvaluate(new EvaluationParameters(min)),\n            unevaluatedLayoutValues['icon-size'].possiblyEvaluate(new EvaluationParameters(max))\n        ];\n    }\n\n    sizes.layoutTextSize = unevaluatedLayoutValues['text-size'].possiblyEvaluate(new EvaluationParameters(bucket.zoom + 1));\n    sizes.layoutIconSize = unevaluatedLayoutValues['icon-size'].possiblyEvaluate(new EvaluationParameters(bucket.zoom + 1));\n    sizes.textMaxSize = unevaluatedLayoutValues['text-size'].possiblyEvaluate(new EvaluationParameters(18));\n\n    const oneEm = 24;\n    const lineHeight = layout.get('text-line-height') * oneEm;\n    const textAlongLine = layout.get('text-rotation-alignment') === 'map' && layout.get('symbol-placement') !== 'point';\n    const keepUpright = layout.get('text-keep-upright');\n\n\n    for (const feature of bucket.features) {\n        const fontstack = layout.get('text-font').evaluate(feature, {}).join(',');\n        const glyphPositionMap = glyphPositions;\n\n        const shapedTextOrientations = {};\n        const text = feature.text;\n        if (text) {\n            const unformattedText = text.toString();\n            const textOffset: [number, number] = (layout.get('text-offset').evaluate(feature, {}).map((t) => t * oneEm): any);\n            const spacing = layout.get('text-letter-spacing').evaluate(feature, {}) * oneEm;\n            const spacingIfAllowed = allowsLetterSpacing(unformattedText) ? spacing : 0;\n            const textAnchor = layout.get('text-anchor').evaluate(feature, {});\n            const textJustify = layout.get('text-justify').evaluate(feature, {});\n            const maxWidth = layout.get('symbol-placement') === 'point' ?\n                layout.get('text-max-width').evaluate(feature, {}) * oneEm :\n                0;\n\n            shapedTextOrientations.horizontal = shapeText(text, glyphMap, fontstack, maxWidth, lineHeight, textAnchor, textJustify, spacingIfAllowed, textOffset, oneEm, WritingMode.horizontal);\n            if (allowsVerticalWritingMode(unformattedText) && textAlongLine && keepUpright) {\n                shapedTextOrientations.vertical = shapeText(text, glyphMap, fontstack, maxWidth, lineHeight, textAnchor, textJustify, spacingIfAllowed, textOffset, oneEm, WritingMode.vertical);\n            }\n        }\n\n        let shapedIcon;\n        if (feature.icon) {\n            const image = imageMap[feature.icon];\n            if (image) {\n                shapedIcon = shapeIcon(\n                    imagePositions[feature.icon],\n                    layout.get('icon-offset').evaluate(feature, {}),\n                    layout.get('icon-anchor').evaluate(feature, {}));\n                if (bucket.sdfIcons === undefined) {\n                    bucket.sdfIcons = image.sdf;\n                } else if (bucket.sdfIcons !== image.sdf) {\n                    warnOnce('Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer');\n                }\n                if (image.pixelRatio !== bucket.pixelRatio) {\n                    bucket.iconsNeedLinear = true;\n                } else if (layout.get('icon-rotate').constantOr(1) !== 0) {\n                    bucket.iconsNeedLinear = true;\n                }\n            }\n        }\n\n        if (shapedTextOrientations.horizontal || shapedIcon) {\n            addFeature(bucket, feature, shapedTextOrientations, shapedIcon, glyphPositionMap, sizes);\n        }\n    }\n\n    if (showCollisionBoxes) {\n        bucket.generateCollisionDebugBuffers();\n    }\n}\n\n\n/**\n * Given a feature and its shaped text and icon data, add a 'symbol\n * instance' for each _possible_ placement of the symbol feature.\n * (At render timePlaceSymbols#place() selects which of these instances to\n * show or hide based on collisions with symbols in other layers.)\n * @private\n */\nfunction addFeature(bucket: SymbolBucket,\n                    feature: SymbolFeature,\n                    shapedTextOrientations: any,\n                    shapedIcon: PositionedIcon | void,\n                    glyphPositionMap: {[string]: {[number]: GlyphPosition}},\n                    sizes: Sizes) {\n    const layoutTextSize = sizes.layoutTextSize.evaluate(feature, {});\n    const layoutIconSize = sizes.layoutIconSize.evaluate(feature, {});\n\n    // To reduce the number of labels that jump around when zooming we need\n    // to use a text-size value that is the same for all zoom levels.\n    // bucket calculates text-size at a high zoom level so that all tiles can\n    // use the same value when calculating anchor positions.\n    let textMaxSize = sizes.textMaxSize.evaluate(feature, {});\n    if (textMaxSize === undefined) {\n        textMaxSize = layoutTextSize;\n    }\n\n    const layout = bucket.layers[0].layout;\n    const textOffset = layout.get('text-offset').evaluate(feature, {});\n    const iconOffset = layout.get('icon-offset').evaluate(feature, {});\n\n    const glyphSize = 24,\n        fontScale = layoutTextSize / glyphSize,\n        textBoxScale = bucket.tilePixelRatio * fontScale,\n        textMaxBoxScale = bucket.tilePixelRatio * textMaxSize / glyphSize,\n        iconBoxScale = bucket.tilePixelRatio * layoutIconSize,\n        symbolMinDistance = bucket.tilePixelRatio * layout.get('symbol-spacing'),\n        textPadding = layout.get('text-padding') * bucket.tilePixelRatio,\n        iconPadding = layout.get('icon-padding') * bucket.tilePixelRatio,\n        textMaxAngle = layout.get('text-max-angle') / 180 * Math.PI,\n        textAlongLine = layout.get('text-rotation-alignment') === 'map' && layout.get('symbol-placement') !== 'point',\n        iconAlongLine = layout.get('icon-rotation-alignment') === 'map' && layout.get('symbol-placement') !== 'point',\n        symbolPlacement = layout.get('symbol-placement'),\n        textRepeatDistance = symbolMinDistance / 2;\n\n    const addSymbolAtAnchor = (line, anchor) => {\n        if (anchor.x < 0 || anchor.x >= EXTENT || anchor.y < 0 || anchor.y >= EXTENT) {\n            // Symbol layers are drawn across tile boundaries, We filter out symbols\n            // outside our tile boundaries (which may be included in vector tile buffers)\n            // to prevent double-drawing symbols.\n            return;\n        }\n\n        addSymbol(bucket, anchor, line, shapedTextOrientations, shapedIcon, bucket.layers[0],\n            bucket.collisionBoxArray, feature.index, feature.sourceLayerIndex, bucket.index,\n            textBoxScale, textPadding, textAlongLine, textOffset,\n            iconBoxScale, iconPadding, iconAlongLine, iconOffset,\n            feature, glyphPositionMap, sizes);\n    };\n\n    if (symbolPlacement === 'line') {\n        for (const line of clipLine(feature.geometry, 0, 0, EXTENT, EXTENT)) {\n            const anchors = getAnchors(\n                line,\n                symbolMinDistance,\n                textMaxAngle,\n                shapedTextOrientations.vertical || shapedTextOrientations.horizontal,\n                shapedIcon,\n                glyphSize,\n                textMaxBoxScale,\n                bucket.overscaling,\n                EXTENT\n            );\n            for (const anchor of anchors) {\n                const shapedText = shapedTextOrientations.horizontal;\n                if (!shapedText || !anchorIsTooClose(bucket, shapedText.text, textRepeatDistance, anchor)) {\n                    addSymbolAtAnchor(line, anchor);\n                }\n            }\n        }\n    } else if (symbolPlacement === 'line-center') {\n        // No clipping, multiple lines per feature are allowed\n        // \"lines\" with only one point are ignored as in clipLines\n        for (const line of feature.geometry) {\n            if (line.length > 1) {\n                const anchor = getCenterAnchor(\n                    line,\n                    textMaxAngle,\n                    shapedTextOrientations.vertical || shapedTextOrientations.horizontal,\n                    shapedIcon,\n                    glyphSize,\n                    textMaxBoxScale);\n                if (anchor) {\n                    addSymbolAtAnchor(line, anchor);\n                }\n            }\n        }\n    } else if (feature.type === 'Polygon') {\n        for (const polygon of classifyRings(feature.geometry, 0)) {\n            // 16 here represents 2 pixels\n            const poi = findPoleOfInaccessibility(polygon, 16);\n            addSymbolAtAnchor(polygon[0], new Anchor(poi.x, poi.y, 0));\n        }\n    } else if (feature.type === 'LineString') {\n        // https://github.com/mapbox/mapbox-gl-js/issues/3808\n        for (const line of feature.geometry) {\n            addSymbolAtAnchor(line, new Anchor(line[0].x, line[0].y, 0));\n        }\n    } else if (feature.type === 'Point') {\n        for (const points of feature.geometry) {\n            for (const point of points) {\n                addSymbolAtAnchor([point], new Anchor(point.x, point.y, 0));\n            }\n        }\n    }\n}\n\nconst MAX_PACKED_SIZE = 65535;\n\nfunction addTextVertices(bucket: SymbolBucket,\n                         anchor: Point,\n                         shapedText: Shaping,\n                         layer: SymbolStyleLayer,\n                         textAlongLine: boolean,\n                         feature: SymbolFeature,\n                         textOffset: [number, number],\n                         lineArray: {lineStartIndex: number, lineLength: number},\n                         writingMode: number,\n                         placedTextSymbolIndices: Array<number>,\n                         glyphPositionMap: {[string]: {[number]: GlyphPosition}},\n                         sizes: Sizes) {\n    const glyphQuads = getGlyphQuads(anchor, shapedText,\n                            layer, textAlongLine, feature, glyphPositionMap);\n\n    const sizeData = bucket.textSizeData;\n    let textSizeData = null;\n\n    if (sizeData.functionType === 'source') {\n        textSizeData = [\n            SIZE_PACK_FACTOR * layer.layout.get('text-size').evaluate(feature, {})\n        ];\n        if (textSizeData[0] > MAX_PACKED_SIZE) {\n            warnOnce(`${bucket.layerIds[0]}: Value for \"text-size\" is >= 256. Reduce your \"text-size\".`);\n        }\n    } else if (sizeData.functionType === 'composite') {\n        textSizeData = [\n            SIZE_PACK_FACTOR * sizes.compositeTextSizes[0].evaluate(feature, {}),\n            SIZE_PACK_FACTOR * sizes.compositeTextSizes[1].evaluate(feature, {})\n        ];\n        if (textSizeData[0] > MAX_PACKED_SIZE || textSizeData[1] > MAX_PACKED_SIZE) {\n            warnOnce(`${bucket.layerIds[0]}: Value for \"text-size\" is >= 256. Reduce your \"text-size\".`);\n        }\n    }\n\n    bucket.addSymbols(\n        bucket.text,\n        glyphQuads,\n        textSizeData,\n        textOffset,\n        textAlongLine,\n        feature,\n        writingMode,\n        anchor,\n        lineArray.lineStartIndex,\n        lineArray.lineLength);\n\n    // The placedSymbolArray is used at render time in drawTileSymbols\n    // These indices allow access to the array at collision detection time\n    placedTextSymbolIndices.push(bucket.text.placedSymbolArray.length - 1);\n\n    return glyphQuads.length * 4;\n}\n\n\n/**\n * Add a single label & icon placement.\n *\n * @private\n */\nfunction addSymbol(bucket: SymbolBucket,\n                   anchor: Anchor,\n                   line: Array<Point>,\n                   shapedTextOrientations: any,\n                   shapedIcon: PositionedIcon | void,\n                   layer: SymbolStyleLayer,\n                   collisionBoxArray: CollisionBoxArray,\n                   featureIndex: number,\n                   sourceLayerIndex: number,\n                   bucketIndex: number,\n                   textBoxScale: number,\n                   textPadding: number,\n                   textAlongLine: boolean,\n                   textOffset: [number, number],\n                   iconBoxScale: number,\n                   iconPadding: number,\n                   iconAlongLine: boolean,\n                   iconOffset: [number, number],\n                   feature: SymbolFeature,\n                   glyphPositionMap: {[string]: {[number]: GlyphPosition}},\n                   sizes: Sizes) {\n    const lineArray = bucket.addToLineVertexArray(anchor, line);\n\n    let textCollisionFeature, iconCollisionFeature;\n\n    let numIconVertices = 0;\n    let numGlyphVertices = 0;\n    let numVerticalGlyphVertices = 0;\n    const key = murmur3(shapedTextOrientations.horizontal ? shapedTextOrientations.horizontal.text : '');\n    const placedTextSymbolIndices = [];\n    if (shapedTextOrientations.horizontal) {\n        // As a collision approximation, we can use either the vertical or the horizontal version of the feature\n        // We're counting on the two versions having similar dimensions\n        const textRotate = layer.layout.get('text-rotate').evaluate(feature, {});\n        textCollisionFeature = new CollisionFeature(collisionBoxArray, line, anchor, featureIndex, sourceLayerIndex, bucketIndex, shapedTextOrientations.horizontal, textBoxScale, textPadding, textAlongLine, bucket.overscaling, textRotate);\n        numGlyphVertices += addTextVertices(bucket, anchor, shapedTextOrientations.horizontal, layer, textAlongLine, feature, textOffset, lineArray, shapedTextOrientations.vertical ? WritingMode.horizontal : WritingMode.horizontalOnly, placedTextSymbolIndices, glyphPositionMap, sizes);\n\n        if (shapedTextOrientations.vertical) {\n            numVerticalGlyphVertices += addTextVertices(bucket, anchor, shapedTextOrientations.vertical, layer, textAlongLine, feature, textOffset, lineArray, WritingMode.vertical, placedTextSymbolIndices, glyphPositionMap, sizes);\n        }\n    }\n\n    const textBoxStartIndex = textCollisionFeature ? textCollisionFeature.boxStartIndex : bucket.collisionBoxArray.length;\n    const textBoxEndIndex = textCollisionFeature ? textCollisionFeature.boxEndIndex : bucket.collisionBoxArray.length;\n\n    if (shapedIcon) {\n        const iconQuads = getIconQuads(anchor, shapedIcon, layer,\n                            iconAlongLine, shapedTextOrientations.horizontal,\n                            feature);\n        const iconRotate = layer.layout.get('icon-rotate').evaluate(feature, {});\n        iconCollisionFeature = new CollisionFeature(collisionBoxArray, line, anchor, featureIndex, sourceLayerIndex, bucketIndex, shapedIcon, iconBoxScale, iconPadding, /*align boxes to line*/false, bucket.overscaling, iconRotate);\n\n        numIconVertices = iconQuads.length * 4;\n\n        const sizeData = bucket.iconSizeData;\n        let iconSizeData = null;\n\n        if (sizeData.functionType === 'source') {\n            iconSizeData = [\n                SIZE_PACK_FACTOR * layer.layout.get('icon-size').evaluate(feature, {})\n            ];\n            if (iconSizeData[0] > MAX_PACKED_SIZE) {\n                warnOnce(`${bucket.layerIds[0]}: Value for \"icon-size\" is >= 256. Reduce your \"icon-size\".`);\n            }\n        } else if (sizeData.functionType === 'composite') {\n            iconSizeData = [\n                SIZE_PACK_FACTOR * sizes.compositeIconSizes[0].evaluate(feature, {}),\n                SIZE_PACK_FACTOR * sizes.compositeIconSizes[1].evaluate(feature, {})\n            ];\n            if (iconSizeData[0] > MAX_PACKED_SIZE || iconSizeData[1] > MAX_PACKED_SIZE) {\n                warnOnce(`${bucket.layerIds[0]}: Value for \"icon-size\" is >= 256. Reduce your \"icon-size\".`);\n            }\n        }\n\n        bucket.addSymbols(\n            bucket.icon,\n            iconQuads,\n            iconSizeData,\n            iconOffset,\n            iconAlongLine,\n            feature,\n            false,\n            anchor,\n            lineArray.lineStartIndex,\n            lineArray.lineLength);\n    }\n\n    const iconBoxStartIndex = iconCollisionFeature ? iconCollisionFeature.boxStartIndex : bucket.collisionBoxArray.length;\n    const iconBoxEndIndex = iconCollisionFeature ? iconCollisionFeature.boxEndIndex : bucket.collisionBoxArray.length;\n\n    if (bucket.glyphOffsetArray.length >= SymbolBucket.MAX_GLYPHS) warnOnce(\n        \"Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907\"\n    );\n\n    bucket.symbolInstances.emplaceBack(\n        anchor.x,\n        anchor.y,\n        placedTextSymbolIndices.length > 0 ? placedTextSymbolIndices[0] : -1,\n        placedTextSymbolIndices.length > 1 ? placedTextSymbolIndices[1] : -1,\n        key,\n        textBoxStartIndex,\n        textBoxEndIndex,\n        iconBoxStartIndex,\n        iconBoxEndIndex,\n        featureIndex,\n        numGlyphVertices,\n        numVerticalGlyphVertices,\n        numIconVertices,\n        0);\n}\n\nfunction anchorIsTooClose(bucket: any, text: string, repeatDistance: number, anchor: Point) {\n    const compareText = bucket.compareText;\n    if (!(text in compareText)) {\n        compareText[text] = [];\n    } else {\n        const otherAnchors = compareText[text];\n        for (let k = otherAnchors.length - 1; k >= 0; k--) {\n            if (anchor.dist(otherAnchors[k]) < repeatDistance) {\n                // If it's within repeatDistance of one anchor, stop looking\n                return true;\n            }\n        }\n    }\n    // If anchor is not within repeatDistance of any other anchor, add to array\n    compareText[text].push(anchor);\n    return false;\n}\n","// @flow\n\nimport Point from '@mapbox/point-geometry';\n\nimport { GLYPH_PBF_BORDER } from '../style/parse_glyph_pbf';\n\nimport type Anchor from './anchor';\nimport type {PositionedIcon, Shaping} from './shaping';\nimport type SymbolStyleLayer from '../style/style_layer/symbol_style_layer';\nimport type {Feature} from '../style-spec/expression';\nimport type {GlyphPosition} from '../render/glyph_atlas';\n\n/**\n * A textured quad for rendering a single icon or glyph.\n *\n * The zoom range the glyph can be shown is defined by minScale and maxScale.\n *\n * @param tl The offset of the top left corner from the anchor.\n * @param tr The offset of the top right corner from the anchor.\n * @param bl The offset of the bottom left corner from the anchor.\n * @param br The offset of the bottom right corner from the anchor.\n * @param tex The texture coordinates.\n *\n * @private\n */\nexport type SymbolQuad = {\n    tl: Point,\n    tr: Point,\n    bl: Point,\n    br: Point,\n    tex: {\n        x: number,\n        y: number,\n        w: number,\n        h: number\n    },\n    writingMode: any | void,\n    glyphOffset: [number, number]\n};\n\n/**\n * Create the quads used for rendering an icon.\n * @private\n */\nexport function getIconQuads(anchor: Anchor,\n                      shapedIcon: PositionedIcon,\n                      layer: SymbolStyleLayer,\n                      alongLine: boolean,\n                      shapedText: Shaping,\n                      feature: Feature): Array<SymbolQuad> {\n    const image = shapedIcon.image;\n    const layout = layer.layout;\n\n    // If you have a 10px icon that isn't perfectly aligned to the pixel grid it will cover 11 actual\n    // pixels. The quad needs to be padded to account for this, otherwise they'll look slightly clipped\n    // on one edge in some cases.\n    const border = 1;\n\n    const top = shapedIcon.top - border / image.pixelRatio;\n    const left = shapedIcon.left - border / image.pixelRatio;\n    const bottom = shapedIcon.bottom + border / image.pixelRatio;\n    const right = shapedIcon.right + border / image.pixelRatio;\n    let tl, tr, br, bl;\n\n    // text-fit mode\n    if (layout.get('icon-text-fit') !== 'none' && shapedText) {\n        const iconWidth = (right - left),\n            iconHeight = (bottom - top),\n            size = layout.get('text-size').evaluate(feature, {}) / 24,\n            textLeft = shapedText.left * size,\n            textRight = shapedText.right * size,\n            textTop = shapedText.top * size,\n            textBottom = shapedText.bottom * size,\n            textWidth = textRight - textLeft,\n            textHeight = textBottom - textTop,\n            padT = layout.get('icon-text-fit-padding')[0],\n            padR = layout.get('icon-text-fit-padding')[1],\n            padB = layout.get('icon-text-fit-padding')[2],\n            padL = layout.get('icon-text-fit-padding')[3],\n            offsetY = layout.get('icon-text-fit') === 'width' ? (textHeight - iconHeight) * 0.5 : 0,\n            offsetX = layout.get('icon-text-fit') === 'height' ? (textWidth - iconWidth) * 0.5 : 0,\n            width = layout.get('icon-text-fit') === 'width' || layout.get('icon-text-fit') === 'both' ? textWidth : iconWidth,\n            height = layout.get('icon-text-fit') === 'height' || layout.get('icon-text-fit') === 'both' ? textHeight : iconHeight;\n        tl = new Point(textLeft + offsetX - padL,         textTop + offsetY - padT);\n        tr = new Point(textLeft + offsetX + padR + width, textTop + offsetY - padT);\n        br = new Point(textLeft + offsetX + padR + width, textTop + offsetY + padB + height);\n        bl = new Point(textLeft + offsetX - padL,         textTop + offsetY + padB + height);\n    // Normal icon size mode\n    } else {\n        tl = new Point(left, top);\n        tr = new Point(right, top);\n        br = new Point(right, bottom);\n        bl = new Point(left, bottom);\n    }\n\n    const angle = layer.layout.get('icon-rotate').evaluate(feature, {}) * Math.PI / 180;\n\n    if (angle) {\n        const sin = Math.sin(angle),\n            cos = Math.cos(angle),\n            matrix = [cos, -sin, sin, cos];\n\n        tl._matMult(matrix);\n        tr._matMult(matrix);\n        bl._matMult(matrix);\n        br._matMult(matrix);\n    }\n\n    // Icon quad is padded, so texture coordinates also need to be padded.\n    return [{tl, tr, bl, br, tex: image.paddedRect, writingMode: undefined, glyphOffset: [0, 0]}];\n}\n\n/**\n * Create the quads used for rendering a text label.\n * @private\n */\nexport function getGlyphQuads(anchor: Anchor,\n                       shaping: Shaping,\n                       layer: SymbolStyleLayer,\n                       alongLine: boolean,\n                       feature: Feature,\n                       positions: {[string]: {[number]: GlyphPosition}}): Array<SymbolQuad> {\n\n    const oneEm = 24;\n    const textRotate = layer.layout.get('text-rotate').evaluate(feature, {}) * Math.PI / 180;\n    const textOffset = layer.layout.get('text-offset').evaluate(feature, {}).map((t) => t * oneEm);\n\n    const positionedGlyphs = shaping.positionedGlyphs;\n    const quads = [];\n\n\n    for (let k = 0; k < positionedGlyphs.length; k++) {\n        const positionedGlyph = positionedGlyphs[k];\n        const glyphPositions = positions[positionedGlyph.fontStack];\n        const glyph = glyphPositions && glyphPositions[positionedGlyph.glyph];\n        if (!glyph) continue;\n\n        const rect = glyph.rect;\n        if (!rect) continue;\n\n        // The rects have an addditional buffer that is not included in their size.\n        const glyphPadding = 1.0;\n        const rectBuffer = GLYPH_PBF_BORDER + glyphPadding;\n\n        const halfAdvance = glyph.metrics.advance * positionedGlyph.scale / 2;\n\n        const glyphOffset = alongLine ?\n            [positionedGlyph.x + halfAdvance, positionedGlyph.y] :\n            [0, 0];\n\n        const builtInOffset = alongLine ?\n            [0, 0] :\n            [positionedGlyph.x + halfAdvance + textOffset[0], positionedGlyph.y + textOffset[1]];\n\n        const x1 = (glyph.metrics.left - rectBuffer) * positionedGlyph.scale - halfAdvance + builtInOffset[0];\n        const y1 = (-glyph.metrics.top - rectBuffer) * positionedGlyph.scale + builtInOffset[1];\n        const x2 = x1 + rect.w * positionedGlyph.scale;\n        const y2 = y1 + rect.h * positionedGlyph.scale;\n\n        const tl = new Point(x1, y1);\n        const tr = new Point(x2, y1);\n        const bl  = new Point(x1, y2);\n        const br = new Point(x2, y2);\n\n        if (alongLine && positionedGlyph.vertical) {\n            // Vertical-supporting glyphs are laid out in 24x24 point boxes (1 square em)\n            // In horizontal orientation, the y values for glyphs are below the midline\n            // and we use a \"yOffset\" of -17 to pull them up to the middle.\n            // By rotating counter-clockwise around the point at the center of the left\n            // edge of a 24x24 layout box centered below the midline, we align the center\n            // of the glyphs with the horizontal midline, so the yOffset is no longer\n            // necessary, but we also pull the glyph to the left along the x axis\n            const center = new Point(-halfAdvance, halfAdvance);\n            const verticalRotation = -Math.PI / 2;\n            const xOffsetCorrection = new Point(5, 0);\n            tl._rotateAround(verticalRotation, center)._add(xOffsetCorrection);\n            tr._rotateAround(verticalRotation, center)._add(xOffsetCorrection);\n            bl._rotateAround(verticalRotation, center)._add(xOffsetCorrection);\n            br._rotateAround(verticalRotation, center)._add(xOffsetCorrection);\n        }\n\n        if (textRotate) {\n            const sin = Math.sin(textRotate),\n                cos = Math.cos(textRotate),\n                matrix = [cos, -sin, sin, cos];\n\n            tl._matMult(matrix);\n            tr._matMult(matrix);\n            bl._matMult(matrix);\n            br._matMult(matrix);\n        }\n\n        quads.push({tl, tr, bl, br, tex: rect, writingMode: shaping.writingMode, glyphOffset});\n    }\n\n    return quads;\n}\n","// @flow\n\nimport Point from '@mapbox/point-geometry';\n\nexport default clipLine;\n\n/**\n * Returns the part of a multiline that intersects with the provided rectangular box.\n *\n * @param lines\n * @param x1 the left edge of the box\n * @param y1 the top edge of the box\n * @param x2 the right edge of the box\n * @param y2 the bottom edge of the box\n * @returns lines\n * @private\n */\nfunction clipLine(lines: Array<Array<Point>>, x1: number, y1: number, x2: number, y2: number): Array<Array<Point>> {\n    const clippedLines = [];\n\n    for (let l = 0; l < lines.length; l++) {\n        const line = lines[l];\n        let clippedLine;\n\n        for (let i = 0; i < line.length - 1; i++) {\n            let p0 = line[i];\n            let p1 = line[i + 1];\n\n\n            if (p0.x < x1 && p1.x < x1) {\n                continue;\n            } else if (p0.x < x1) {\n                p0 = new Point(x1, p0.y + (p1.y - p0.y) * ((x1 - p0.x) / (p1.x - p0.x)))._round();\n            } else if (p1.x < x1) {\n                p1 = new Point(x1, p0.y + (p1.y - p0.y) * ((x1 - p0.x) / (p1.x - p0.x)))._round();\n            }\n\n            if (p0.y < y1 && p1.y < y1) {\n                continue;\n            } else if (p0.y < y1) {\n                p0 = new Point(p0.x + (p1.x - p0.x) * ((y1 - p0.y) / (p1.y - p0.y)), y1)._round();\n            } else if (p1.y < y1) {\n                p1 = new Point(p0.x + (p1.x - p0.x) * ((y1 - p0.y) / (p1.y - p0.y)), y1)._round();\n            }\n\n            if (p0.x >= x2 && p1.x >= x2) {\n                continue;\n            } else if (p0.x >= x2) {\n                p0 = new Point(x2, p0.y + (p1.y - p0.y) * ((x2 - p0.x) / (p1.x - p0.x)))._round();\n            } else if (p1.x >= x2) {\n                p1 = new Point(x2, p0.y + (p1.y - p0.y) * ((x2 - p0.x) / (p1.x - p0.x)))._round();\n            }\n\n            if (p0.y >= y2 && p1.y >= y2) {\n                continue;\n            } else if (p0.y >= y2) {\n                p0 = new Point(p0.x + (p1.x - p0.x) * ((y2 - p0.y) / (p1.y - p0.y)), y2)._round();\n            } else if (p1.y >= y2) {\n                p1 = new Point(p0.x + (p1.x - p0.x) * ((y2 - p0.y) / (p1.y - p0.y)), y2)._round();\n            }\n\n            if (!clippedLine || !p0.equals(clippedLine[clippedLine.length - 1])) {\n                clippedLine = [p0];\n                clippedLines.push(clippedLine);\n            }\n\n            clippedLine.push(p1);\n        }\n    }\n\n    return clippedLines;\n}\n","// @flow\n\nimport { AlphaImage } from '../util/image';\nimport { register } from '../util/web_worker_transfer';\nimport potpack from 'potpack';\n\nimport type {GlyphMetrics, StyleGlyph} from '../style/style_glyph';\n\nconst padding = 1;\n\ntype Rect = {\n    x: number,\n    y: number,\n    w: number,\n    h: number\n};\n\nexport type GlyphPosition = {\n    rect: Rect,\n    metrics: GlyphMetrics\n};\n\nexport type GlyphPositions = { [string]: { [number]: GlyphPosition } }\n\nexport default class GlyphAtlas {\n    image: AlphaImage;\n    positions: GlyphPositions;\n\n    constructor(stacks: { [string]: { [number]: ?StyleGlyph } }) {\n        const positions = {};\n        const bins = [];\n\n        for (const stack in stacks) {\n            const glyphs = stacks[stack];\n            const stackPositions = positions[stack] = {};\n\n            for (const id in glyphs) {\n                const src = glyphs[+id];\n                if (!src || src.bitmap.width === 0 || src.bitmap.height === 0) continue;\n\n                const bin = {\n                    x: 0,\n                    y: 0,\n                    w: src.bitmap.width + 2 * padding,\n                    h: src.bitmap.height + 2 * padding\n                };\n                bins.push(bin);\n                stackPositions[id] = {rect: bin, metrics: src.metrics};\n            }\n        }\n\n        const {w, h} = potpack(bins);\n        const image = new AlphaImage({width: w || 1, height: h || 1});\n\n        for (const stack in stacks) {\n            const glyphs = stacks[stack];\n\n            for (const id in glyphs) {\n                const src = glyphs[+id];\n                if (!src || src.bitmap.width === 0 || src.bitmap.height === 0) continue;\n                const bin = positions[stack][id].rect;\n                AlphaImage.copy(src.bitmap, image, {x: 0, y: 0}, {x: bin.x + padding, y: bin.y + padding}, src.bitmap);\n            }\n        }\n\n        this.image = image;\n        this.positions = positions;\n    }\n}\n\nregister('GlyphAtlas', GlyphAtlas);\n","// @flow\n\nimport FeatureIndex from '../data/feature_index';\n\nimport { performSymbolLayout } from '../symbol/symbol_layout';\nimport { CollisionBoxArray } from '../data/array_types';\nimport DictionaryCoder from '../util/dictionary_coder';\nimport SymbolBucket from '../data/bucket/symbol_bucket';\nimport LineBucket from '../data/bucket/line_bucket';\nimport FillBucket from '../data/bucket/fill_bucket';\nimport FillExtrusionBucket from '../data/bucket/fill_extrusion_bucket';\nimport { warnOnce, mapObject, values } from '../util/util';\nimport assert from 'assert';\nimport ImageAtlas from '../render/image_atlas';\nimport GlyphAtlas from '../render/glyph_atlas';\nimport EvaluationParameters from '../style/evaluation_parameters';\nimport { OverscaledTileID } from './tile_id';\n\nimport type {Bucket} from '../data/bucket';\nimport type Actor from '../util/actor';\nimport type StyleLayer from '../style/style_layer';\nimport type StyleLayerIndex from '../style/style_layer_index';\nimport type {StyleImage} from '../style/style_image';\nimport type {StyleGlyph} from '../style/style_glyph';\nimport type {\n    WorkerTileParameters,\n    WorkerTileCallback,\n} from '../source/worker_source';\n\nclass WorkerTile {\n    tileID: OverscaledTileID;\n    uid: string;\n    zoom: number;\n    pixelRatio: number;\n    tileSize: number;\n    source: string;\n    overscaling: number;\n    showCollisionBoxes: boolean;\n    collectResourceTiming: boolean;\n    returnDependencies: boolean;\n\n    status: 'parsing' | 'done';\n    data: VectorTile;\n    collisionBoxArray: CollisionBoxArray;\n\n    abort: ?() => void;\n    reloadCallback: WorkerTileCallback;\n    vectorTile: VectorTile;\n\n    constructor(params: WorkerTileParameters) {\n        this.tileID = new OverscaledTileID(params.tileID.overscaledZ, params.tileID.wrap, params.tileID.canonical.z, params.tileID.canonical.x, params.tileID.canonical.y);\n        this.uid = params.uid;\n        this.zoom = params.zoom;\n        this.pixelRatio = params.pixelRatio;\n        this.tileSize = params.tileSize;\n        this.source = params.source;\n        this.overscaling = this.tileID.overscaleFactor();\n        this.showCollisionBoxes = params.showCollisionBoxes;\n        this.collectResourceTiming = !!params.collectResourceTiming;\n        this.returnDependencies = !!params.returnDependencies;\n    }\n\n    parse(data: VectorTile, layerIndex: StyleLayerIndex, actor: Actor, callback: WorkerTileCallback) {\n        this.status = 'parsing';\n        this.data = data;\n\n        this.collisionBoxArray = new CollisionBoxArray();\n        const sourceLayerCoder = new DictionaryCoder(Object.keys(data.layers).sort());\n\n        const featureIndex = new FeatureIndex(this.tileID);\n        featureIndex.bucketLayerIDs = [];\n\n        const buckets: {[string]: Bucket} = {};\n\n        const options = {\n            featureIndex,\n            iconDependencies: {},\n            patternDependencies: {},\n            glyphDependencies: {}\n        };\n\n        const layerFamilies = layerIndex.familiesBySource[this.source];\n        for (const sourceLayerId in layerFamilies) {\n            const sourceLayer = data.layers[sourceLayerId];\n            if (!sourceLayer) {\n                continue;\n            }\n\n            if (sourceLayer.version === 1) {\n                warnOnce(`Vector tile source \"${this.source}\" layer \"${sourceLayerId}\" ` +\n                    `does not use vector tile spec v2 and therefore may have some rendering errors.`);\n            }\n\n            const sourceLayerIndex = sourceLayerCoder.encode(sourceLayerId);\n            const features = [];\n            for (let index = 0; index < sourceLayer.length; index++) {\n                const feature = sourceLayer.feature(index);\n                features.push({ feature, index, sourceLayerIndex });\n            }\n\n            for (const family of layerFamilies[sourceLayerId]) {\n                const layer = family[0];\n\n                assert(layer.source === this.source);\n                if (layer.minzoom && this.zoom < Math.floor(layer.minzoom)) continue;\n                if (layer.maxzoom && this.zoom >= layer.maxzoom) continue;\n                if (layer.visibility === 'none') continue;\n\n                recalculateLayers(family, this.zoom);\n\n                const bucket = buckets[layer.id] = layer.createBucket({\n                    index: featureIndex.bucketLayerIDs.length,\n                    layers: family,\n                    zoom: this.zoom,\n                    pixelRatio: this.pixelRatio,\n                    overscaling: this.overscaling,\n                    collisionBoxArray: this.collisionBoxArray,\n                    sourceLayerIndex,\n                    sourceID: this.source\n                });\n\n                bucket.populate(features, options);\n                featureIndex.bucketLayerIDs.push(family.map((l) => l.id));\n            }\n        }\n\n        let error: ?Error;\n        let glyphMap: ?{[string]: {[number]: ?StyleGlyph}};\n        let iconMap: ?{[string]: StyleImage};\n        let patternMap: ?{[string]: StyleImage};\n\n        const stacks = mapObject(options.glyphDependencies, (glyphs) => Object.keys(glyphs).map(Number));\n        if (Object.keys(stacks).length) {\n            actor.send('getGlyphs', {uid: this.uid, stacks}, (err, result) => {\n                if (!error) {\n                    error = err;\n                    glyphMap = result;\n                    maybePrepare.call(this);\n                }\n            });\n        } else {\n            glyphMap = {};\n        }\n\n        const icons = Object.keys(options.iconDependencies);\n        if (icons.length) {\n            actor.send('getImages', {icons}, (err, result) => {\n                if (!error) {\n                    error = err;\n                    iconMap = result;\n                    maybePrepare.call(this);\n                }\n            });\n        } else {\n            iconMap = {};\n        }\n\n        const patterns = Object.keys(options.patternDependencies);\n        if (patterns.length) {\n            actor.send('getImages', {icons: patterns}, (err, result) => {\n                if (!error) {\n                    error = err;\n                    patternMap = result;\n                    maybePrepare.call(this);\n                }\n            });\n        } else {\n            patternMap = {};\n        }\n\n\n        maybePrepare.call(this);\n\n        function maybePrepare() {\n            if (error) {\n                return callback(error);\n            } else if (glyphMap && iconMap && patternMap) {\n                const glyphAtlas = new GlyphAtlas(glyphMap);\n                const imageAtlas = new ImageAtlas(iconMap, patternMap);\n\n                for (const key in buckets) {\n                    const bucket = buckets[key];\n                    if (bucket instanceof SymbolBucket) {\n                        recalculateLayers(bucket.layers, this.zoom);\n                        performSymbolLayout(bucket, glyphMap, glyphAtlas.positions, iconMap, imageAtlas.iconPositions, this.showCollisionBoxes);\n                    } else if (bucket.hasPattern &&\n                        (bucket instanceof LineBucket ||\n                         bucket instanceof FillBucket ||\n                         bucket instanceof FillExtrusionBucket)) {\n                        recalculateLayers(bucket.layers, this.zoom);\n                        bucket.addFeatures(options, imageAtlas.patternPositions);\n                    }\n                }\n\n                this.status = 'done';\n                callback(null, {\n                    buckets: values(buckets).filter(b => !b.isEmpty()),\n                    featureIndex,\n                    collisionBoxArray: this.collisionBoxArray,\n                    glyphAtlasImage: glyphAtlas.image,\n                    imageAtlas,\n                    // Only used for benchmarking:\n                    glyphMap: this.returnDependencies ? glyphMap : null,\n                    iconMap: this.returnDependencies ? iconMap : null,\n                    glyphPositions: this.returnDependencies ? glyphAtlas.positions : null\n                });\n            }\n        }\n    }\n}\n\nfunction recalculateLayers(layers: $ReadOnlyArray<StyleLayer>, zoom: number) {\n    // Layers are shared and may have been used by a WorkerTile with a different zoom.\n    const parameters = new EvaluationParameters(zoom);\n    for (const layer of layers) {\n        layer.recalculate(parameters);\n    }\n}\n\nexport default WorkerTile;\n","// @flow\n\nimport type {RequestParameters} from '../util/ajax';\n\n// Wraps performance to facilitate testing\n// Not incorporated into browser.js because the latter is poisonous when used outside the main thread\nconst performanceExists = typeof performance !== 'undefined';\nconst wrapper = {};\n\nwrapper.getEntriesByName = (url: string) => {\n    if (performanceExists && performance && performance.getEntriesByName)\n        return performance.getEntriesByName(url);\n    else\n        return false;\n};\n\nwrapper.mark = (name: string) => {\n    if (performanceExists && performance && performance.mark)\n        return performance.mark(name);\n    else\n        return false;\n};\n\nwrapper.measure = (name: string, startMark: string, endMark: string) => {\n    if (performanceExists && performance && performance.measure)\n        return performance.measure(name, startMark, endMark);\n    else\n        return false;\n};\n\nwrapper.clearMarks = (name: string) => {\n    if (performanceExists && performance && performance.clearMarks)\n        return performance.clearMarks(name);\n    else\n        return false;\n};\n\nwrapper.clearMeasures = (name: string) => {\n    if (performanceExists && performance && performance.clearMeasures)\n        return performance.clearMeasures(name);\n    else\n        return false;\n};\n\n/**\n * Safe wrapper for the performance resource timing API in web workers with graceful degradation\n *\n * @param {RequestParameters} request\n * @private\n */\nclass Performance {\n    _marks: {start: string, end: string, measure: string};\n\n    constructor (request: RequestParameters) {\n        this._marks = {\n            start: [request.url, 'start'].join('#'),\n            end: [request.url, 'end'].join('#'),\n            measure: request.url.toString()\n        };\n\n        wrapper.mark(this._marks.start);\n    }\n\n    finish() {\n        wrapper.mark(this._marks.end);\n        let resourceTimingData = wrapper.getEntriesByName(this._marks.measure);\n\n        // fallback if web worker implementation of perf.getEntriesByName returns empty\n        if (resourceTimingData.length === 0) {\n            wrapper.measure(this._marks.measure, this._marks.start, this._marks.end);\n            resourceTimingData = wrapper.getEntriesByName(this._marks.measure);\n\n            // cleanup\n            wrapper.clearMarks(this._marks.start);\n            wrapper.clearMarks(this._marks.end);\n            wrapper.clearMeasures(this._marks.measure);\n        }\n\n        return resourceTimingData;\n    }\n}\n\nwrapper.Performance = Performance;\n\nexport default wrapper;\n","// @flow\n\nimport { getArrayBuffer } from '../util/ajax';\n\nimport vt from '@mapbox/vector-tile';\nimport Protobuf from 'pbf';\nimport WorkerTile from './worker_tile';\nimport { extend } from '../util/util';\nimport performance from '../util/performance';\n\nimport type {\n    WorkerSource,\n    WorkerTileParameters,\n    WorkerTileCallback,\n    TileParameters\n} from '../source/worker_source';\n\nimport type {PerformanceResourceTiming} from '../types/performance_resource_timing';\nimport type Actor from '../util/actor';\nimport type StyleLayerIndex from '../style/style_layer_index';\nimport type {Callback} from '../types/callback';\n\nexport type LoadVectorTileResult = {\n    vectorTile: VectorTile;\n    rawData: ArrayBuffer;\n    expires?: any;\n    cacheControl?: any;\n    resourceTiming?: Array<PerformanceResourceTiming>;\n};\n\n/**\n * @callback LoadVectorDataCallback\n * @param error\n * @param vectorTile\n * @private\n */\nexport type LoadVectorDataCallback = Callback<?LoadVectorTileResult>;\n\nexport type AbortVectorData = () => void;\nexport type LoadVectorData = (params: WorkerTileParameters, callback: LoadVectorDataCallback) => ?AbortVectorData;\n\n/**\n * @private\n */\nfunction loadVectorTile(params: WorkerTileParameters, callback: LoadVectorDataCallback) {\n    const request = getArrayBuffer(params.request, (err: ?Error, data: ?ArrayBuffer, cacheControl: ?string, expires: ?string) => {\n        if (err) {\n            callback(err);\n        } else if (data) {\n            callback(null, {\n                vectorTile: new vt.VectorTile(new Protobuf(data)),\n                rawData: data,\n                cacheControl,\n                expires\n            });\n        }\n    });\n    return () => {\n        request.cancel();\n        callback();\n    };\n}\n\n/**\n * The {@link WorkerSource} implementation that supports {@link VectorTileSource}.\n * This class is designed to be easily reused to support custom source types\n * for data formats that can be parsed/converted into an in-memory VectorTile\n * representation.  To do so, create it with\n * `new VectorTileWorkerSource(actor, styleLayers, customLoadVectorDataFunction)`.\n *\n * @private\n */\nclass VectorTileWorkerSource implements WorkerSource {\n    actor: Actor;\n    layerIndex: StyleLayerIndex;\n    loadVectorData: LoadVectorData;\n    loading: { [string]: WorkerTile };\n    loaded: { [string]: WorkerTile };\n\n    /**\n     * @param [loadVectorData] Optional method for custom loading of a VectorTile\n     * object based on parameters passed from the main-thread Source. See\n     * {@link VectorTileWorkerSource#loadTile}. The default implementation simply\n     * loads the pbf at `params.url`.\n     */\n    constructor(actor: Actor, layerIndex: StyleLayerIndex, loadVectorData: ?LoadVectorData) {\n        this.actor = actor;\n        this.layerIndex = layerIndex;\n        this.loadVectorData = loadVectorData || loadVectorTile;\n        this.loading = {};\n        this.loaded = {};\n    }\n\n    /**\n     * Implements {@link WorkerSource#loadTile}. Delegates to\n     * {@link VectorTileWorkerSource#loadVectorData} (which by default expects\n     * a `params.url` property) for fetching and producing a VectorTile object.\n     */\n    loadTile(params: WorkerTileParameters, callback: WorkerTileCallback) {\n        const uid = params.uid;\n\n        if (!this.loading)\n            this.loading = {};\n\n        const perf = (params && params.request && params.request.collectResourceTiming) ?\n            new performance.Performance(params.request) : false;\n\n        const workerTile = this.loading[uid] = new WorkerTile(params);\n        workerTile.abort = this.loadVectorData(params, (err, response) => {\n            delete this.loading[uid];\n\n            if (err || !response) {\n                workerTile.status = 'done';\n                this.loaded[uid] = workerTile;\n                return callback(err);\n            }\n\n            const rawTileData = response.rawData;\n            const cacheControl = {};\n            if (response.expires) cacheControl.expires = response.expires;\n            if (response.cacheControl) cacheControl.cacheControl = response.cacheControl;\n\n            const resourceTiming = {};\n            if (perf) {\n                const resourceTimingData = perf.finish();\n                // it's necessary to eval the result of getEntriesByName() here via parse/stringify\n                // late evaluation in the main thread causes TypeError: illegal invocation\n                if (resourceTimingData)\n                    resourceTiming.resourceTiming = JSON.parse(JSON.stringify(resourceTimingData));\n            }\n\n            workerTile.vectorTile = response.vectorTile;\n            workerTile.parse(response.vectorTile, this.layerIndex, this.actor, (err, result) => {\n                if (err || !result) return callback(err);\n\n                // Transferring a copy of rawTileData because the worker needs to retain its copy.\n                callback(null, extend({rawTileData: rawTileData.slice(0)}, result, cacheControl, resourceTiming));\n            });\n\n            this.loaded = this.loaded || {};\n            this.loaded[uid] = workerTile;\n        });\n    }\n\n    /**\n     * Implements {@link WorkerSource#reloadTile}.\n     */\n    reloadTile(params: WorkerTileParameters, callback: WorkerTileCallback) {\n        const loaded = this.loaded,\n            uid = params.uid,\n            vtSource = this;\n        if (loaded && loaded[uid]) {\n            const workerTile = loaded[uid];\n            workerTile.showCollisionBoxes = params.showCollisionBoxes;\n\n            const done = (err, data) => {\n                const reloadCallback = workerTile.reloadCallback;\n                if (reloadCallback) {\n                    delete workerTile.reloadCallback;\n                    workerTile.parse(workerTile.vectorTile, vtSource.layerIndex, vtSource.actor, reloadCallback);\n                }\n                callback(err, data);\n            };\n\n            if (workerTile.status === 'parsing') {\n                workerTile.reloadCallback = done;\n            } else if (workerTile.status === 'done') {\n                // if there was no vector tile data on the initial load, don't try and re-parse tile\n                if (workerTile.vectorTile) {\n                    workerTile.parse(workerTile.vectorTile, this.layerIndex, this.actor, done);\n                } else {\n                    done();\n                }\n            }\n        }\n    }\n\n    /**\n     * Implements {@link WorkerSource#abortTile}.\n     *\n     * @param params\n     * @param params.uid The UID for this tile.\n     */\n    abortTile(params: TileParameters, callback: WorkerTileCallback) {\n        const loading = this.loading,\n            uid = params.uid;\n        if (loading && loading[uid] && loading[uid].abort) {\n            loading[uid].abort();\n            delete loading[uid];\n        }\n        callback();\n    }\n\n    /**\n     * Implements {@link WorkerSource#removeTile}.\n     *\n     * @param params\n     * @param params.uid The UID for this tile.\n     */\n    removeTile(params: TileParameters, callback: WorkerTileCallback) {\n        const loaded = this.loaded,\n            uid = params.uid;\n        if (loaded && loaded[uid]) {\n            delete loaded[uid];\n        }\n        callback();\n    }\n}\n\nexport default VectorTileWorkerSource;\n","// @flow\n\nimport DEMData from '../data/dem_data';\n\nimport type Actor from '../util/actor';\nimport type {\n    WorkerDEMTileParameters,\n    WorkerDEMTileCallback,\n    TileParameters\n} from './worker_source';\n\n\nclass RasterDEMTileWorkerSource {\n    actor: Actor;\n    loaded: {[string]: DEMData};\n\n    constructor() {\n        this.loaded = {};\n    }\n\n    loadTile(params: WorkerDEMTileParameters, callback: WorkerDEMTileCallback) {\n        const {uid, encoding, rawImageData} = params;\n        const dem = new DEMData(uid, rawImageData, encoding);\n\n        this.loaded = this.loaded || {};\n        this.loaded[uid] = dem;\n        callback(null, dem);\n    }\n\n    removeTile(params: TileParameters) {\n        const loaded = this.loaded,\n            uid = params.uid;\n        if (loaded && loaded[uid]) {\n            delete loaded[uid];\n        }\n    }\n}\n\nexport default RasterDEMTileWorkerSource;\n","module.exports.RADIUS = 6378137;\nmodule.exports.FLATTENING = 1/298.257223563;\nmodule.exports.POLAR_RADIUS = 6356752.3142;\n","var wgs84 = require('wgs84');\n\nmodule.exports.geometry = geometry;\nmodule.exports.ring = ringArea;\n\nfunction geometry(_) {\n    var area = 0, i;\n    switch (_.type) {\n        case 'Polygon':\n            return polygonArea(_.coordinates);\n        case 'MultiPolygon':\n            for (i = 0; i < _.coordinates.length; i++) {\n                area += polygonArea(_.coordinates[i]);\n            }\n            return area;\n        case 'Point':\n        case 'MultiPoint':\n        case 'LineString':\n        case 'MultiLineString':\n            return 0;\n        case 'GeometryCollection':\n            for (i = 0; i < _.geometries.length; i++) {\n                area += geometry(_.geometries[i]);\n            }\n            return area;\n    }\n}\n\nfunction polygonArea(coords) {\n    var area = 0;\n    if (coords && coords.length > 0) {\n        area += Math.abs(ringArea(coords[0]));\n        for (var i = 1; i < coords.length; i++) {\n            area -= Math.abs(ringArea(coords[i]));\n        }\n    }\n    return area;\n}\n\n/**\n * Calculate the approximate area of the polygon were it projected onto\n *     the earth.  Note that this area will be positive if ring is oriented\n *     clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n *     Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\n *\n * Returns:\n * {float} The approximate signed geodesic area of the polygon in square\n *     meters.\n */\n\nfunction ringArea(coords) {\n    var p1, p2, p3, lowerIndex, middleIndex, upperIndex, i,\n    area = 0,\n    coordsLength = coords.length;\n\n    if (coordsLength > 2) {\n        for (i = 0; i < coordsLength; i++) {\n            if (i === coordsLength - 2) {// i = N-2\n                lowerIndex = coordsLength - 2;\n                middleIndex = coordsLength -1;\n                upperIndex = 0;\n            } else if (i === coordsLength - 1) {// i = N-1\n                lowerIndex = coordsLength - 1;\n                middleIndex = 0;\n                upperIndex = 1;\n            } else { // i = 0 to N-3\n                lowerIndex = i;\n                middleIndex = i+1;\n                upperIndex = i+2;\n            }\n            p1 = coords[lowerIndex];\n            p2 = coords[middleIndex];\n            p3 = coords[upperIndex];\n            area += ( rad(p3[0]) - rad(p1[0]) ) * Math.sin( rad(p2[1]));\n        }\n\n        area = area * wgs84.RADIUS * wgs84.RADIUS / 2;\n    }\n\n    return area;\n}\n\nfunction rad(_) {\n    return _ * Math.PI / 180;\n}","var geojsonArea = require('@mapbox/geojson-area');\n\nmodule.exports = rewind;\n\nfunction rewind(gj, outer) {\n    switch ((gj && gj.type) || null) {\n        case 'FeatureCollection':\n            gj.features = gj.features.map(curryOuter(rewind, outer));\n            return gj;\n        case 'GeometryCollection':\n            gj.geometries = gj.geometries.map(curryOuter(rewind, outer));\n            return gj;\n        case 'Feature':\n            gj.geometry = rewind(gj.geometry, outer);\n            return gj;\n        case 'Polygon':\n        case 'MultiPolygon':\n            return correct(gj, outer);\n        default:\n            return gj;\n    }\n}\n\nfunction curryOuter(a, b) {\n    return function(_) { return a(_, b); };\n}\n\nfunction correct(_, outer) {\n    if (_.type === 'Polygon') {\n        _.coordinates = correctRings(_.coordinates, outer);\n    } else if (_.type === 'MultiPolygon') {\n        _.coordinates = _.coordinates.map(curryOuter(correctRings, outer));\n    }\n    return _;\n}\n\nfunction correctRings(_, outer) {\n    outer = !!outer;\n    _[0] = wind(_[0], outer);\n    for (var i = 1; i < _.length; i++) {\n        _[i] = wind(_[i], !outer);\n    }\n    return _;\n}\n\nfunction wind(_, dir) {\n    return cw(_) === dir ? _ : _.reverse();\n}\n\nfunction cw(_) {\n    return geojsonArea.ring(_) >= 0;\n}\n","// @flow\n\nimport Point from '@mapbox/point-geometry';\n\nimport mvt from '@mapbox/vector-tile';\nconst toGeoJSON = mvt.VectorTileFeature.prototype.toGeoJSON;\nimport EXTENT from '../data/extent';\n\n// The feature type used by geojson-vt and supercluster. Should be extracted to\n// global type and used in module definitions for those two modules.\ntype Feature = {\n    type: 1,\n    id: mixed,\n    tags: {[string]: string | number | boolean},\n    geometry: Array<[number, number]>,\n} | {\n    type: 2 | 3,\n    id: mixed,\n    tags: {[string]: string | number | boolean},\n    geometry: Array<Array<[number, number]>>,\n}\n\nclass FeatureWrapper implements VectorTileFeature {\n    _feature: Feature;\n\n    extent: number;\n    type: 1 | 2 | 3;\n    id: number;\n    properties: {[string]: string | number | boolean};\n\n    constructor(feature: Feature) {\n        this._feature = feature;\n\n        this.extent = EXTENT;\n        this.type = feature.type;\n        this.properties = feature.tags;\n\n        // If the feature has a top-level `id` property, copy it over, but only\n        // if it can be coerced to an integer, because this wrapper is used for\n        // serializing geojson feature data into vector tile PBF data, and the\n        // vector tile spec only supports integer values for feature ids --\n        // allowing non-integer values here results in a non-compliant PBF\n        // that causes an exception when it is parsed with vector-tile-js\n        if ('id' in feature && !isNaN(feature.id)) {\n            this.id = parseInt(feature.id, 10);\n        }\n    }\n\n    loadGeometry() {\n        if (this._feature.type === 1) {\n            const geometry = [];\n            for (const point of this._feature.geometry) {\n                geometry.push([new Point(point[0], point[1])]);\n            }\n            return geometry;\n        } else {\n            const geometry = [];\n            for (const ring of this._feature.geometry) {\n                const newRing = [];\n                for (const point of ring) {\n                    newRing.push(new Point(point[0], point[1]));\n                }\n                geometry.push(newRing);\n            }\n            return geometry;\n        }\n    }\n\n    toGeoJSON(x: number, y: number, z: number) {\n        return toGeoJSON.call(this, x, y, z);\n    }\n}\n\nclass GeoJSONWrapper implements VectorTile, VectorTileLayer {\n    layers: {[string]: VectorTileLayer};\n    name: string;\n    extent: number;\n    length: number;\n    _features: Array<Feature>;\n\n    constructor(features: Array<Feature>) {\n        this.layers = { '_geojsonTileLayer': this };\n        this.name = '_geojsonTileLayer';\n        this.extent = EXTENT;\n        this.length = features.length;\n        this._features = features;\n    }\n\n    feature(i: number): VectorTileFeature {\n        return new FeatureWrapper(this._features[i]);\n    }\n}\n\nexport default GeoJSONWrapper;\n","'use strict'\n\nvar Point = require('@mapbox/point-geometry')\nvar VectorTileFeature = require('@mapbox/vector-tile').VectorTileFeature\n\nmodule.exports = GeoJSONWrapper\n\n// conform to vectortile api\nfunction GeoJSONWrapper (features, options) {\n  this.options = options || {}\n  this.features = features\n  this.length = features.length\n}\n\nGeoJSONWrapper.prototype.feature = function (i) {\n  return new FeatureWrapper(this.features[i], this.options.extent)\n}\n\nfunction FeatureWrapper (feature, extent) {\n  this.id = typeof feature.id === 'number' ? feature.id : undefined\n  this.type = feature.type\n  this.rawGeometry = feature.type === 1 ? [feature.geometry] : feature.geometry\n  this.properties = feature.tags\n  this.extent = extent || 4096\n}\n\nFeatureWrapper.prototype.loadGeometry = function () {\n  var rings = this.rawGeometry\n  this.geometry = []\n\n  for (var i = 0; i < rings.length; i++) {\n    var ring = rings[i]\n    var newRing = []\n    for (var j = 0; j < ring.length; j++) {\n      newRing.push(new Point(ring[j][0], ring[j][1]))\n    }\n    this.geometry.push(newRing)\n  }\n  return this.geometry\n}\n\nFeatureWrapper.prototype.bbox = function () {\n  if (!this.geometry) this.loadGeometry()\n\n  var rings = this.geometry\n  var x1 = Infinity\n  var x2 = -Infinity\n  var y1 = Infinity\n  var y2 = -Infinity\n\n  for (var i = 0; i < rings.length; i++) {\n    var ring = rings[i]\n\n    for (var j = 0; j < ring.length; j++) {\n      var coord = ring[j]\n\n      x1 = Math.min(x1, coord.x)\n      x2 = Math.max(x2, coord.x)\n      y1 = Math.min(y1, coord.y)\n      y2 = Math.max(y2, coord.y)\n    }\n  }\n\n  return [x1, y1, x2, y2]\n}\n\nFeatureWrapper.prototype.toGeoJSON = VectorTileFeature.prototype.toGeoJSON\n","var Pbf = require('pbf')\nvar GeoJSONWrapper = require('./lib/geojson_wrapper')\n\nmodule.exports = fromVectorTileJs\nmodule.exports.fromVectorTileJs = fromVectorTileJs\nmodule.exports.fromGeojsonVt = fromGeojsonVt\nmodule.exports.GeoJSONWrapper = GeoJSONWrapper\n\n/**\n * Serialize a vector-tile-js-created tile to pbf\n *\n * @param {Object} tile\n * @return {Buffer} uncompressed, pbf-serialized tile data\n */\nfunction fromVectorTileJs (tile) {\n  var out = new Pbf()\n  writeTile(tile, out)\n  return out.finish()\n}\n\n/**\n * Serialized a geojson-vt-created tile to pbf.\n *\n * @param {Object} layers - An object mapping layer names to geojson-vt-created vector tile objects\n * @param {Object} [options] - An object specifying the vector-tile specification version and extent that were used to create `layers`.\n * @param {Number} [options.version=1] - Version of vector-tile spec used\n * @param {Number} [options.extent=4096] - Extent of the vector tile\n * @return {Buffer} uncompressed, pbf-serialized tile data\n */\nfunction fromGeojsonVt (layers, options) {\n  options = options || {}\n  var l = {}\n  for (var k in layers) {\n    l[k] = new GeoJSONWrapper(layers[k].features, options)\n    l[k].name = k\n    l[k].version = options.version\n    l[k].extent = options.extent\n  }\n  return fromVectorTileJs({layers: l})\n}\n\nfunction writeTile (tile, pbf) {\n  for (var key in tile.layers) {\n    pbf.writeMessage(3, writeLayer, tile.layers[key])\n  }\n}\n\nfunction writeLayer (layer, pbf) {\n  pbf.writeVarintField(15, layer.version || 1)\n  pbf.writeStringField(1, layer.name || '')\n  pbf.writeVarintField(5, layer.extent || 4096)\n\n  var i\n  var context = {\n    keys: [],\n    values: [],\n    keycache: {},\n    valuecache: {}\n  }\n\n  for (i = 0; i < layer.length; i++) {\n    context.feature = layer.feature(i)\n    pbf.writeMessage(2, writeFeature, context)\n  }\n\n  var keys = context.keys\n  for (i = 0; i < keys.length; i++) {\n    pbf.writeStringField(3, keys[i])\n  }\n\n  var values = context.values\n  for (i = 0; i < values.length; i++) {\n    pbf.writeMessage(4, writeValue, values[i])\n  }\n}\n\nfunction writeFeature (context, pbf) {\n  var feature = context.feature\n\n  if (feature.id !== undefined) {\n    pbf.writeVarintField(1, feature.id)\n  }\n\n  pbf.writeMessage(2, writeProperties, context)\n  pbf.writeVarintField(3, feature.type)\n  pbf.writeMessage(4, writeGeometry, feature)\n}\n\nfunction writeProperties (context, pbf) {\n  var feature = context.feature\n  var keys = context.keys\n  var values = context.values\n  var keycache = context.keycache\n  var valuecache = context.valuecache\n\n  for (var key in feature.properties) {\n    var keyIndex = keycache[key]\n    if (typeof keyIndex === 'undefined') {\n      keys.push(key)\n      keyIndex = keys.length - 1\n      keycache[key] = keyIndex\n    }\n    pbf.writeVarint(keyIndex)\n\n    var value = feature.properties[key]\n    var type = typeof value\n    if (type !== 'string' && type !== 'boolean' && type !== 'number') {\n      value = JSON.stringify(value)\n    }\n    var valueKey = type + ':' + value\n    var valueIndex = valuecache[valueKey]\n    if (typeof valueIndex === 'undefined') {\n      values.push(value)\n      valueIndex = values.length - 1\n      valuecache[valueKey] = valueIndex\n    }\n    pbf.writeVarint(valueIndex)\n  }\n}\n\nfunction command (cmd, length) {\n  return (length << 3) + (cmd & 0x7)\n}\n\nfunction zigzag (num) {\n  return (num << 1) ^ (num >> 31)\n}\n\nfunction writeGeometry (feature, pbf) {\n  var geometry = feature.loadGeometry()\n  var type = feature.type\n  var x = 0\n  var y = 0\n  var rings = geometry.length\n  for (var r = 0; r < rings; r++) {\n    var ring = geometry[r]\n    var count = 1\n    if (type === 1) {\n      count = ring.length\n    }\n    pbf.writeVarint(command(1, count)) // moveto\n    // do not write polygon closing path as lineto\n    var lineCount = type === 3 ? ring.length - 1 : ring.length\n    for (var i = 0; i < lineCount; i++) {\n      if (i === 1 && type !== 1) {\n        pbf.writeVarint(command(2, lineCount - 1)) // lineto\n      }\n      var dx = ring[i].x - x\n      var dy = ring[i].y - y\n      pbf.writeVarint(zigzag(dx))\n      pbf.writeVarint(zigzag(dy))\n      x += dx\n      y += dy\n    }\n    if (type === 3) {\n      pbf.writeVarint(command(7, 1)) // closepath\n    }\n  }\n}\n\nfunction writeValue (value, pbf) {\n  var type = typeof value\n  if (type === 'string') {\n    pbf.writeStringField(1, value)\n  } else if (type === 'boolean') {\n    pbf.writeBooleanField(7, value)\n  } else if (type === 'number') {\n    if (value % 1 !== 0) {\n      pbf.writeDoubleField(3, value)\n    } else if (value < 0) {\n      pbf.writeSVarintField(6, value)\n    } else {\n      pbf.writeVarintField(5, value)\n    }\n  }\n}\n","// @flow\n\nimport { create as createSource } from './source';\n\nimport Tile from './tile';\nimport { Event, ErrorEvent, Evented } from '../util/evented';\nimport TileCache from './tile_cache';\nimport MercatorCoordinate from '../geo/mercator_coordinate';\nimport { keysDifference } from '../util/util';\nimport EXTENT from '../data/extent';\nimport Context from '../gl/context';\nimport Point from '@mapbox/point-geometry';\nimport browser from '../util/browser';\nimport { OverscaledTileID } from './tile_id';\nimport assert from 'assert';\nimport SourceFeatureState from './source_state';\n\nimport type {Source} from './source';\nimport type Map from '../ui/map';\nimport type Style from '../style/style';\nimport type Dispatcher from '../util/dispatcher';\nimport type Transform from '../geo/transform';\nimport type {TileState} from './tile';\nimport type {Callback} from '../types/callback';\nimport type {SourceSpecification} from '../style-spec/types';\n\n/**\n * `SourceCache` is responsible for\n *\n *  - creating an instance of `Source`\n *  - forwarding events from `Source`\n *  - caching tiles loaded from an instance of `Source`\n *  - loading the tiles needed to render a given viewport\n *  - unloading the cached tiles not needed to render a given viewport\n *\n * @private\n */\nclass SourceCache extends Evented {\n    id: string;\n    dispatcher: Dispatcher;\n    map: Map;\n    style: Style;\n\n    _source: Source;\n    _sourceLoaded: boolean;\n    _sourceErrored: boolean;\n    _tiles: {[any]: Tile};\n    _prevLng: number | void;\n    _cache: TileCache;\n    _timers: {[any]: TimeoutID};\n    _cacheTimers: {[any]: TimeoutID};\n    _maxTileCacheSize: ?number;\n    _paused: boolean;\n    _shouldReloadOnResume: boolean;\n    _coveredTiles: {[any]: boolean};\n    transform: Transform;\n    _isIdRenderable: (id: number, symbolLayer?: boolean) => boolean;\n    used: boolean;\n    _state: SourceFeatureState;\n\n    static maxUnderzooming: number;\n    static maxOverzooming: number;\n\n    constructor(id: string, options: SourceSpecification, dispatcher: Dispatcher) {\n        super();\n        this.id = id;\n        this.dispatcher = dispatcher;\n\n        this.on('data', (e) => {\n            // this._sourceLoaded signifies that the TileJSON is loaded if applicable.\n            // if the source type does not come with a TileJSON, the flag signifies the\n            // source data has loaded (i.e geojson has been tiled on the worker and is ready)\n            if (e.dataType === 'source' && e.sourceDataType === 'metadata') this._sourceLoaded = true;\n\n            // for sources with mutable data, this event fires when the underlying data\n            // to a source is changed. (i.e. GeoJSONSource#setData and ImageSource#serCoordinates)\n            if (this._sourceLoaded && !this._paused && e.dataType === \"source\" && e.sourceDataType === 'content') {\n                this.reload();\n                if (this.transform) {\n                    this.update(this.transform);\n                }\n            }\n        });\n\n        this.on('error', () => {\n            this._sourceErrored = true;\n        });\n\n        this._source = createSource(id, options, dispatcher, this);\n\n        this._tiles = {};\n        this._cache = new TileCache(0, this._unloadTile.bind(this));\n        this._timers = {};\n        this._cacheTimers = {};\n        this._maxTileCacheSize = null;\n\n        this._coveredTiles = {};\n        this._state = new SourceFeatureState();\n    }\n\n    onAdd(map: Map) {\n        this.map = map;\n        this._maxTileCacheSize = map ? map._maxTileCacheSize : null;\n        if (this._source && this._source.onAdd) {\n            this._source.onAdd(map);\n        }\n    }\n\n    onRemove(map: Map) {\n        if (this._source && this._source.onRemove) {\n            this._source.onRemove(map);\n        }\n    }\n\n    /**\n     * Return true if no tile data is pending, tiles will not change unless\n     * an additional API call is received.\n     */\n    loaded(): boolean {\n        if (this._sourceErrored) { return true; }\n        if (!this._sourceLoaded) { return false; }\n        for (const t in this._tiles) {\n            const tile = this._tiles[t];\n            if (tile.state !== 'loaded' && tile.state !== 'errored')\n                return false;\n        }\n        return true;\n    }\n\n    getSource(): Source {\n        return this._source;\n    }\n\n    pause() {\n        this._paused = true;\n    }\n\n    resume() {\n        if (!this._paused) return;\n        const shouldReload = this._shouldReloadOnResume;\n        this._paused = false;\n        this._shouldReloadOnResume = false;\n        if (shouldReload) this.reload();\n        if (this.transform) this.update(this.transform);\n    }\n\n    _loadTile(tile: Tile, callback: Callback<void>) {\n        return this._source.loadTile(tile, callback);\n    }\n\n    _unloadTile(tile: Tile) {\n        if (this._source.unloadTile)\n            return this._source.unloadTile(tile, () => {});\n    }\n\n    _abortTile(tile: Tile) {\n        if (this._source.abortTile)\n            return this._source.abortTile(tile, () => {});\n    }\n\n    serialize() {\n        return this._source.serialize();\n    }\n\n    prepare(context: Context) {\n        if  (this._source.prepare) {\n            this._source.prepare();\n        }\n\n        this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);\n        for (const i in this._tiles) {\n            this._tiles[i].upload(context);\n        }\n    }\n\n    /**\n     * Return all tile ids ordered with z-order, and cast to numbers\n     */\n    getIds(): Array<number> {\n        return Object.keys(this._tiles).map(Number).sort(compareKeyZoom);\n    }\n\n    getRenderableIds(symbolLayer?: boolean): Array<number> {\n        const ids = [];\n        for (const id in this._tiles) {\n            if (this._isIdRenderable(+id, symbolLayer)) ids.push(+id);\n        }\n        if (symbolLayer) {\n            return ids.sort((a_, b_) => {\n                const a = this._tiles[a_].tileID;\n                const b = this._tiles[b_].tileID;\n                const rotatedA = (new Point(a.canonical.x, a.canonical.y))._rotate(this.transform.angle);\n                const rotatedB = (new Point(b.canonical.x, b.canonical.y))._rotate(this.transform.angle);\n                return a.overscaledZ - b.overscaledZ || rotatedB.y - rotatedA.y || rotatedB.x - rotatedA.x;\n            });\n        }\n        return ids.sort(compareKeyZoom);\n    }\n\n    hasRenderableParent(tileID: OverscaledTileID) {\n        const parentTile = this.findLoadedParent(tileID, 0);\n        if (parentTile) {\n            return this._isIdRenderable(parentTile.tileID.key);\n        }\n        return false;\n    }\n\n    _isIdRenderable(id: number, symbolLayer?: boolean) {\n        return this._tiles[id] && this._tiles[id].hasData() &&\n            !this._coveredTiles[id] && (symbolLayer || !this._tiles[id].holdingForFade());\n    }\n\n    reload() {\n        if (this._paused) {\n            this._shouldReloadOnResume = true;\n            return;\n        }\n\n        this._cache.reset();\n\n        for (const i in this._tiles) {\n            if (this._tiles[i].state !== \"errored\") this._reloadTile(i, 'reloading');\n        }\n    }\n\n    _reloadTile(id: string | number, state: TileState) {\n        const tile = this._tiles[id];\n\n        // this potentially does not address all underlying\n        // issues https://github.com/mapbox/mapbox-gl-js/issues/4252\n        // - hard to tell without repro steps\n        if (!tile) return;\n\n        // The difference between \"loading\" tiles and \"reloading\" or \"expired\"\n        // tiles is that \"reloading\"/\"expired\" tiles are \"renderable\".\n        // Therefore, a \"loading\" tile cannot become a \"reloading\" tile without\n        // first becoming a \"loaded\" tile.\n        if (tile.state !== 'loading') {\n            tile.state = state;\n        }\n\n        this._loadTile(tile, this._tileLoaded.bind(this, tile, id, state));\n    }\n\n    _tileLoaded(tile: Tile, id: string | number, previousState: TileState, err: ?Error) {\n        if (err) {\n            tile.state = 'errored';\n            if ((err: any).status !== 404) this._source.fire(new ErrorEvent(err, {tile}));\n            // continue to try loading parent/children tiles if a tile doesn't exist (404)\n            else this.update(this.transform);\n            return;\n        }\n\n        tile.timeAdded = browser.now();\n        if (previousState === 'expired') tile.refreshedUponExpiration = true;\n        this._setTileReloadTimer(id, tile);\n        if (this.getSource().type === 'raster-dem' && tile.dem) this._backfillDEM(tile);\n        this._state.initializeTileState(tile, this.map ? this.map.painter : null);\n\n        this._source.fire(new Event('data', {dataType: 'source', tile, coord: tile.tileID}));\n    }\n\n    /**\n    * For raster terrain source, backfill DEM to eliminate visible tile boundaries\n    * @private\n    */\n    _backfillDEM(tile: Tile) {\n        const renderables = this.getRenderableIds();\n        for (let i = 0; i < renderables.length; i++) {\n            const borderId = renderables[i];\n            if (tile.neighboringTiles && tile.neighboringTiles[borderId]) {\n                const borderTile = this.getTileByID(borderId);\n                fillBorder(tile, borderTile);\n                fillBorder(borderTile, tile);\n            }\n        }\n\n        function fillBorder(tile, borderTile) {\n            tile.needsHillshadePrepare = true;\n            let dx = borderTile.tileID.canonical.x - tile.tileID.canonical.x;\n            const dy = borderTile.tileID.canonical.y - tile.tileID.canonical.y;\n            const dim = Math.pow(2, tile.tileID.canonical.z);\n            const borderId = borderTile.tileID.key;\n            if (dx === 0 && dy === 0) return;\n\n            if (Math.abs(dy) > 1) {\n                return;\n            }\n            if (Math.abs(dx) > 1) {\n                // Adjust the delta coordinate for world wraparound.\n                if (Math.abs(dx + dim) === 1) {\n                    dx += dim;\n                } else if (Math.abs(dx - dim) === 1) {\n                    dx -= dim;\n                }\n            }\n            if (!borderTile.dem || !tile.dem) return;\n            tile.dem.backfillBorder(borderTile.dem, dx, dy);\n            if (tile.neighboringTiles && tile.neighboringTiles[borderId])\n                tile.neighboringTiles[borderId].backfilled = true;\n        }\n    }\n    /**\n     * Get a specific tile by TileID\n     */\n    getTile(tileID: OverscaledTileID): Tile {\n        return this.getTileByID(tileID.key);\n    }\n\n    /**\n     * Get a specific tile by id\n     */\n    getTileByID(id: string | number): Tile {\n        return this._tiles[id];\n    }\n\n    /**\n     * get the zoom level adjusted for the difference in map and source tilesizes\n     */\n    getZoom(transform: Transform): number {\n        return transform.zoom + transform.scaleZoom(transform.tileSize / this._source.tileSize);\n    }\n\n    /**\n     * For a given set of tiles, retain children that are loaded and have a zoom\n     * between `zoom` (exclusive) and `maxCoveringZoom` (inclusive)\n     */\n    _retainLoadedChildren(\n        idealTiles: {[any]: OverscaledTileID},\n        zoom: number,\n        maxCoveringZoom: number,\n        retain: {[any]: OverscaledTileID}\n    ) {\n        for (const id in this._tiles) {\n            let tile = this._tiles[id];\n\n            // only consider renderable tiles up to maxCoveringZoom\n            if (retain[id] ||\n                !tile.hasData() ||\n                tile.tileID.overscaledZ <= zoom ||\n                tile.tileID.overscaledZ > maxCoveringZoom\n            ) continue;\n\n            // loop through parents and retain the topmost loaded one if found\n            let topmostLoadedID = tile.tileID;\n            while (tile && tile.tileID.overscaledZ > zoom + 1) {\n                const parentID = tile.tileID.scaledTo(tile.tileID.overscaledZ - 1);\n\n                tile = this._tiles[parentID.key];\n\n                if (tile && tile.hasData()) {\n                    topmostLoadedID = parentID;\n                }\n            }\n\n            // loop through ancestors of the topmost loaded child to see if there's one that needed it\n            let tileID = topmostLoadedID;\n            while (tileID.overscaledZ > zoom) {\n                tileID = tileID.scaledTo(tileID.overscaledZ - 1);\n\n                if (idealTiles[tileID.key]) {\n                    // found a parent that needed a loaded child; retain that child\n                    retain[topmostLoadedID.key] = topmostLoadedID;\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * Find a loaded parent of the given tile (up to minCoveringZoom)\n     */\n    findLoadedParent(tileID: OverscaledTileID, minCoveringZoom: number): ?Tile {\n        for (let z = tileID.overscaledZ - 1; z >= minCoveringZoom; z--) {\n            const parent = tileID.scaledTo(z);\n            if (!parent) return;\n            const id = String(parent.key);\n            const tile = this._tiles[id];\n            if (tile && tile.hasData()) {\n                return tile;\n            }\n            if (this._cache.has(parent)) {\n                return this._cache.get(parent);\n            }\n        }\n    }\n\n    /**\n     * Resizes the tile cache based on the current viewport's size\n     * or the maxTileCacheSize option passed during map creation\n     *\n     * Larger viewports use more tiles and need larger caches. Larger viewports\n     * are more likely to be found on devices with more memory and on pages where\n     * the map is more important.\n     */\n    updateCacheSize(transform: Transform) {\n        const widthInTiles = Math.ceil(transform.width / this._source.tileSize) + 1;\n        const heightInTiles = Math.ceil(transform.height / this._source.tileSize) + 1;\n        const approxTilesInView = widthInTiles * heightInTiles;\n        const commonZoomRange = 5;\n\n        const viewDependentMaxSize = Math.floor(approxTilesInView * commonZoomRange);\n        const maxSize = typeof this._maxTileCacheSize === 'number' ? Math.min(this._maxTileCacheSize, viewDependentMaxSize) : viewDependentMaxSize;\n\n        this._cache.setMaxSize(maxSize);\n    }\n\n    handleWrapJump(lng: number) {\n        // On top of the regular z/x/y values, TileIDs have a `wrap` value that specify\n        // which cppy of the world the tile belongs to. For example, at `lng: 10` you\n        // might render z/x/y/0 while at `lng: 370` you would render z/x/y/1.\n        //\n        // When lng values get wrapped (going from `lng: 370` to `long: 10`) you expect\n        // to see the same thing on the screen (370 degrees and 10 degrees is the same\n        // place in the world) but all the TileIDs will have different wrap values.\n        //\n        // In order to make this transition seamless, we calculate the rounded difference of\n        // \"worlds\" between the last frame and the current frame. If the map panned by\n        // a world, then we can assign all the tiles new TileIDs with updated wrap values.\n        // For example, assign z/x/y/1 a new id: z/x/y/0. It is the same tile, just rendered\n        // in a different position.\n        //\n        // This enables us to reuse the tiles at more ideal locations and prevent flickering.\n        const prevLng = this._prevLng === undefined ? lng : this._prevLng;\n        const lngDifference = lng - prevLng;\n        const worldDifference = lngDifference / 360;\n        const wrapDelta = Math.round(worldDifference);\n        this._prevLng = lng;\n\n        if (wrapDelta) {\n            const tiles = {};\n            for (const key in this._tiles) {\n                const tile = this._tiles[key];\n                tile.tileID = tile.tileID.unwrapTo(tile.tileID.wrap + wrapDelta);\n                tiles[tile.tileID.key] = tile;\n            }\n            this._tiles = tiles;\n\n            // Reset tile reload timers\n            for (const id in this._timers) {\n                clearTimeout(this._timers[id]);\n                delete this._timers[id];\n            }\n            for (const id in this._tiles) {\n                const tile = this._tiles[id];\n                this._setTileReloadTimer(id, tile);\n            }\n        }\n    }\n\n    /**\n     * Removes tiles that are outside the viewport and adds new tiles that\n     * are inside the viewport.\n     */\n    update(transform: Transform) {\n        this.transform = transform;\n        if (!this._sourceLoaded || this._paused) { return; }\n\n        this.updateCacheSize(transform);\n        this.handleWrapJump(this.transform.center.lng);\n\n        // Covered is a list of retained tiles who's areas are fully covered by other,\n        // better, retained tiles. They are not drawn separately.\n        this._coveredTiles = {};\n\n        let idealTileIDs;\n        if (!this.used) {\n            idealTileIDs = [];\n        } else if (this._source.tileID) {\n            idealTileIDs = transform.getVisibleUnwrappedCoordinates(this._source.tileID)\n                .map((unwrapped) => new OverscaledTileID(unwrapped.canonical.z, unwrapped.wrap, unwrapped.canonical.z, unwrapped.canonical.x, unwrapped.canonical.y));\n        } else {\n            idealTileIDs = transform.coveringTiles({\n                tileSize: this._source.tileSize,\n                minzoom: this._source.minzoom,\n                maxzoom: this._source.maxzoom,\n                roundZoom: this._source.roundZoom,\n                reparseOverscaled: this._source.reparseOverscaled\n            });\n\n            if (this._source.hasTile) {\n                idealTileIDs = idealTileIDs.filter((coord) => (this._source.hasTile: any)(coord));\n            }\n        }\n\n        // Determine the overzooming/underzooming amounts.\n        const zoom = (this._source.roundZoom ? Math.round : Math.floor)(this.getZoom(transform));\n        const minCoveringZoom = Math.max(zoom - SourceCache.maxOverzooming, this._source.minzoom);\n        const maxCoveringZoom = Math.max(zoom + SourceCache.maxUnderzooming,  this._source.minzoom);\n\n        // Retain is a list of tiles that we shouldn't delete, even if they are not\n        // the most ideal tile for the current viewport. This may include tiles like\n        // parent or child tiles that are *already* loaded.\n        const retain = this._updateRetainedTiles(idealTileIDs, zoom);\n\n        if (isRasterType(this._source.type)) {\n            const parentsForFading = {};\n            const fadingTiles = {};\n            const ids = Object.keys(retain);\n            for (const id of ids) {\n                const tileID = retain[id];\n                assert(tileID.key === +id);\n\n                const tile = this._tiles[id];\n                if (!tile || tile.fadeEndTime && tile.fadeEndTime <= browser.now()) continue;\n\n                // if the tile is loaded but still fading in, find parents to cross-fade with it\n                const parentTile = this.findLoadedParent(tileID, minCoveringZoom);\n                if (parentTile) {\n                    this._addTile(parentTile.tileID);\n                    parentsForFading[parentTile.tileID.key] = parentTile.tileID;\n                }\n\n                fadingTiles[id] = tileID;\n            }\n\n            // for tiles that are still fading in, also find children to cross-fade with\n            this._retainLoadedChildren(fadingTiles, zoom, maxCoveringZoom, retain);\n\n            for (const id in parentsForFading) {\n                if (!retain[id]) {\n                    // If a tile is only needed for fading, mark it as covered so that it isn't rendered on it's own.\n                    this._coveredTiles[id] = true;\n                    retain[id] = parentsForFading[id];\n                }\n            }\n        }\n\n        for (const retainedId in retain) {\n            // Make sure retained tiles always clear any existing fade holds\n            // so that if they're removed again their fade timer starts fresh.\n            this._tiles[retainedId].clearFadeHold();\n        }\n\n        // Remove the tiles we don't need anymore.\n        const remove = keysDifference(this._tiles, retain);\n        for (const tileID of remove) {\n            const tile = this._tiles[tileID];\n            if (tile.hasSymbolBuckets && !tile.holdingForFade()) {\n                tile.setHoldDuration(this.map._fadeDuration);\n            } else if (!tile.hasSymbolBuckets || tile.symbolFadeFinished()) {\n                this._removeTile(tileID);\n            }\n        }\n    }\n\n    releaseSymbolFadeTiles() {\n        for (const id in this._tiles) {\n            if (this._tiles[id].holdingForFade()) {\n                this._removeTile(id);\n            }\n        }\n    }\n\n    _updateRetainedTiles(idealTileIDs: Array<OverscaledTileID>, zoom: number): { [string]: OverscaledTileID} {\n        const retain = {};\n        const checked: {[number]: boolean } = {};\n        const minCoveringZoom = Math.max(zoom - SourceCache.maxOverzooming, this._source.minzoom);\n        const maxCoveringZoom = Math.max(zoom + SourceCache.maxUnderzooming,  this._source.minzoom);\n\n        const missingTiles = {};\n        for (const tileID of idealTileIDs) {\n            const tile = this._addTile(tileID);\n\n            // retain the tile even if it's not loaded because it's an ideal tile.\n            retain[tileID.key] = tileID;\n\n            if (tile.hasData()) continue;\n\n            if (zoom < this._source.maxzoom) {\n                // save missing tiles that potentially have loaded children\n                missingTiles[tileID.key] = tileID;\n            }\n        }\n\n        // retain any loaded children of ideal tiles up to maxCoveringZoom\n        this._retainLoadedChildren(missingTiles, zoom, maxCoveringZoom, retain);\n\n        for (const tileID of idealTileIDs) {\n            let tile = this._tiles[tileID.key];\n\n            if (tile.hasData()) continue;\n\n            // The tile we require is not yet loaded or does not exist;\n            // Attempt to find children that fully cover it.\n\n            if (zoom + 1 > this._source.maxzoom) {\n                // We're looking for an overzoomed child tile.\n                const childCoord = tileID.children(this._source.maxzoom)[0];\n                const childTile = this.getTile(childCoord);\n                if (!!childTile && childTile.hasData()) {\n                    retain[childCoord.key] = childCoord;\n                    continue; // tile is covered by overzoomed child\n                }\n            } else {\n                // check if all 4 immediate children are loaded (i.e. the missing ideal tile is covered)\n                const children = tileID.children(this._source.maxzoom);\n\n                if (retain[children[0].key] &&\n                    retain[children[1].key] &&\n                    retain[children[2].key] &&\n                    retain[children[3].key]) continue; // tile is covered by children\n            }\n\n            // We couldn't find child tiles that entirely cover the ideal tile; look for parents now.\n\n            // As we ascend up the tile pyramid of the ideal tile, we check whether the parent\n            // tile has been previously requested (and errored because we only loop over tiles with no data)\n            // in order to determine if we need to request its parent.\n            let parentWasRequested = tile.wasRequested();\n\n            for (let overscaledZ = tileID.overscaledZ - 1; overscaledZ >= minCoveringZoom; --overscaledZ) {\n                const parentId = tileID.scaledTo(overscaledZ);\n\n                // Break parent tile ascent if this route has been previously checked by another child.\n                if (checked[parentId.key]) break;\n                checked[parentId.key] = true;\n\n                tile = this.getTile(parentId);\n                if (!tile && parentWasRequested) {\n                    tile = this._addTile(parentId);\n                }\n                if (tile) {\n                    retain[parentId.key] = parentId;\n                    // Save the current values, since they're the parent of the next iteration\n                    // of the parent tile ascent loop.\n                    parentWasRequested = tile.wasRequested();\n                    if (tile.hasData()) break;\n                }\n            }\n        }\n\n        return retain;\n    }\n\n    /**\n     * Add a tile, given its coordinate, to the pyramid.\n     * @private\n     */\n    _addTile(tileID: OverscaledTileID): Tile {\n        let tile = this._tiles[tileID.key];\n        if (tile)\n            return tile;\n\n\n        tile = this._cache.getAndRemove(tileID);\n        if (tile) {\n            this._setTileReloadTimer(tileID.key, tile);\n            // set the tileID because the cached tile could have had a different wrap value\n            tile.tileID = tileID;\n            this._state.initializeTileState(tile, this.map ? this.map.painter : null);\n            if (this._cacheTimers[tileID.key]) {\n                clearTimeout(this._cacheTimers[tileID.key]);\n                delete this._cacheTimers[tileID.key];\n                this._setTileReloadTimer(tileID.key, tile);\n            }\n        }\n\n        const cached = Boolean(tile);\n        if (!cached) {\n            tile = new Tile(tileID, this._source.tileSize * tileID.overscaleFactor());\n            this._loadTile(tile, this._tileLoaded.bind(this, tile, tileID.key, tile.state));\n        }\n\n        // Impossible, but silence flow.\n        if (!tile) return (null: any);\n\n        tile.uses++;\n        this._tiles[tileID.key] = tile;\n        if (!cached) this._source.fire(new Event('dataloading', {tile, coord: tile.tileID, dataType: 'source'}));\n\n        return tile;\n    }\n\n    _setTileReloadTimer(id: string | number, tile: Tile) {\n        if (id in this._timers) {\n            clearTimeout(this._timers[id]);\n            delete this._timers[id];\n        }\n\n        const expiryTimeout = tile.getExpiryTimeout();\n        if (expiryTimeout) {\n            this._timers[id] = setTimeout(() => {\n                this._reloadTile(id, 'expired');\n                delete this._timers[id];\n            }, expiryTimeout);\n        }\n    }\n\n    /**\n     * Remove a tile, given its id, from the pyramid\n     * @private\n     */\n    _removeTile(id: string | number) {\n        const tile = this._tiles[id];\n        if (!tile)\n            return;\n\n        tile.uses--;\n        delete this._tiles[id];\n        if (this._timers[id]) {\n            clearTimeout(this._timers[id]);\n            delete this._timers[id];\n        }\n\n        if (tile.uses > 0)\n            return;\n\n        if (tile.hasData()) {\n            this._cache.add(tile.tileID, tile, tile.getExpiryTimeout());\n        } else {\n            tile.aborted = true;\n            this._abortTile(tile);\n            this._unloadTile(tile);\n        }\n    }\n\n    /**\n     * Remove all tiles from this pyramid\n     */\n    clearTiles() {\n        this._shouldReloadOnResume = false;\n        this._paused = false;\n\n        for (const id in this._tiles)\n            this._removeTile(id);\n\n        this._cache.reset();\n    }\n\n    /**\n     * Search through our current tiles and attempt to find the tiles that\n     * cover the given bounds.\n     * @param pointQueryGeometry coordinates of the corners of bounding rectangle\n     * @returns {Array<Object>} result items have {tile, minX, maxX, minY, maxY}, where min/max bounding values are the given bounds transformed in into the coordinate space of this tile.\n     */\n    tilesIn(pointQueryGeometry: Array<Point>, maxPitchScaleFactor: number, has3DLayer: boolean) {\n\n        const tileResults = [];\n\n        const transform = this.transform;\n        if (!transform) return tileResults;\n\n        const cameraPointQueryGeometry = has3DLayer ?\n            transform.getCameraQueryGeometry(pointQueryGeometry) :\n            pointQueryGeometry;\n\n        const queryGeometry = pointQueryGeometry.map((p) => transform.pointCoordinate(p));\n        const cameraQueryGeometry = cameraPointQueryGeometry.map((p) => transform.pointCoordinate(p));\n\n        const ids = this.getIds();\n\n        let minX = Infinity;\n        let minY = Infinity;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n\n        for (const p of cameraQueryGeometry) {\n            minX = Math.min(minX, p.x);\n            minY = Math.min(minY, p.y);\n            maxX = Math.max(maxX, p.x);\n            maxY = Math.max(maxY, p.y);\n        }\n\n        for (let i = 0; i < ids.length; i++) {\n            const tile = this._tiles[ids[i]];\n            if (tile.holdingForFade()) {\n                // Tiles held for fading are covered by tiles that are closer to ideal\n                continue;\n            }\n            const tileID = tile.tileID;\n            const scale = Math.pow(2, transform.zoom - tile.tileID.overscaledZ);\n            const queryPadding = maxPitchScaleFactor * tile.queryPadding * EXTENT / tile.tileSize / scale;\n\n            const tileSpaceBounds = [\n                tileID.getTilePoint(new MercatorCoordinate(minX, minY)),\n                tileID.getTilePoint(new MercatorCoordinate(maxX, maxY))\n            ];\n\n            if (tileSpaceBounds[0].x - queryPadding < EXTENT && tileSpaceBounds[0].y - queryPadding < EXTENT &&\n                tileSpaceBounds[1].x + queryPadding >= 0 && tileSpaceBounds[1].y + queryPadding >= 0) {\n\n                const tileSpaceQueryGeometry: Array<Point> = queryGeometry.map((c) => tileID.getTilePoint(c));\n                const tileSpaceCameraQueryGeometry = cameraQueryGeometry.map((c) => tileID.getTilePoint(c));\n\n                tileResults.push({\n                    tile,\n                    tileID,\n                    queryGeometry: tileSpaceQueryGeometry,\n                    cameraQueryGeometry: tileSpaceCameraQueryGeometry,\n                    scale\n                });\n            }\n        }\n\n        return tileResults;\n    }\n\n    getVisibleCoordinates(symbolLayer?: boolean): Array<OverscaledTileID> {\n        const coords = this.getRenderableIds(symbolLayer).map((id) => this._tiles[id].tileID);\n        for (const coord of coords) {\n            coord.posMatrix = this.transform.calculatePosMatrix(coord.toUnwrapped());\n        }\n        return coords;\n    }\n\n    hasTransition() {\n        if (this._source.hasTransition()) {\n            return true;\n        }\n\n        if (isRasterType(this._source.type)) {\n            for (const id in this._tiles) {\n                const tile = this._tiles[id];\n                if (tile.fadeEndTime !== undefined && tile.fadeEndTime >= browser.now()) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Set the value of a particular state for a feature\n     * @private\n     */\n    setFeatureState(sourceLayer?: string, feature: number, state: Object) {\n        sourceLayer = sourceLayer || '_geojsonTileLayer';\n        this._state.updateState(sourceLayer, feature, state);\n    }\n\n    /**\n     * Resets the value of a particular state key for a feature\n     * @private\n     */\n    removeFeatureState(sourceLayer?: string, feature?: number, key?: string) {\n        sourceLayer = sourceLayer || '_geojsonTileLayer';\n        this._state.removeFeatureState(sourceLayer, feature, key);\n    }\n\n    /**\n     * Get the entire state object for a feature\n     * @private\n     */\n    getFeatureState(sourceLayer?: string, feature: number) {\n        sourceLayer = sourceLayer || '_geojsonTileLayer';\n        return this._state.getState(sourceLayer, feature);\n    }\n}\n\nSourceCache.maxOverzooming = 10;\nSourceCache.maxUnderzooming = 3;\n\nfunction compareKeyZoom(a, b) {\n    return ((a % 32) - (b % 32)) || (b - a);\n}\n\nfunction isRasterType(type) {\n    return type === 'raster' || type === 'image' || type === 'video';\n}\n\nexport default SourceCache;\n","// @flow\n\nimport { mat4 } from 'gl-matrix';\nimport EXTENT from '../data/extent';\nimport { PosArray } from '../data/array_types';\nimport { LineIndexArray } from '../data/index_array_type';\nimport posAttributes from '../data/pos_attributes';\nimport SegmentVector from '../data/segment';\nimport DepthMode from '../gl/depth_mode';\nimport StencilMode from '../gl/stencil_mode';\nimport CullFaceMode from '../gl/cull_face_mode';\nimport { debugUniformValues } from './program/debug_program';\nimport Color from '../style-spec/util/color';\n\nimport type Painter from './painter';\nimport type SourceCache from '../source/source_cache';\nimport type {OverscaledTileID} from '../source/tile_id';\n\nexport default drawDebug;\n\nfunction drawDebug(painter: Painter, sourceCache: SourceCache, coords: Array<OverscaledTileID>) {\n    for (let i = 0; i < coords.length; i++) {\n        drawDebugTile(painter, sourceCache, coords[i]);\n    }\n}\n\nfunction drawDebugTile(painter, sourceCache, coord) {\n    const context = painter.context;\n    const gl = context.gl;\n\n    const posMatrix = coord.posMatrix;\n    const program = painter.useProgram('debug');\n\n    const depthMode = DepthMode.disabled;\n    const stencilMode = StencilMode.disabled;\n    const colorMode = painter.colorModeForRenderPass();\n    const id = '$debug';\n\n    program.draw(context, gl.LINE_STRIP, depthMode, stencilMode, colorMode, CullFaceMode.disabled,\n        debugUniformValues(posMatrix, Color.red), id,\n        painter.debugBuffer, painter.tileBorderIndexBuffer, painter.debugSegments);\n\n    const vertices = createTextVertices(coord.toString(), 50, 200, 5);\n    const debugTextArray = new PosArray();\n    const debugTextIndices = new LineIndexArray();\n    for (let v = 0; v < vertices.length; v += 2) {\n        debugTextArray.emplaceBack(vertices[v], vertices[v + 1]);\n        debugTextIndices.emplaceBack(v, v + 1);\n    }\n    const debugTextBuffer = context.createVertexBuffer(debugTextArray, posAttributes.members);\n    const debugTextIndexBuffer = context.createIndexBuffer(debugTextIndices);\n    const debugTextSegment = SegmentVector.simpleSegment(0, 0, debugTextArray.length / 2, debugTextArray.length / 2);\n\n    // Draw the halo with multiple 1px lines instead of one wider line because\n    // the gl spec doesn't guarantee support for lines with width > 1.\n    const tileSize = sourceCache.getTile(coord).tileSize;\n    const onePixel = EXTENT / (Math.pow(2, painter.transform.zoom - coord.overscaledZ) * tileSize);\n    const translations = [[-1, -1], [-1, 1], [1, -1], [1, 1]];\n    for (let i = 0; i < translations.length; i++) {\n        const translation = translations[i];\n\n        program.draw(context, gl.LINES, depthMode, stencilMode, colorMode, CullFaceMode.disabled,\n            debugUniformValues(\n                mat4.translate([], posMatrix, [\n                    onePixel * translation[0],\n                    onePixel * translation[1], 0]),\n                Color.white),\n            id, debugTextBuffer, debugTextIndexBuffer, debugTextSegment);\n    }\n\n    program.draw(context, gl.LINES, depthMode, stencilMode, colorMode, CullFaceMode.disabled,\n        debugUniformValues(posMatrix, Color.black), id,\n        debugTextBuffer, debugTextIndexBuffer, debugTextSegment);\n}\n\n// Font data From Hershey Simplex Font\n// http://paulbourke.net/dataformats/hershey/\nconst simplexFont = {\n    \" \": [16, []],\n    \"!\": [10, [5, 21, 5, 7, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],\n    \"\\\"\": [16, [4, 21, 4, 14, -1, -1, 12, 21, 12, 14]],\n    \"#\": [21, [11, 25, 4, -7, -1, -1, 17, 25, 10, -7, -1, -1, 4, 12, 18, 12, -1, -1, 3, 6, 17, 6]],\n    \"$\": [20, [8, 25, 8, -4, -1, -1, 12, 25, 12, -4, -1, -1, 17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]],\n    \"%\": [24, [21, 21, 3, 0, -1, -1, 8, 21, 10, 19, 10, 17, 9, 15, 7, 14, 5, 14, 3, 16, 3, 18, 4, 20, 6, 21, 8, 21, 10, 20, 13, 19, 16, 19, 19, 20, 21, 21, -1, -1, 17, 7, 15, 6, 14, 4, 14, 2, 16, 0, 18, 0, 20, 1, 21, 3, 21, 5, 19, 7, 17, 7]],\n    \"&\": [26, [23, 12, 23, 13, 22, 14, 21, 14, 20, 13, 19, 11, 17, 6, 15, 3, 13, 1, 11, 0, 7, 0, 5, 1, 4, 2, 3, 4, 3, 6, 4, 8, 5, 9, 12, 13, 13, 14, 14, 16, 14, 18, 13, 20, 11, 21, 9, 20, 8, 18, 8, 16, 9, 13, 11, 10, 16, 3, 18, 1, 20, 0, 22, 0, 23, 1, 23, 2]],\n    \"'\": [10, [5, 19, 4, 20, 5, 21, 6, 20, 6, 18, 5, 16, 4, 15]],\n    \"(\": [14, [11, 25, 9, 23, 7, 20, 5, 16, 4, 11, 4, 7, 5, 2, 7, -2, 9, -5, 11, -7]],\n    \")\": [14, [3, 25, 5, 23, 7, 20, 9, 16, 10, 11, 10, 7, 9, 2, 7, -2, 5, -5, 3, -7]],\n    \"*\": [16, [8, 21, 8, 9, -1, -1, 3, 18, 13, 12, -1, -1, 13, 18, 3, 12]],\n    \"+\": [26, [13, 18, 13, 0, -1, -1, 4, 9, 22, 9]],\n    \",\": [10, [6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]],\n    \"-\": [26, [4, 9, 22, 9]],\n    \".\": [10, [5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],\n    \"/\": [22, [20, 25, 2, -7]],\n    \"0\": [20, [9, 21, 6, 20, 4, 17, 3, 12, 3, 9, 4, 4, 6, 1, 9, 0, 11, 0, 14, 1, 16, 4, 17, 9, 17, 12, 16, 17, 14, 20, 11, 21, 9, 21]],\n    \"1\": [20, [6, 17, 8, 18, 11, 21, 11, 0]],\n    \"2\": [20, [4, 16, 4, 17, 5, 19, 6, 20, 8, 21, 12, 21, 14, 20, 15, 19, 16, 17, 16, 15, 15, 13, 13, 10, 3, 0, 17, 0]],\n    \"3\": [20, [5, 21, 16, 21, 10, 13, 13, 13, 15, 12, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]],\n    \"4\": [20, [13, 21, 3, 7, 18, 7, -1, -1, 13, 21, 13, 0]],\n    \"5\": [20, [15, 21, 5, 21, 4, 12, 5, 13, 8, 14, 11, 14, 14, 13, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]],\n    \"6\": [20, [16, 18, 15, 20, 12, 21, 10, 21, 7, 20, 5, 17, 4, 12, 4, 7, 5, 3, 7, 1, 10, 0, 11, 0, 14, 1, 16, 3, 17, 6, 17, 7, 16, 10, 14, 12, 11, 13, 10, 13, 7, 12, 5, 10, 4, 7]],\n    \"7\": [20, [17, 21, 7, 0, -1, -1, 3, 21, 17, 21]],\n    \"8\": [20, [8, 21, 5, 20, 4, 18, 4, 16, 5, 14, 7, 13, 11, 12, 14, 11, 16, 9, 17, 7, 17, 4, 16, 2, 15, 1, 12, 0, 8, 0, 5, 1, 4, 2, 3, 4, 3, 7, 4, 9, 6, 11, 9, 12, 13, 13, 15, 14, 16, 16, 16, 18, 15, 20, 12, 21, 8, 21]],\n    \"9\": [20, [16, 14, 15, 11, 13, 9, 10, 8, 9, 8, 6, 9, 4, 11, 3, 14, 3, 15, 4, 18, 6, 20, 9, 21, 10, 21, 13, 20, 15, 18, 16, 14, 16, 9, 15, 4, 13, 1, 10, 0, 8, 0, 5, 1, 4, 3]],\n    \":\": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],\n    \";\": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]],\n    \"<\": [24, [20, 18, 4, 9, 20, 0]],\n    \"=\": [26, [4, 12, 22, 12, -1, -1, 4, 6, 22, 6]],\n    \">\": [24, [4, 18, 20, 9, 4, 0]],\n    \"?\": [18, [3, 16, 3, 17, 4, 19, 5, 20, 7, 21, 11, 21, 13, 20, 14, 19, 15, 17, 15, 15, 14, 13, 13, 12, 9, 10, 9, 7, -1, -1, 9, 2, 8, 1, 9, 0, 10, 1, 9, 2]],\n    \"@\": [27, [18, 13, 17, 15, 15, 16, 12, 16, 10, 15, 9, 14, 8, 11, 8, 8, 9, 6, 11, 5, 14, 5, 16, 6, 17, 8, -1, -1, 12, 16, 10, 14, 9, 11, 9, 8, 10, 6, 11, 5, -1, -1, 18, 16, 17, 8, 17, 6, 19, 5, 21, 5, 23, 7, 24, 10, 24, 12, 23, 15, 22, 17, 20, 19, 18, 20, 15, 21, 12, 21, 9, 20, 7, 19, 5, 17, 4, 15, 3, 12, 3, 9, 4, 6, 5, 4, 7, 2, 9, 1, 12, 0, 15, 0, 18, 1, 20, 2, 21, 3, -1, -1, 19, 16, 18, 8, 18, 6, 19, 5]],\n    \"A\": [18, [9, 21, 1, 0, -1, -1, 9, 21, 17, 0, -1, -1, 4, 7, 14, 7]],\n    \"B\": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, -1, -1, 4, 11, 13, 11, 16, 10, 17, 9, 18, 7, 18, 4, 17, 2, 16, 1, 13, 0, 4, 0]],\n    \"C\": [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5]],\n    \"D\": [21, [4, 21, 4, 0, -1, -1, 4, 21, 11, 21, 14, 20, 16, 18, 17, 16, 18, 13, 18, 8, 17, 5, 16, 3, 14, 1, 11, 0, 4, 0]],\n    \"E\": [19, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11, -1, -1, 4, 0, 17, 0]],\n    \"F\": [18, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11]],\n    \"G\": [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 18, 8, -1, -1, 13, 8, 18, 8]],\n    \"H\": [22, [4, 21, 4, 0, -1, -1, 18, 21, 18, 0, -1, -1, 4, 11, 18, 11]],\n    \"I\": [8, [4, 21, 4, 0]],\n    \"J\": [16, [12, 21, 12, 5, 11, 2, 10, 1, 8, 0, 6, 0, 4, 1, 3, 2, 2, 5, 2, 7]],\n    \"K\": [21, [4, 21, 4, 0, -1, -1, 18, 21, 4, 7, -1, -1, 9, 12, 18, 0]],\n    \"L\": [17, [4, 21, 4, 0, -1, -1, 4, 0, 16, 0]],\n    \"M\": [24, [4, 21, 4, 0, -1, -1, 4, 21, 12, 0, -1, -1, 20, 21, 12, 0, -1, -1, 20, 21, 20, 0]],\n    \"N\": [22, [4, 21, 4, 0, -1, -1, 4, 21, 18, 0, -1, -1, 18, 21, 18, 0]],\n    \"O\": [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21]],\n    \"P\": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 14, 17, 12, 16, 11, 13, 10, 4, 10]],\n    \"Q\": [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21, -1, -1, 12, 4, 18, -2]],\n    \"R\": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, 4, 11, -1, -1, 11, 11, 18, 0]],\n    \"S\": [20, [17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]],\n    \"T\": [16, [8, 21, 8, 0, -1, -1, 1, 21, 15, 21]],\n    \"U\": [22, [4, 21, 4, 6, 5, 3, 7, 1, 10, 0, 12, 0, 15, 1, 17, 3, 18, 6, 18, 21]],\n    \"V\": [18, [1, 21, 9, 0, -1, -1, 17, 21, 9, 0]],\n    \"W\": [24, [2, 21, 7, 0, -1, -1, 12, 21, 7, 0, -1, -1, 12, 21, 17, 0, -1, -1, 22, 21, 17, 0]],\n    \"X\": [20, [3, 21, 17, 0, -1, -1, 17, 21, 3, 0]],\n    \"Y\": [18, [1, 21, 9, 11, 9, 0, -1, -1, 17, 21, 9, 11]],\n    \"Z\": [20, [17, 21, 3, 0, -1, -1, 3, 21, 17, 21, -1, -1, 3, 0, 17, 0]],\n    \"[\": [14, [4, 25, 4, -7, -1, -1, 5, 25, 5, -7, -1, -1, 4, 25, 11, 25, -1, -1, 4, -7, 11, -7]],\n    \"\\\\\": [14, [0, 21, 14, -3]],\n    \"]\": [14, [9, 25, 9, -7, -1, -1, 10, 25, 10, -7, -1, -1, 3, 25, 10, 25, -1, -1, 3, -7, 10, -7]],\n    \"^\": [16, [6, 15, 8, 18, 10, 15, -1, -1, 3, 12, 8, 17, 13, 12, -1, -1, 8, 17, 8, 0]],\n    \"_\": [16, [0, -2, 16, -2]],\n    \"`\": [10, [6, 21, 5, 20, 4, 18, 4, 16, 5, 15, 6, 16, 5, 17]],\n    \"a\": [19, [15, 14, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],\n    \"b\": [19, [4, 21, 4, 0, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]],\n    \"c\": [18, [15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],\n    \"d\": [19, [15, 21, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],\n    \"e\": [18, [3, 8, 15, 8, 15, 10, 14, 12, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],\n    \"f\": [12, [10, 21, 8, 21, 6, 20, 5, 17, 5, 0, -1, -1, 2, 14, 9, 14]],\n    \"g\": [19, [15, 14, 15, -2, 14, -5, 13, -6, 11, -7, 8, -7, 6, -6, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],\n    \"h\": [19, [4, 21, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],\n    \"i\": [8, [3, 21, 4, 20, 5, 21, 4, 22, 3, 21, -1, -1, 4, 14, 4, 0]],\n    \"j\": [10, [5, 21, 6, 20, 7, 21, 6, 22, 5, 21, -1, -1, 6, 14, 6, -3, 5, -6, 3, -7, 1, -7]],\n    \"k\": [17, [4, 21, 4, 0, -1, -1, 14, 14, 4, 4, -1, -1, 8, 8, 15, 0]],\n    \"l\": [8, [4, 21, 4, 0]],\n    \"m\": [30, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0, -1, -1, 15, 10, 18, 13, 20, 14, 23, 14, 25, 13, 26, 10, 26, 0]],\n    \"n\": [19, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],\n    \"o\": [19, [8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3, 16, 6, 16, 8, 15, 11, 13, 13, 11, 14, 8, 14]],\n    \"p\": [19, [4, 14, 4, -7, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]],\n    \"q\": [19, [15, 14, 15, -7, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],\n    \"r\": [13, [4, 14, 4, 0, -1, -1, 4, 8, 5, 11, 7, 13, 9, 14, 12, 14]],\n    \"s\": [17, [14, 11, 13, 13, 10, 14, 7, 14, 4, 13, 3, 11, 4, 9, 6, 8, 11, 7, 13, 6, 14, 4, 14, 3, 13, 1, 10, 0, 7, 0, 4, 1, 3, 3]],\n    \"t\": [12, [5, 21, 5, 4, 6, 1, 8, 0, 10, 0, -1, -1, 2, 14, 9, 14]],\n    \"u\": [19, [4, 14, 4, 4, 5, 1, 7, 0, 10, 0, 12, 1, 15, 4, -1, -1, 15, 14, 15, 0]],\n    \"v\": [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0]],\n    \"w\": [22, [3, 14, 7, 0, -1, -1, 11, 14, 7, 0, -1, -1, 11, 14, 15, 0, -1, -1, 19, 14, 15, 0]],\n    \"x\": [17, [3, 14, 14, 0, -1, -1, 14, 14, 3, 0]],\n    \"y\": [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0, 6, -4, 4, -6, 2, -7, 1, -7]],\n    \"z\": [17, [14, 14, 3, 0, -1, -1, 3, 14, 14, 14, -1, -1, 3, 0, 14, 0]],\n    \"{\": [14, [9, 25, 7, 24, 6, 23, 5, 21, 5, 19, 6, 17, 7, 16, 8, 14, 8, 12, 6, 10, -1, -1, 7, 24, 6, 22, 6, 20, 7, 18, 8, 17, 9, 15, 9, 13, 8, 11, 4, 9, 8, 7, 9, 5, 9, 3, 8, 1, 7, 0, 6, -2, 6, -4, 7, -6, -1, -1, 6, 8, 8, 6, 8, 4, 7, 2, 6, 1, 5, -1, 5, -3, 6, -5, 7, -6, 9, -7]],\n    \"|\": [8, [4, 25, 4, -7]],\n    \"}\": [14, [5, 25, 7, 24, 8, 23, 9, 21, 9, 19, 8, 17, 7, 16, 6, 14, 6, 12, 8, 10, -1, -1, 7, 24, 8, 22, 8, 20, 7, 18, 6, 17, 5, 15, 5, 13, 6, 11, 10, 9, 6, 7, 5, 5, 5, 3, 6, 1, 7, 0, 8, -2, 8, -4, 7, -6, -1, -1, 8, 8, 6, 6, 6, 4, 7, 2, 8, 1, 9, -1, 9, -3, 8, -5, 7, -6, 5, -7]],\n    \"~\": [24, [3, 6, 3, 8, 4, 11, 6, 12, 8, 12, 10, 11, 14, 8, 16, 7, 18, 7, 20, 8, 21, 10, -1, -1, 3, 8, 4, 10, 6, 11, 8, 11, 10, 10, 14, 7, 16, 6, 18, 6, 20, 7, 21, 10, 21, 12]]\n};\n\nfunction createTextVertices(text, left, baseline, scale) {\n    scale = scale || 1;\n\n    const strokes = [];\n    let i, len, j, len2, glyph, x, y, prev;\n\n    for (i = 0, len = text.length; i < len; i++) {\n        glyph = simplexFont[text[i]];\n        if (!glyph) continue;\n        prev = null;\n\n        for (j = 0, len2 = glyph[1].length; j < len2; j += 2) {\n            if (glyph[1][j] === -1 && glyph[1][j + 1] === -1) {\n                prev = null;\n\n            } else {\n                x = left + glyph[1][j] * scale;\n                y = baseline - glyph[1][j + 1] * scale;\n                if (prev) {\n                    strokes.push(prev.x, prev.y, x, y);\n                }\n                prev = {x, y};\n            }\n        }\n        left += glyph[0] * scale;\n    }\n\n    return strokes;\n}\n","// @flow\n\nimport browser from '../util/browser';\n\nimport { mat4 } from 'gl-matrix';\nimport SourceCache from '../source/source_cache';\nimport EXTENT from '../data/extent';\nimport pixelsToTileUnits from '../source/pixels_to_tile_units';\nimport SegmentVector from '../data/segment';\nimport { RasterBoundsArray, PosArray, TriangleIndexArray, LineStripIndexArray } from '../data/array_types';\nimport rasterBoundsAttributes from '../data/raster_bounds_attributes';\nimport posAttributes from '../data/pos_attributes';\nimport ProgramConfiguration from '../data/program_configuration';\nimport CrossTileSymbolIndex from '../symbol/cross_tile_symbol_index';\nimport * as shaders from '../shaders';\nimport Program from './program';\nimport { programUniforms } from './program/program_uniforms';\nimport Context from '../gl/context';\nimport DepthMode from '../gl/depth_mode';\nimport StencilMode from '../gl/stencil_mode';\nimport ColorMode from '../gl/color_mode';\nimport CullFaceMode from '../gl/cull_face_mode';\nimport Texture from './texture';\nimport updateTileMasks from './tile_mask';\nimport { clippingMaskUniformValues } from './program/clipping_mask_program';\nimport Color from '../style-spec/util/color';\nimport symbol from './draw_symbol';\nimport circle from './draw_circle';\nimport heatmap from './draw_heatmap';\nimport line from './draw_line';\nimport fill from './draw_fill';\nimport fillExtrusion from './draw_fill_extrusion';\nimport hillshade from './draw_hillshade';\nimport raster from './draw_raster';\nimport background from './draw_background';\nimport debug from './draw_debug';\nimport custom from './draw_custom';\n\nconst draw = {\n    symbol,\n    circle,\n    heatmap,\n    line,\n    fill,\n    'fill-extrusion': fillExtrusion,\n    hillshade,\n    raster,\n    background,\n    debug,\n    custom\n};\n\nimport type Transform from '../geo/transform';\nimport type Tile from '../source/tile';\nimport type {OverscaledTileID} from '../source/tile_id';\nimport type Style from '../style/style';\nimport type StyleLayer from '../style/style_layer';\nimport type {CrossFaded} from '../style/properties';\nimport type LineAtlas from './line_atlas';\nimport type ImageManager from './image_manager';\nimport type GlyphManager from './glyph_manager';\nimport type VertexBuffer from '../gl/vertex_buffer';\nimport type IndexBuffer from '../gl/index_buffer';\nimport type {DepthMaskType, DepthFuncType} from '../gl/types';\n\nexport type RenderPass = 'offscreen' | 'opaque' | 'translucent';\n\ntype PainterOptions = {\n    showOverdrawInspector: boolean,\n    showTileBoundaries: boolean,\n    rotating: boolean,\n    zooming: boolean,\n    moving: boolean,\n    fadeDuration: number\n}\n\n/**\n * Initialize a new painter object.\n *\n * @param {Canvas} gl an experimental-webgl drawing context\n * @private\n */\nclass Painter {\n    context: Context;\n    transform: Transform;\n    _tileTextures: { [number]: Array<Texture> };\n    numSublayers: number;\n    depthEpsilon: number;\n    emptyProgramConfiguration: ProgramConfiguration;\n    width: number;\n    height: number;\n    depthRbo: WebGLRenderbuffer;\n    depthRboNeedsClear: boolean;\n    tileExtentBuffer: VertexBuffer;\n    tileExtentSegments: SegmentVector;\n    debugBuffer: VertexBuffer;\n    debugSegments: SegmentVector;\n    rasterBoundsBuffer: VertexBuffer;\n    rasterBoundsSegments: SegmentVector;\n    viewportBuffer: VertexBuffer;\n    viewportSegments: SegmentVector;\n    quadTriangleIndexBuffer: IndexBuffer;\n    tileBorderIndexBuffer: IndexBuffer;\n    _tileClippingMaskIDs: { [number]: number };\n    stencilClearMode: StencilMode;\n    style: Style;\n    options: PainterOptions;\n    lineAtlas: LineAtlas;\n    imageManager: ImageManager;\n    glyphManager: GlyphManager;\n    depthRange: number;\n    renderPass: RenderPass;\n    currentLayer: number;\n    id: string;\n    _showOverdrawInspector: boolean;\n    cache: { [string]: Program<*> };\n    crossTileSymbolIndex: CrossTileSymbolIndex;\n    symbolFadeChange: number;\n\n    constructor(gl: WebGLRenderingContext, transform: Transform) {\n        this.context = new Context(gl);\n        this.transform = transform;\n        this._tileTextures = {};\n\n        this.setup();\n\n        // Within each layer there are multiple distinct z-planes that can be drawn to.\n        // This is implemented using the WebGL depth buffer.\n        this.numSublayers = SourceCache.maxUnderzooming + SourceCache.maxOverzooming + 1;\n        this.depthEpsilon = 1 / Math.pow(2, 16);\n\n        this.depthRboNeedsClear = true;\n\n        this.emptyProgramConfiguration = new ProgramConfiguration();\n\n        this.crossTileSymbolIndex = new CrossTileSymbolIndex();\n    }\n\n    /*\n     * Update the GL viewport, projection matrix, and transforms to compensate\n     * for a new width and height value.\n     */\n    resize(width: number, height: number) {\n        const gl = this.context.gl;\n\n        this.width = width * browser.devicePixelRatio;\n        this.height = height * browser.devicePixelRatio;\n        this.context.viewport.set([0, 0, this.width, this.height]);\n\n        if (this.style) {\n            for (const layerId of this.style._order) {\n                this.style._layers[layerId].resize();\n            }\n        }\n\n        if (this.depthRbo) {\n            gl.deleteRenderbuffer(this.depthRbo);\n            this.depthRbo = null;\n        }\n    }\n\n    setup() {\n        const context = this.context;\n\n        const tileExtentArray = new PosArray();\n        tileExtentArray.emplaceBack(0, 0);\n        tileExtentArray.emplaceBack(EXTENT, 0);\n        tileExtentArray.emplaceBack(0, EXTENT);\n        tileExtentArray.emplaceBack(EXTENT, EXTENT);\n        this.tileExtentBuffer = context.createVertexBuffer(tileExtentArray, posAttributes.members);\n        this.tileExtentSegments = SegmentVector.simpleSegment(0, 0, 4, 2);\n\n        const debugArray = new PosArray();\n        debugArray.emplaceBack(0, 0);\n        debugArray.emplaceBack(EXTENT, 0);\n        debugArray.emplaceBack(0, EXTENT);\n        debugArray.emplaceBack(EXTENT, EXTENT);\n        this.debugBuffer = context.createVertexBuffer(debugArray, posAttributes.members);\n        this.debugSegments = SegmentVector.simpleSegment(0, 0, 4, 5);\n\n        const rasterBoundsArray = new RasterBoundsArray();\n        rasterBoundsArray.emplaceBack(0, 0, 0, 0);\n        rasterBoundsArray.emplaceBack(EXTENT, 0, EXTENT, 0);\n        rasterBoundsArray.emplaceBack(0, EXTENT, 0, EXTENT);\n        rasterBoundsArray.emplaceBack(EXTENT, EXTENT, EXTENT, EXTENT);\n        this.rasterBoundsBuffer = context.createVertexBuffer(rasterBoundsArray, rasterBoundsAttributes.members);\n        this.rasterBoundsSegments = SegmentVector.simpleSegment(0, 0, 4, 2);\n\n        const viewportArray = new PosArray();\n        viewportArray.emplaceBack(0, 0);\n        viewportArray.emplaceBack(1, 0);\n        viewportArray.emplaceBack(0, 1);\n        viewportArray.emplaceBack(1, 1);\n        this.viewportBuffer = context.createVertexBuffer(viewportArray, posAttributes.members);\n        this.viewportSegments = SegmentVector.simpleSegment(0, 0, 4, 2);\n\n        const tileLineStripIndices = new LineStripIndexArray();\n        tileLineStripIndices.emplaceBack(0);\n        tileLineStripIndices.emplaceBack(1);\n        tileLineStripIndices.emplaceBack(3);\n        tileLineStripIndices.emplaceBack(2);\n        tileLineStripIndices.emplaceBack(0);\n        this.tileBorderIndexBuffer = context.createIndexBuffer(tileLineStripIndices);\n\n        const quadTriangleIndices = new TriangleIndexArray();\n        quadTriangleIndices.emplaceBack(0, 1, 2);\n        quadTriangleIndices.emplaceBack(2, 1, 3);\n        this.quadTriangleIndexBuffer = context.createIndexBuffer(quadTriangleIndices);\n\n        const gl = this.context.gl;\n        this.stencilClearMode = new StencilMode({ func: gl.ALWAYS, mask: 0 }, 0x0, 0xFF, gl.ZERO, gl.ZERO, gl.ZERO);\n    }\n\n    /*\n     * Reset the drawing canvas by clearing the stencil buffer so that we can draw\n     * new tiles at the same location, while retaining previously drawn pixels.\n     */\n    clearStencil() {\n        const context = this.context;\n        const gl = context.gl;\n\n        // As a temporary workaround for https://github.com/mapbox/mapbox-gl-js/issues/5490,\n        // pending an upstream fix, we draw a fullscreen stencil=0 clipping mask here,\n        // effectively clearing the stencil buffer: once an upstream patch lands, remove\n        // this function in favor of context.clear({ stencil: 0x0 })\n\n        const matrix = mat4.create();\n        mat4.ortho(matrix, 0, this.width, this.height, 0, 0, 1);\n        mat4.scale(matrix, matrix, [gl.drawingBufferWidth, gl.drawingBufferHeight, 0]);\n\n        this.useProgram('clippingMask').draw(context, gl.TRIANGLES,\n            DepthMode.disabled, this.stencilClearMode, ColorMode.disabled, CullFaceMode.disabled,\n            clippingMaskUniformValues(matrix),\n            '$clipping', this.viewportBuffer,\n            this.quadTriangleIndexBuffer, this.viewportSegments);\n    }\n\n    _renderTileClippingMasks(tileIDs: Array<OverscaledTileID>) {\n        const context = this.context;\n        const gl = context.gl;\n\n        context.setColorMode(ColorMode.disabled);\n        context.setDepthMode(DepthMode.disabled);\n\n        const program = this.useProgram('clippingMask');\n\n        let idNext = 1;\n        this._tileClippingMaskIDs = {};\n\n        for (const tileID of tileIDs) {\n            const id = this._tileClippingMaskIDs[tileID.key] = idNext++;\n\n            program.draw(context, gl.TRIANGLES, DepthMode.disabled,\n                // Tests will always pass, and ref value will be written to stencil buffer.\n                new StencilMode({ func: gl.ALWAYS, mask: 0 }, id, 0xFF, gl.KEEP, gl.KEEP, gl.REPLACE),\n                ColorMode.disabled, CullFaceMode.disabled, clippingMaskUniformValues(tileID.posMatrix),\n                '$clipping', this.tileExtentBuffer,\n                this.quadTriangleIndexBuffer, this.tileExtentSegments);\n        }\n    }\n\n    stencilModeForClipping(tileID: OverscaledTileID): StencilMode {\n        const gl = this.context.gl;\n        return new StencilMode({ func: gl.EQUAL, mask: 0xFF }, this._tileClippingMaskIDs[tileID.key], 0x00, gl.KEEP, gl.KEEP, gl.REPLACE);\n    }\n\n    colorModeForRenderPass(): $ReadOnly<ColorMode> {\n        const gl = this.context.gl;\n        if (this._showOverdrawInspector) {\n            const numOverdrawSteps = 8;\n            const a = 1 / numOverdrawSteps;\n\n            return new ColorMode([gl.CONSTANT_COLOR, gl.ONE], new Color(a, a, a, 0), [true, true, true, true]);\n        } else if (this.renderPass === 'opaque') {\n            return ColorMode.unblended;\n        } else {\n            return ColorMode.alphaBlended;\n        }\n    }\n\n    depthModeForSublayer(n: number, mask: DepthMaskType, func: ?DepthFuncType): DepthMode {\n        const depth = 1 - ((1 + this.currentLayer) * this.numSublayers + n) * this.depthEpsilon;\n        return new DepthMode(func || this.context.gl.LEQUAL, mask, [depth, depth]);\n    }\n\n    render(style: Style, options: PainterOptions) {\n        this.style = style;\n        this.options = options;\n\n        this.lineAtlas = style.lineAtlas;\n        this.imageManager = style.imageManager;\n        this.glyphManager = style.glyphManager;\n\n        this.symbolFadeChange = style.placement.symbolFadeChange(browser.now());\n\n        const layerIds = this.style._order;\n        const sourceCaches = this.style.sourceCaches;\n\n        for (const id in sourceCaches) {\n            const sourceCache = sourceCaches[id];\n            if (sourceCache.used) {\n                sourceCache.prepare(this.context);\n            }\n        }\n\n        const coordsAscending: {[string]: Array<OverscaledTileID>} = {};\n        const coordsDescending: {[string]: Array<OverscaledTileID>} = {};\n        const coordsDescendingSymbol: {[string]: Array<OverscaledTileID>} = {};\n\n        for (const id in sourceCaches) {\n            const sourceCache = sourceCaches[id];\n            coordsAscending[id] = sourceCache.getVisibleCoordinates();\n            coordsDescending[id] = coordsAscending[id].slice().reverse();\n            coordsDescendingSymbol[id] = sourceCache.getVisibleCoordinates(true).reverse();\n        }\n\n        for (const id in sourceCaches) {\n            const sourceCache = sourceCaches[id];\n            const source = sourceCache.getSource();\n            if (source.type !== 'raster' && source.type !== 'raster-dem') continue;\n            const visibleTiles = [];\n            for (const coord of coordsAscending[id]) visibleTiles.push(sourceCache.getTile(coord));\n            updateTileMasks(visibleTiles, this.context);\n        }\n\n        // Offscreen pass ===============================================\n        // We first do all rendering that requires rendering to a separate\n        // framebuffer, and then save those for rendering back to the map\n        // later: in doing this we avoid doing expensive framebuffer restores.\n        this.renderPass = 'offscreen';\n        this.depthRboNeedsClear = true;\n\n        for (const layerId of layerIds) {\n            const layer = this.style._layers[layerId];\n            if (!layer.hasOffscreenPass() || layer.isHidden(this.transform.zoom)) continue;\n\n            const coords = coordsDescending[layer.source];\n            if (layer.type !== 'custom' && !coords.length) continue;\n\n            this.renderLayer(this, sourceCaches[layer.source], layer, coords);\n        }\n\n        // Rebind the main framebuffer now that all offscreen layers have been rendered:\n        this.context.bindFramebuffer.set(null);\n\n        // Clear buffers in preparation for drawing to the main framebuffer\n        this.context.clear({ color: options.showOverdrawInspector ? Color.black : Color.transparent, depth: 1 });\n\n        this._showOverdrawInspector = options.showOverdrawInspector;\n        this.depthRange = (style._order.length + 2) * this.numSublayers * this.depthEpsilon;\n\n        // Opaque pass ===============================================\n        // Draw opaque layers top-to-bottom first.\n        this.renderPass = 'opaque';\n        let prevSourceId;\n\n        for (this.currentLayer = layerIds.length - 1; this.currentLayer >= 0; this.currentLayer--) {\n            const layer = this.style._layers[layerIds[this.currentLayer]];\n            const sourceCache = sourceCaches[layer.source];\n            const coords = coordsAscending[layer.source];\n\n            if (layer.source !== prevSourceId && sourceCache) {\n                this.clearStencil();\n                if (sourceCache.getSource().isTileClipped) {\n                    this._renderTileClippingMasks(coords);\n                }\n            }\n\n            this.renderLayer(this, sourceCache, layer, coords);\n            prevSourceId = layer.source;\n        }\n\n        // Translucent pass ===============================================\n        // Draw all other layers bottom-to-top.\n        this.renderPass = 'translucent';\n\n        for (this.currentLayer = 0, prevSourceId = null; this.currentLayer < layerIds.length; this.currentLayer++) {\n            const layer = this.style._layers[layerIds[this.currentLayer]];\n            const sourceCache = sourceCaches[layer.source];\n\n            // For symbol layers in the translucent pass, we add extra tiles to the renderable set\n            // for cross-tile symbol fading. Symbol layers don't use tile clipping, so no need to render\n            // separate clipping masks\n            const coords = (layer.type === 'symbol' ? coordsDescendingSymbol : coordsDescending)[layer.source];\n\n            if (layer.source !== prevSourceId && sourceCache) {\n                this.clearStencil();\n                if (sourceCache.getSource().isTileClipped) {\n                    this._renderTileClippingMasks(coordsAscending[layer.source]);\n                }\n            }\n\n            this.renderLayer(this, sourceCache, layer, coords);\n            prevSourceId = layer.source;\n        }\n\n        if (this.options.showTileBoundaries) {\n            for (const id in sourceCaches) {\n                draw.debug(this, sourceCaches[id], coordsAscending[id]);\n                break;\n            }\n        }\n\n        this.setCustomLayerDefaults();\n    }\n\n    setupOffscreenDepthRenderbuffer(): void {\n        const context = this.context;\n        // All of the 3D textures will use the same depth renderbuffer.\n        if (!this.depthRbo) {\n            this.depthRbo = context.createRenderbuffer(context.gl.DEPTH_COMPONENT16, this.width, this.height);\n        }\n    }\n\n    renderLayer(painter: Painter, sourceCache: SourceCache, layer: StyleLayer, coords: Array<OverscaledTileID>) {\n        if (layer.isHidden(this.transform.zoom)) return;\n        if (layer.type !== 'background' && layer.type !== 'custom' && !coords.length) return;\n        this.id = layer.id;\n\n        draw[layer.type](painter, sourceCache, layer, coords);\n    }\n\n    /**\n     * Transform a matrix to incorporate the *-translate and *-translate-anchor properties into it.\n     * @param inViewportPixelUnitsUnits True when the units accepted by the matrix are in viewport pixels instead of tile units.\n     * @returns {Float32Array} matrix\n     */\n    translatePosMatrix(matrix: Float32Array, tile: Tile, translate: [number, number], translateAnchor: 'map' | 'viewport', inViewportPixelUnitsUnits?: boolean) {\n        if (!translate[0] && !translate[1]) return matrix;\n\n        const angle = inViewportPixelUnitsUnits ?\n            (translateAnchor === 'map' ? this.transform.angle : 0) :\n            (translateAnchor === 'viewport' ? -this.transform.angle : 0);\n\n        if (angle) {\n            const sinA = Math.sin(angle);\n            const cosA = Math.cos(angle);\n            translate = [\n                translate[0] * cosA - translate[1] * sinA,\n                translate[0] * sinA + translate[1] * cosA\n            ];\n        }\n\n        const translation = [\n            inViewportPixelUnitsUnits ? translate[0] : pixelsToTileUnits(tile, translate[0], this.transform.zoom),\n            inViewportPixelUnitsUnits ? translate[1] : pixelsToTileUnits(tile, translate[1], this.transform.zoom),\n            0\n        ];\n\n        const translatedMatrix = new Float32Array(16);\n        mat4.translate(translatedMatrix, matrix, translation);\n        return translatedMatrix;\n    }\n\n    saveTileTexture(texture: Texture) {\n        const textures = this._tileTextures[texture.size[0]];\n        if (!textures) {\n            this._tileTextures[texture.size[0]] = [texture];\n        } else {\n            textures.push(texture);\n        }\n    }\n\n    getTileTexture(size: number) {\n        const textures = this._tileTextures[size];\n        return textures && textures.length > 0 ? textures.pop() : null;\n    }\n\n    /**\n     * Checks whether a pattern image is needed, and if it is, whether it is not loaded.\n     *\n     * @returns true if a needed image is missing and rendering needs to be skipped.\n     */\n    isPatternMissing(image: ?CrossFaded<string>): boolean {\n        if (!image) return false;\n        const imagePosA = this.imageManager.getPattern(image.from);\n        const imagePosB = this.imageManager.getPattern(image.to);\n        return !imagePosA || !imagePosB;\n    }\n\n    useProgram(name: string, programConfiguration: ProgramConfiguration = this.emptyProgramConfiguration): Program<any> {\n        this.cache = this.cache || {};\n        const key = `${name}${programConfiguration.cacheKey || ''}${this._showOverdrawInspector ? '/overdraw' : ''}`;\n        if (!this.cache[key]) {\n            this.cache[key] = new Program(this.context, shaders[name], programConfiguration, programUniforms[name], this._showOverdrawInspector);\n        }\n        return this.cache[key];\n    }\n\n    /*\n     * Reset some GL state to default values to avoid hard-to-debug bugs\n     * in custom layers.\n     */\n    setCustomLayerDefaults() {\n        // Prevent custom layers from unintentionally modify the last VAO used.\n        // All other state is state is restored on it's own, but for VAOs it's\n        // simpler to unbind so that we don't have to track the state of VAOs.\n        this.context.unbindVAO();\n\n        // The default values for this state is meaningful and often expected.\n        // Leaving this state dirty could cause a lot of confusion for users.\n        this.context.cullFace.setDefault();\n        this.context.activeTexture.setDefault();\n        this.context.pixelStoreUnpack.setDefault();\n        this.context.pixelStoreUnpackPremultiplyAlpha.setDefault();\n        this.context.pixelStoreUnpackFlipY.setDefault();\n    }\n\n    /*\n     * Set GL state that is shared by all layers.\n     */\n    setBaseState() {\n        const gl = this.context.gl;\n        this.context.cullFace.set(false);\n        this.context.viewport.set([0, 0, this.width, this.height]);\n        this.context.blendEquation.set(gl.FUNC_ADD);\n    }\n}\n\nexport default Painter;\n","// @flow\n\nimport drawCollisionDebug from './draw_collision_debug';\n\nimport SegmentVector from '../data/segment';\nimport pixelsToTileUnits from '../source/pixels_to_tile_units';\nimport * as symbolProjection from '../symbol/projection';\nimport * as symbolSize from '../symbol/symbol_size';\nimport { mat4 } from 'gl-matrix';\nconst identityMat4 = mat4.identity(new Float32Array(16));\nimport properties from '../style/style_layer/symbol_style_layer_properties';\nconst symbolLayoutProperties = properties.layout;\nimport StencilMode from '../gl/stencil_mode';\nimport DepthMode from '../gl/depth_mode';\nimport CullFaceMode from '../gl/cull_face_mode';\nimport {\n    symbolIconUniformValues,\n    symbolSDFUniformValues\n} from './program/symbol_program';\n\nimport type Painter from './painter';\nimport type SourceCache from '../source/source_cache';\nimport type SymbolStyleLayer from '../style/style_layer/symbol_style_layer';\nimport type SymbolBucket, {SymbolBuffers} from '../data/bucket/symbol_bucket';\nimport type Texture from '../render/texture';\nimport type {OverscaledTileID} from '../source/tile_id';\nimport type {UniformValues} from './uniform_binding';\nimport type {SymbolSDFUniformsType} from '../render/program/symbol_program';\n\nexport default drawSymbols;\n\ntype SymbolTileRenderState = {\n    segments: SegmentVector,\n    sortKey: number,\n    state: {\n        program: any,\n        buffers: SymbolBuffers,\n        uniformValues: any,\n        atlasTexture: Texture,\n        atlasInterpolation: any,\n        isSDF: boolean,\n        hasHalo: boolean\n    }\n};\n\nfunction drawSymbols(painter: Painter, sourceCache: SourceCache, layer: SymbolStyleLayer, coords: Array<OverscaledTileID>) {\n    if (painter.renderPass !== 'translucent') return;\n\n    // Disable the stencil test so that labels aren't clipped to tile boundaries.\n    const stencilMode = StencilMode.disabled;\n    const colorMode = painter.colorModeForRenderPass();\n\n    if (layer.paint.get('icon-opacity').constantOr(1) !== 0) {\n        drawLayerSymbols(painter, sourceCache, layer, coords, false,\n            layer.paint.get('icon-translate'),\n            layer.paint.get('icon-translate-anchor'),\n            layer.layout.get('icon-rotation-alignment'),\n            layer.layout.get('icon-pitch-alignment'),\n            layer.layout.get('icon-keep-upright'),\n            stencilMode, colorMode\n        );\n    }\n\n    if (layer.paint.get('text-opacity').constantOr(1) !== 0) {\n        drawLayerSymbols(painter, sourceCache, layer, coords, true,\n            layer.paint.get('text-translate'),\n            layer.paint.get('text-translate-anchor'),\n            layer.layout.get('text-rotation-alignment'),\n            layer.layout.get('text-pitch-alignment'),\n            layer.layout.get('text-keep-upright'),\n            stencilMode, colorMode\n        );\n    }\n\n    if (sourceCache.map.showCollisionBoxes) {\n        drawCollisionDebug(painter, sourceCache, layer, coords);\n    }\n}\n\nfunction drawLayerSymbols(painter, sourceCache, layer, coords, isText, translate, translateAnchor,\n    rotationAlignment, pitchAlignment, keepUpright, stencilMode, colorMode) {\n\n    const context = painter.context;\n    const gl = context.gl;\n    const tr = painter.transform;\n\n    const rotateWithMap = rotationAlignment === 'map';\n    const pitchWithMap = pitchAlignment === 'map';\n    const alongLine = rotateWithMap && layer.layout.get('symbol-placement') !== 'point';\n    // Line label rotation happens in `updateLineLabels`\n    // Pitched point labels are automatically rotated by the labelPlaneMatrix projection\n    // Unpitched point labels need to have their rotation applied after projection\n    const rotateInShader = rotateWithMap && !pitchWithMap && !alongLine;\n\n    const sortFeaturesByKey = layer.layout.get('symbol-sort-key').constantOr(1) !== undefined;\n\n    const depthMode = painter.depthModeForSublayer(0, DepthMode.ReadOnly);\n\n    let program;\n    let size;\n\n    const tileRenderState: Array<SymbolTileRenderState> = [];\n\n    for (const coord of coords) {\n        const tile = sourceCache.getTile(coord);\n        const bucket: SymbolBucket = (tile.getBucket(layer): any);\n        if (!bucket) continue;\n        const buffers = isText ? bucket.text : bucket.icon;\n        if (!buffers || !buffers.segments.get().length) continue;\n        const programConfiguration = buffers.programConfigurations.get(layer.id);\n\n        const isSDF = isText || bucket.sdfIcons;\n\n        const sizeData = isText ? bucket.textSizeData : bucket.iconSizeData;\n\n        if (!program) {\n            program = painter.useProgram(isSDF ? 'symbolSDF' : 'symbolIcon', programConfiguration);\n            size = symbolSize.evaluateSizeForZoom(sizeData, tr.zoom, symbolLayoutProperties.properties[isText ? 'text-size' : 'icon-size']);\n        }\n\n        context.activeTexture.set(gl.TEXTURE0);\n\n        let texSize: [number, number];\n        let atlasTexture;\n        let atlasInterpolation;\n        if (isText) {\n            atlasTexture = tile.glyphAtlasTexture;\n            atlasInterpolation = gl.LINEAR;\n            texSize = tile.glyphAtlasTexture.size;\n\n        } else {\n            const iconScaled = layer.layout.get('icon-size').constantOr(0) !== 1 || bucket.iconsNeedLinear;\n            const iconTransformed = pitchWithMap || tr.pitch !== 0;\n\n            atlasTexture = tile.imageAtlasTexture;\n            atlasInterpolation = isSDF || painter.options.rotating || painter.options.zooming || iconScaled || iconTransformed ?\n                gl.LINEAR :\n                gl.NEAREST;\n            texSize = tile.imageAtlasTexture.size;\n        }\n\n        const s = pixelsToTileUnits(tile, 1, painter.transform.zoom);\n        const labelPlaneMatrix = symbolProjection.getLabelPlaneMatrix(coord.posMatrix, pitchWithMap, rotateWithMap, painter.transform, s);\n        const glCoordMatrix = symbolProjection.getGlCoordMatrix(coord.posMatrix, pitchWithMap, rotateWithMap, painter.transform, s);\n\n        if (alongLine) {\n            symbolProjection.updateLineLabels(bucket, coord.posMatrix, painter, isText, labelPlaneMatrix, glCoordMatrix, pitchWithMap, keepUpright);\n        }\n\n        const matrix = painter.translatePosMatrix(coord.posMatrix, tile, translate, translateAnchor),\n            uLabelPlaneMatrix = alongLine ? identityMat4 : labelPlaneMatrix,\n            uglCoordMatrix = painter.translatePosMatrix(glCoordMatrix, tile, translate, translateAnchor, true);\n\n        const hasHalo = isSDF && layer.paint.get(isText ? 'text-halo-width' : 'icon-halo-width').constantOr(1) !== 0;\n\n        let uniformValues;\n        if (isSDF) {\n            uniformValues = symbolSDFUniformValues(sizeData.functionType,\n                size, rotateInShader, pitchWithMap, painter, matrix,\n                uLabelPlaneMatrix, uglCoordMatrix, isText, texSize, true);\n\n        } else {\n            uniformValues = symbolIconUniformValues(sizeData.functionType,\n                size, rotateInShader, pitchWithMap, painter, matrix,\n                uLabelPlaneMatrix, uglCoordMatrix, isText, texSize);\n        }\n\n        const state = {\n            program,\n            buffers,\n            uniformValues,\n            atlasTexture,\n            atlasInterpolation,\n            isSDF,\n            hasHalo\n        };\n\n        if (sortFeaturesByKey) {\n            const oldSegments = buffers.segments.get();\n            for (const segment of oldSegments) {\n                tileRenderState.push({\n                    segments: new SegmentVector([segment]),\n                    sortKey: ((segment.sortKey: any): number),\n                    state\n                });\n            }\n        } else {\n            tileRenderState.push({\n                segments: buffers.segments,\n                sortKey: 0,\n                state\n            });\n        }\n    }\n\n    if (sortFeaturesByKey) {\n        tileRenderState.sort((a, b) => a.sortKey - b.sortKey);\n    }\n\n    for (const segmentState of tileRenderState) {\n        const state = segmentState.state;\n\n        state.atlasTexture.bind(state.atlasInterpolation, gl.CLAMP_TO_EDGE);\n\n        if (state.isSDF) {\n            const uniformValues = ((state.uniformValues: any): UniformValues<SymbolSDFUniformsType>);\n            if (state.hasHalo) {\n                uniformValues['u_is_halo'] = 1;\n                drawSymbolElements(state.buffers, segmentState.segments, layer, painter, state.program, depthMode, stencilMode, colorMode, uniformValues);\n            }\n            uniformValues['u_is_halo'] = 0;\n        }\n        drawSymbolElements(state.buffers, segmentState.segments, layer, painter, state.program, depthMode, stencilMode, colorMode, state.uniformValues);\n    }\n}\n\nfunction drawSymbolElements(buffers, segments, layer, painter, program, depthMode, stencilMode, colorMode, uniformValues) {\n    const context = painter.context;\n    const gl = context.gl;\n    program.draw(context, gl.TRIANGLES, depthMode, stencilMode, colorMode, CullFaceMode.disabled,\n        uniformValues, layer.id, buffers.layoutVertexBuffer,\n        buffers.indexBuffer, segments, layer.paint,\n        painter.transform.zoom, buffers.programConfigurations.get(layer.id),\n        buffers.dynamicLayoutVertexBuffer, buffers.opacityVertexBuffer);\n}\n\n","// @flow\n\nimport type Painter from './painter';\nimport type SourceCache from '../source/source_cache';\nimport type StyleLayer from '../style/style_layer';\nimport type {OverscaledTileID} from '../source/tile_id';\nimport type SymbolBucket from '../data/bucket/symbol_bucket';\nimport DepthMode from '../gl/depth_mode';\nimport StencilMode from '../gl/stencil_mode';\nimport CullFaceMode from '../gl/cull_face_mode';\nimport { collisionUniformValues } from './program/collision_program';\n\nexport default drawCollisionDebug;\n\nfunction drawCollisionDebugGeometry(painter: Painter, sourceCache: SourceCache, layer: StyleLayer, coords: Array<OverscaledTileID>, drawCircles: boolean) {\n    const context = painter.context;\n    const gl = context.gl;\n    const program = drawCircles ? painter.useProgram('collisionCircle') : painter.useProgram('collisionBox');\n\n    for (let i = 0; i < coords.length; i++) {\n        const coord = coords[i];\n        const tile = sourceCache.getTile(coord);\n        const bucket: ?SymbolBucket = (tile.getBucket(layer): any);\n        if (!bucket) continue;\n        const buffers = drawCircles ? bucket.collisionCircle : bucket.collisionBox;\n        if (!buffers) continue;\n\n        program.draw(context, drawCircles ? gl.TRIANGLES : gl.LINES,\n            DepthMode.disabled, StencilMode.disabled,\n            painter.colorModeForRenderPass(),\n            CullFaceMode.disabled,\n            collisionUniformValues(\n                coord.posMatrix,\n                painter.transform,\n                tile),\n            layer.id, buffers.layoutVertexBuffer, buffers.indexBuffer,\n            buffers.segments, null, painter.transform.zoom, null, null,\n            buffers.collisionVertexBuffer);\n    }\n}\n\nfunction drawCollisionDebug(painter: Painter, sourceCache: SourceCache, layer: StyleLayer, coords: Array<OverscaledTileID>) {\n    drawCollisionDebugGeometry(painter, sourceCache, layer, coords, false);\n    drawCollisionDebugGeometry(painter, sourceCache, layer, coords, true);\n}\n","// @flow\n\nimport StencilMode from '../gl/stencil_mode';\nimport DepthMode from '../gl/depth_mode';\nimport CullFaceMode from '../gl/cull_face_mode';\nimport { circleUniformValues } from './program/circle_program';\n\nimport type Painter from './painter';\nimport type SourceCache from '../source/source_cache';\nimport type CircleStyleLayer from '../style/style_layer/circle_style_layer';\nimport type CircleBucket from '../data/bucket/circle_bucket';\nimport type {OverscaledTileID} from '../source/tile_id';\n\nexport default drawCircles;\n\nfunction drawCircles(painter: Painter, sourceCache: SourceCache, layer: CircleStyleLayer, coords: Array<OverscaledTileID>) {\n    if (painter.renderPass !== 'translucent') return;\n\n    const opacity = layer.paint.get('circle-opacity');\n    const strokeWidth = layer.paint.get('circle-stroke-width');\n    const strokeOpacity = layer.paint.get('circle-stroke-opacity');\n\n    if (opacity.constantOr(1) === 0 && (strokeWidth.constantOr(1) === 0 || strokeOpacity.constantOr(1) === 0)) {\n        return;\n    }\n\n    const context = painter.context;\n    const gl = context.gl;\n\n    const depthMode = painter.depthModeForSublayer(0, DepthMode.ReadOnly);\n    // Turn off stencil testing to allow circles to be drawn across boundaries,\n    // so that large circles are not clipped to tiles\n    const stencilMode = StencilMode.disabled;\n    const colorMode = painter.colorModeForRenderPass();\n\n    for (let i = 0; i < coords.length; i++) {\n        const coord = coords[i];\n\n        const tile = sourceCache.getTile(coord);\n        const bucket: ?CircleBucket<*> = (tile.getBucket(layer): any);\n        if (!bucket) continue;\n\n        const programConfiguration = bucket.programConfigurations.get(layer.id);\n        const program = painter.useProgram('circle', programConfiguration);\n\n        program.draw(context, gl.TRIANGLES, depthMode, stencilMode, colorMode, CullFaceMode.disabled,\n            circleUniformValues(painter, coord, tile, layer), layer.id,\n            bucket.layoutVertexBuffer, bucket.indexBuffer, bucket.segments,\n            layer.paint, painter.transform.zoom, programConfiguration);\n    }\n}\n","// @flow\n\nimport Texture from './texture';\nimport Color from '../style-spec/util/color';\nimport DepthMode from '../gl/depth_mode';\nimport StencilMode from '../gl/stencil_mode';\nimport ColorMode from '../gl/color_mode';\nimport CullFaceMode from '../gl/cull_face_mode';\nimport {\n    heatmapUniformValues,\n    heatmapTextureUniformValues\n} from './program/heatmap_program';\n\nimport type Painter from './painter';\nimport type SourceCache from '../source/source_cache';\nimport type HeatmapStyleLayer from '../style/style_layer/heatmap_style_layer';\nimport type HeatmapBucket from '../data/bucket/heatmap_bucket';\nimport type {OverscaledTileID} from '../source/tile_id';\n\nexport default drawHeatmap;\n\nfunction drawHeatmap(painter: Painter, sourceCache: SourceCache, layer: HeatmapStyleLayer, coords: Array<OverscaledTileID>) {\n    if (layer.paint.get('heatmap-opacity') === 0) {\n        return;\n    }\n\n    if (painter.renderPass === 'offscreen') {\n        const context = painter.context;\n        const gl = context.gl;\n\n        const depthMode = painter.depthModeForSublayer(0, DepthMode.ReadOnly);\n        // Allow kernels to be drawn across boundaries, so that\n        // large kernels are not clipped to tiles\n        const stencilMode = StencilMode.disabled;\n        // Turn on additive blending for kernels, which is a key aspect of kernel density estimation formula\n        const colorMode = new ColorMode([gl.ONE, gl.ONE], Color.transparent, [true, true, true, true]);\n\n        bindFramebuffer(context, painter, layer);\n\n        context.clear({ color: Color.transparent });\n\n        for (let i = 0; i < coords.length; i++) {\n            const coord = coords[i];\n\n            // Skip tiles that have uncovered parents to avoid flickering; we don't need\n            // to use complex tile masking here because the change between zoom levels is subtle,\n            // so it's fine to simply render the parent until all its 4 children are loaded\n            if (sourceCache.hasRenderableParent(coord)) continue;\n\n            const tile = sourceCache.getTile(coord);\n            const bucket: ?HeatmapBucket = (tile.getBucket(layer): any);\n            if (!bucket) continue;\n\n            const programConfiguration = bucket.programConfigurations.get(layer.id);\n            const program = painter.useProgram('heatmap', programConfiguration);\n            const {zoom} = painter.transform;\n\n            program.draw(context, gl.TRIANGLES, depthMode, stencilMode, colorMode, CullFaceMode.disabled,\n                heatmapUniformValues(coord.posMatrix,\n                    tile, zoom, layer.paint.get('heatmap-intensity')),\n                layer.id, bucket.layoutVertexBuffer, bucket.indexBuffer,\n                bucket.segments, layer.paint, painter.transform.zoom,\n                programConfiguration);\n        }\n\n        context.viewport.set([0, 0, painter.width, painter.height]);\n\n    } else if (painter.renderPass === 'translucent') {\n        painter.context.setColorMode(painter.colorModeForRenderPass());\n        renderTextureToMap(painter, layer);\n    }\n}\n\nfunction bindFramebuffer(context, painter, layer) {\n    const gl = context.gl;\n    context.activeTexture.set(gl.TEXTURE1);\n\n    // Use a 4x downscaled screen texture for better performance\n    context.viewport.set([0, 0, painter.width / 4, painter.height / 4]);\n\n    let fbo = layer.heatmapFbo;\n\n    if (!fbo) {\n        const texture = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\n        fbo = layer.heatmapFbo = context.createFramebuffer(painter.width / 4, painter.height / 4);\n\n        bindTextureToFramebuffer(context, painter, texture, fbo);\n\n    } else {\n        gl.bindTexture(gl.TEXTURE_2D, fbo.colorAttachment.get());\n        context.bindFramebuffer.set(fbo.framebuffer);\n    }\n}\n\nfunction bindTextureToFramebuffer(context, painter, texture, fbo) {\n    const gl = context.gl;\n    // Use the higher precision half-float texture where available (producing much smoother looking heatmaps);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, painter.width / 4, painter.height / 4, 0, gl.RGBA,\n        context.extTextureHalfFloat ? context.extTextureHalfFloat.HALF_FLOAT_OES : gl.UNSIGNED_BYTE, null);\n\n    fbo.colorAttachment.set(texture);\n\n    // If using half-float texture as a render target is not supported, fall back to a low precision texture\n    if (context.extTextureHalfFloat && gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {\n        context.extTextureHalfFloat = null;\n        fbo.colorAttachment.setDirty();\n        bindTextureToFramebuffer(context, painter, texture, fbo);\n    }\n}\n\nfunction renderTextureToMap(painter, layer) {\n    const context = painter.context;\n    const gl = context.gl;\n\n    // Here we bind two different textures from which we'll sample in drawing\n    // heatmaps: the kernel texture, prepared in the offscreen pass, and a\n    // color ramp texture.\n    const fbo = layer.heatmapFbo;\n    if (!fbo) return;\n    context.activeTexture.set(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, fbo.colorAttachment.get());\n\n    context.activeTexture.set(gl.TEXTURE1);\n    let colorRampTexture = layer.colorRampTexture;\n    if (!colorRampTexture) {\n        colorRampTexture = layer.colorRampTexture = new Texture(context, layer.colorRamp, gl.RGBA);\n    }\n    colorRampTexture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE);\n\n    painter.useProgram('heatmapTexture').draw(context, gl.TRIANGLES,\n        DepthMode.disabled, StencilMode.disabled, painter.colorModeForRenderPass(), CullFaceMode.disabled,\n        heatmapTextureUniformValues(painter, layer, 0, 1),\n        layer.id, painter.viewportBuffer, painter.quadTriangleIndexBuffer,\n        painter.viewportSegments, layer.paint, painter.transform.zoom);\n}\n","// @flow\n\nimport DepthMode from '../gl/depth_mode';\nimport CullFaceMode from '../gl/cull_face_mode';\nimport Texture from './texture';\nimport {\n    lineUniformValues,\n    linePatternUniformValues,\n    lineSDFUniformValues,\n    lineGradientUniformValues\n} from './program/line_program';\n\nimport type Painter from './painter';\nimport type SourceCache from '../source/source_cache';\nimport type LineStyleLayer from '../style/style_layer/line_style_layer';\nimport type LineBucket from '../data/bucket/line_bucket';\nimport type {OverscaledTileID} from '../source/tile_id';\n\nexport default function drawLine(painter: Painter, sourceCache: SourceCache, layer: LineStyleLayer, coords: Array<OverscaledTileID>) {\n    if (painter.renderPass !== 'translucent') return;\n\n    const opacity = layer.paint.get('line-opacity');\n    const width = layer.paint.get('line-width');\n    if (opacity.constantOr(1) === 0 || width.constantOr(1) === 0) return;\n\n    const depthMode = painter.depthModeForSublayer(0, DepthMode.ReadOnly);\n    const colorMode = painter.colorModeForRenderPass();\n\n    const dasharray = layer.paint.get('line-dasharray');\n    const patternProperty = layer.paint.get('line-pattern');\n    const image = patternProperty.constantOr((1: any));\n\n    const gradient = layer.paint.get('line-gradient');\n    const crossfade = layer.getCrossfadeParameters();\n\n    const programId =\n        dasharray ? 'lineSDF' :\n        image ? 'linePattern' :\n        gradient ? 'lineGradient' : 'line';\n\n    const context = painter.context;\n    const gl = context.gl;\n\n    let firstTile = true;\n\n    if (gradient) {\n        context.activeTexture.set(gl.TEXTURE0);\n\n        let gradientTexture = layer.gradientTexture;\n        if (!layer.gradient) return;\n        if (!gradientTexture) gradientTexture = layer.gradientTexture = new Texture(context, layer.gradient, gl.RGBA);\n        gradientTexture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE);\n    }\n\n    for (const coord of coords) {\n        const tile = sourceCache.getTile(coord);\n\n        if (image && !tile.patternsLoaded()) continue;\n\n        const bucket: ?LineBucket = (tile.getBucket(layer): any);\n        if (!bucket) continue;\n\n        const programConfiguration = bucket.programConfigurations.get(layer.id);\n        const prevProgram = painter.context.program.get();\n        const program = painter.useProgram(programId, programConfiguration);\n        const programChanged = firstTile || program.program !== prevProgram;\n\n        const constantPattern = patternProperty.constantOr(null);\n        if (constantPattern && tile.imageAtlas) {\n            const posTo = tile.imageAtlas.patternPositions[constantPattern.to];\n            const posFrom = tile.imageAtlas.patternPositions[constantPattern.from];\n            if (posTo && posFrom) programConfiguration.setConstantPatternPositions(posTo, posFrom);\n        }\n\n        const uniformValues = dasharray ? lineSDFUniformValues(painter, tile, layer, dasharray, crossfade) :\n            image ? linePatternUniformValues(painter, tile, layer, crossfade) :\n            gradient ? lineGradientUniformValues(painter, tile, layer) :\n            lineUniformValues(painter, tile, layer);\n\n        if (dasharray && (programChanged || painter.lineAtlas.dirty)) {\n            context.activeTexture.set(gl.TEXTURE0);\n            painter.lineAtlas.bind(context);\n        } else if (image) {\n            context.activeTexture.set(gl.TEXTURE0);\n            tile.imageAtlasTexture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE);\n            programConfiguration.updatePatternPaintBuffers(crossfade);\n        }\n\n        program.draw(context, gl.TRIANGLES, depthMode,\n            painter.stencilModeForClipping(coord), colorMode, CullFaceMode.disabled, uniformValues,\n            layer.id, bucket.layoutVertexBuffer, bucket.indexBuffer, bucket.segments,\n            layer.paint, painter.transform.zoom, programConfiguration);\n\n        firstTile = false;\n        // once refactored so that bound texture state is managed, we'll also be able to remove this firstTile/programChanged logic\n    }\n}\n","import { __awaiter, __extends, __generator } from \"tslib\";\nimport { WebPlugin } from './index';\nimport { FilesystemDirectory } from '../core-plugin-definitions';\nvar FilesystemPluginWeb = /** @class */ (function (_super) {\n    __extends(FilesystemPluginWeb, _super);\n    function FilesystemPluginWeb() {\n        var _this = _super.call(this, {\n            name: 'Filesystem',\n            platforms: ['web']\n        }) || this;\n        _this.DEFAULT_DIRECTORY = FilesystemDirectory.Data;\n        _this.DB_VERSION = 1;\n        _this.DB_NAME = 'Disc';\n        _this._writeCmds = ['add', 'put', 'delete'];\n        return _this;\n    }\n    FilesystemPluginWeb.prototype.initDb = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n                if (this._db !== undefined) {\n                    return [2 /*return*/, this._db];\n                }\n                if (!('indexedDB' in window)) {\n                    throw new Error('This browser doesn\\'t support IndexedDB');\n                }\n                return [2 /*return*/, new Promise(function (resolve, reject) {\n                        var request = indexedDB.open(_this.DB_NAME, _this.DB_VERSION);\n                        request.onupgradeneeded = FilesystemPluginWeb.doUpgrade;\n                        request.onsuccess = function () {\n                            _this._db = request.result;\n                            resolve(request.result);\n                        };\n                        request.onerror = function () { return reject(request.error); };\n                        request.onblocked = function () {\n                            console.warn('db blocked');\n                        };\n                    })];\n            });\n        });\n    };\n    FilesystemPluginWeb.doUpgrade = function (event) {\n        var eventTarget = event.target;\n        var db = eventTarget.result;\n        switch (event.oldVersion) {\n            case 0:\n            case 1:\n            default:\n                if (db.objectStoreNames.contains('FileStorage')) {\n                    db.deleteObjectStore('FileStorage');\n                }\n                var store = db.createObjectStore('FileStorage', { keyPath: 'path' });\n                store.createIndex('by_folder', 'folder');\n        }\n    };\n    FilesystemPluginWeb.prototype.dbRequest = function (cmd, args) {\n        return __awaiter(this, void 0, void 0, function () {\n            var readFlag;\n            return __generator(this, function (_a) {\n                readFlag = this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n                return [2 /*return*/, this.initDb()\n                        .then(function (conn) {\n                        return new Promise(function (resolve, reject) {\n                            var tx = conn.transaction(['FileStorage'], readFlag);\n                            var store = tx.objectStore('FileStorage');\n                            var req = store[cmd].apply(store, args);\n                            req.onsuccess = function () { return resolve(req.result); };\n                            req.onerror = function () { return reject(req.error); };\n                        });\n                    })];\n            });\n        });\n    };\n    FilesystemPluginWeb.prototype.dbIndexRequest = function (indexName, cmd, args) {\n        return __awaiter(this, void 0, void 0, function () {\n            var readFlag;\n            return __generator(this, function (_a) {\n                readFlag = this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n                return [2 /*return*/, this.initDb()\n                        .then(function (conn) {\n                        return new Promise(function (resolve, reject) {\n                            var tx = conn.transaction(['FileStorage'], readFlag);\n                            var store = tx.objectStore('FileStorage');\n                            var index = store.index(indexName);\n                            var req = index[cmd].apply(index, args);\n                            req.onsuccess = function () { return resolve(req.result); };\n                            req.onerror = function () { return reject(req.error); };\n                        });\n                    })];\n            });\n        });\n    };\n    FilesystemPluginWeb.prototype.getPath = function (directory, uriPath) {\n        directory = directory || this.DEFAULT_DIRECTORY;\n        var cleanedUriPath = uriPath !== undefined ? uriPath.replace(/^[/]+|[/]+$/g, '') : '';\n        var fsPath = '/' + directory;\n        if (uriPath !== '')\n            fsPath += '/' + cleanedUriPath;\n        return fsPath;\n    };\n    FilesystemPluginWeb.prototype.clear = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var conn, tx, store;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.initDb()];\n                    case 1:\n                        conn = _a.sent();\n                        tx = conn.transaction(['FileStorage'], 'readwrite');\n                        store = tx.objectStore('FileStorage');\n                        store.clear();\n                        return [2 /*return*/, {}];\n                }\n            });\n        });\n    };\n    /**\n     * Read a file from disk\n     * @param options options for the file read\n     * @return a promise that resolves with the read file data result\n     */\n    FilesystemPluginWeb.prototype.readFile = function (options) {\n        return __awaiter(this, void 0, void 0, function () {\n            var path, entry;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        path = this.getPath(options.directory, options.path);\n                        return [4 /*yield*/, this.dbRequest('get', [path])];\n                    case 1:\n                        entry = _a.sent();\n                        if (entry === undefined)\n                            throw Error('File does not exist.');\n                        return [2 /*return*/, { data: entry.content }];\n                }\n            });\n        });\n    };\n    /**\n     * Write a file to disk in the specified location on device\n     * @param options options for the file write\n     * @return a promise that resolves with the file write result\n     */\n    FilesystemPluginWeb.prototype.writeFile = function (options) {\n        return __awaiter(this, void 0, void 0, function () {\n            var path, data, doRecursive, occupiedEntry, encoding, parentPath, parentEntry, subDirIndex, parentArgPath, now, pathObj;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        path = this.getPath(options.directory, options.path);\n                        data = options.data;\n                        doRecursive = options.recursive;\n                        return [4 /*yield*/, this.dbRequest('get', [path])];\n                    case 1:\n                        occupiedEntry = _a.sent();\n                        if (occupiedEntry && occupiedEntry.type === 'directory')\n                            throw ('The supplied path is a directory.');\n                        encoding = options.encoding;\n                        parentPath = path.substr(0, path.lastIndexOf('/'));\n                        return [4 /*yield*/, this.dbRequest('get', [parentPath])];\n                    case 2:\n                        parentEntry = _a.sent();\n                        if (!(parentEntry === undefined)) return [3 /*break*/, 4];\n                        subDirIndex = parentPath.indexOf('/', 1);\n                        if (!(subDirIndex !== -1)) return [3 /*break*/, 4];\n                        parentArgPath = parentPath.substr(subDirIndex);\n                        return [4 /*yield*/, this.mkdir({ path: parentArgPath, directory: options.directory, recursive: doRecursive })];\n                    case 3:\n                        _a.sent();\n                        _a.label = 4;\n                    case 4:\n                        now = Date.now();\n                        pathObj = {\n                            path: path,\n                            folder: parentPath,\n                            type: 'file',\n                            size: data.length,\n                            ctime: now,\n                            mtime: now,\n                            content: !encoding && data.indexOf(',') >= 0 ? data.split(',')[1] : data,\n                        };\n                        return [4 /*yield*/, this.dbRequest('put', [pathObj])];\n                    case 5:\n                        _a.sent();\n                        return [2 /*return*/, {\n                                uri: pathObj.path\n                            }];\n                }\n            });\n        });\n    };\n    /**\n     * Append to a file on disk in the specified location on device\n     * @param options options for the file append\n     * @return a promise that resolves with the file write result\n     */\n    FilesystemPluginWeb.prototype.appendFile = function (options) {\n        return __awaiter(this, void 0, void 0, function () {\n            var path, data, parentPath, now, ctime, occupiedEntry, parentEntry, parentArgPathIndex, parentArgPath, pathObj;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        path = this.getPath(options.directory, options.path);\n                        data = options.data;\n                        parentPath = path.substr(0, path.lastIndexOf('/'));\n                        now = Date.now();\n                        ctime = now;\n                        return [4 /*yield*/, this.dbRequest('get', [path])];\n                    case 1:\n                        occupiedEntry = _a.sent();\n                        if (occupiedEntry && occupiedEntry.type === 'directory')\n                            throw ('The supplied path is a directory.');\n                        return [4 /*yield*/, this.dbRequest('get', [parentPath])];\n                    case 2:\n                        parentEntry = _a.sent();\n                        if (!(parentEntry === undefined)) return [3 /*break*/, 4];\n                        parentArgPathIndex = parentPath.indexOf('/', 1);\n                        parentArgPath = parentArgPathIndex !== -1 ? parentPath.substr(parentArgPathIndex) : '/';\n                        return [4 /*yield*/, this.mkdir({ path: parentArgPath, directory: options.directory, recursive: true })];\n                    case 3:\n                        _a.sent();\n                        _a.label = 4;\n                    case 4:\n                        if (occupiedEntry !== undefined) {\n                            data = occupiedEntry.content + data;\n                            ctime = occupiedEntry.ctime;\n                        }\n                        pathObj = {\n                            path: path,\n                            folder: parentPath,\n                            type: 'file',\n                            size: data.length,\n                            ctime: ctime,\n                            mtime: now,\n                            content: data\n                        };\n                        return [4 /*yield*/, this.dbRequest('put', [pathObj])];\n                    case 5:\n                        _a.sent();\n                        return [2 /*return*/, {}];\n                }\n            });\n        });\n    };\n    /**\n     * Delete a file from disk\n     * @param options options for the file delete\n     * @return a promise that resolves with the deleted file data result\n     */\n    FilesystemPluginWeb.prototype.deleteFile = function (options) {\n        return __awaiter(this, void 0, void 0, function () {\n            var path, entry, entries;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        path = this.getPath(options.directory, options.path);\n                        return [4 /*yield*/, this.dbRequest('get', [path])];\n                    case 1:\n                        entry = _a.sent();\n                        if (entry === undefined)\n                            throw Error('File does not exist.');\n                        return [4 /*yield*/, this.dbIndexRequest('by_folder', 'getAllKeys', [IDBKeyRange.only(path)])];\n                    case 2:\n                        entries = _a.sent();\n                        if (entries.length !== 0)\n                            throw Error('Folder is not empty.');\n                        return [4 /*yield*/, this.dbRequest('delete', [path])];\n                    case 3:\n                        _a.sent();\n                        return [2 /*return*/, {}];\n                }\n            });\n        });\n    };\n    /**\n     * Create a directory.\n     * @param options options for the mkdir\n     * @return a promise that resolves with the mkdir result\n     */\n    FilesystemPluginWeb.prototype.mkdir = function (options) {\n        return __awaiter(this, void 0, void 0, function () {\n            var path, doRecursive, parentPath, depth, parentEntry, occupiedEntry, parentArgPath, now, pathObj;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        path = this.getPath(options.directory, options.path);\n                        doRecursive = options.recursive;\n                        parentPath = path.substr(0, path.lastIndexOf('/'));\n                        depth = (path.match(/\\//g) || []).length;\n                        return [4 /*yield*/, this.dbRequest('get', [parentPath])];\n                    case 1:\n                        parentEntry = _a.sent();\n                        return [4 /*yield*/, this.dbRequest('get', [path])];\n                    case 2:\n                        occupiedEntry = _a.sent();\n                        if (depth === 1)\n                            throw Error('Cannot create Root directory');\n                        if (occupiedEntry !== undefined)\n                            throw Error('Current directory does already exist.');\n                        if (!doRecursive && depth !== 2 && parentEntry === undefined)\n                            throw Error('Parent directory must exist');\n                        if (!(doRecursive && depth !== 2 && parentEntry === undefined)) return [3 /*break*/, 4];\n                        parentArgPath = parentPath.substr(parentPath.indexOf('/', 1));\n                        return [4 /*yield*/, this.mkdir({\n                                path: parentArgPath,\n                                directory: options.directory,\n                                recursive: doRecursive\n                            })];\n                    case 3:\n                        _a.sent();\n                        _a.label = 4;\n                    case 4:\n                        now = Date.now();\n                        pathObj = { path: path, folder: parentPath, type: 'directory', size: 0, ctime: now, mtime: now };\n                        return [4 /*yield*/, this.dbRequest('put', [pathObj])];\n                    case 5:\n                        _a.sent();\n                        return [2 /*return*/, {}];\n                }\n            });\n        });\n    };\n    /**\n     * Remove a directory\n     * @param options the options for the directory remove\n     */\n    FilesystemPluginWeb.prototype.rmdir = function (options) {\n        return __awaiter(this, void 0, void 0, function () {\n            var path, directory, recursive, fullPath, entry, readDirResult, _i, _a, entry_1, entryPath, entryObj;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        path = options.path, directory = options.directory, recursive = options.recursive;\n                        fullPath = this.getPath(directory, path);\n                        return [4 /*yield*/, this.dbRequest('get', [fullPath])];\n                    case 1:\n                        entry = _b.sent();\n                        if (entry === undefined)\n                            throw Error('Folder does not exist.');\n                        if (entry.type !== 'directory')\n                            throw Error('Requested path is not a directory');\n                        return [4 /*yield*/, this.readdir({ path: path, directory: directory })];\n                    case 2:\n                        readDirResult = _b.sent();\n                        if (readDirResult.files.length !== 0 && !recursive)\n                            throw Error('Folder is not empty');\n                        _i = 0, _a = readDirResult.files;\n                        _b.label = 3;\n                    case 3:\n                        if (!(_i < _a.length)) return [3 /*break*/, 9];\n                        entry_1 = _a[_i];\n                        entryPath = path + \"/\" + entry_1;\n                        return [4 /*yield*/, this.stat({ path: entryPath, directory: directory })];\n                    case 4:\n                        entryObj = _b.sent();\n                        if (!(entryObj.type === 'file')) return [3 /*break*/, 6];\n                        return [4 /*yield*/, this.deleteFile({ path: entryPath, directory: directory })];\n                    case 5:\n                        _b.sent();\n                        return [3 /*break*/, 8];\n                    case 6: return [4 /*yield*/, this.rmdir({ path: entryPath, directory: directory, recursive: recursive })];\n                    case 7:\n                        _b.sent();\n                        _b.label = 8;\n                    case 8:\n                        _i++;\n                        return [3 /*break*/, 3];\n                    case 9: return [4 /*yield*/, this.dbRequest('delete', [fullPath])];\n                    case 10:\n                        _b.sent();\n                        return [2 /*return*/, {}];\n                }\n            });\n        });\n    };\n    /**\n     * Return a list of files from the directory (not recursive)\n     * @param options the options for the readdir operation\n     * @return a promise that resolves with the readdir directory listing result\n     */\n    FilesystemPluginWeb.prototype.readdir = function (options) {\n        return __awaiter(this, void 0, void 0, function () {\n            var path, entry, entries, names;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        path = this.getPath(options.directory, options.path);\n                        return [4 /*yield*/, this.dbRequest('get', [path])];\n                    case 1:\n                        entry = _a.sent();\n                        if (options.path !== '' && entry === undefined)\n                            throw Error('Folder does not exist.');\n                        return [4 /*yield*/, this.dbIndexRequest('by_folder', 'getAllKeys', [IDBKeyRange.only(path)])];\n                    case 2:\n                        entries = _a.sent();\n                        names = entries.map(function (e) {\n                            return e.substring(path.length + 1);\n                        });\n                        return [2 /*return*/, { files: names }];\n                }\n            });\n        });\n    };\n    /**\n     * Return full File URI for a path and directory\n     * @param options the options for the stat operation\n     * @return a promise that resolves with the file stat result\n     */\n    FilesystemPluginWeb.prototype.getUri = function (options) {\n        return __awaiter(this, void 0, void 0, function () {\n            var path, entry;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        path = this.getPath(options.directory, options.path);\n                        return [4 /*yield*/, this.dbRequest('get', [path])];\n                    case 1:\n                        entry = _a.sent();\n                        if (!(entry === undefined)) return [3 /*break*/, 3];\n                        return [4 /*yield*/, this.dbRequest('get', [path + '/'])];\n                    case 2:\n                        entry = (_a.sent());\n                        _a.label = 3;\n                    case 3:\n                        if (entry === undefined)\n                            throw Error('Entry does not exist.');\n                        return [2 /*return*/, {\n                                uri: entry.path\n                            }];\n                }\n            });\n        });\n    };\n    /**\n     * Return data about a file\n     * @param options the options for the stat operation\n     * @return a promise that resolves with the file stat result\n     */\n    FilesystemPluginWeb.prototype.stat = function (options) {\n        return __awaiter(this, void 0, void 0, function () {\n            var path, entry;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        path = this.getPath(options.directory, options.path);\n                        return [4 /*yield*/, this.dbRequest('get', [path])];\n                    case 1:\n                        entry = _a.sent();\n                        if (!(entry === undefined)) return [3 /*break*/, 3];\n                        return [4 /*yield*/, this.dbRequest('get', [path + '/'])];\n                    case 2:\n                        entry = (_a.sent());\n                        _a.label = 3;\n                    case 3:\n                        if (entry === undefined)\n                            throw Error('Entry does not exist.');\n                        return [2 /*return*/, {\n                                type: entry.type,\n                                size: entry.size,\n                                ctime: entry.ctime,\n                                mtime: entry.mtime,\n                                uri: entry.path\n                            }];\n                }\n            });\n        });\n    };\n    /**\n     * Rename a file or directory\n     * @param options the options for the rename operation\n     * @return a promise that resolves with the rename result\n     */\n    FilesystemPluginWeb.prototype.rename = function (options) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this._copy(options, true)];\n            });\n        });\n    };\n    /**\n     * Copy a file or directory\n     * @param options the options for the copy operation\n     * @return a promise that resolves with the copy result\n     */\n    FilesystemPluginWeb.prototype.copy = function (options) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this._copy(options, false)];\n            });\n        });\n    };\n    /**\n     * Function that can perform a copy or a rename\n     * @param options the options for the rename operation\n     * @param doRename whether to perform a rename or copy operation\n     * @return a promise that resolves with the result\n     */\n    FilesystemPluginWeb.prototype._copy = function (options, doRename) {\n        if (doRename === void 0) { doRename = false; }\n        return __awaiter(this, void 0, void 0, function () {\n            var to, from, fromDirectory, toDirectory, fromPath, toPath, toObj, e_1, toPathComponents, toPath_1, toParentDirectory, fromObj, updateTime, _a, file, e_2, contents, _i, contents_1, filename;\n            var _this = this;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        to = options.to, from = options.from, fromDirectory = options.directory, toDirectory = options.toDirectory;\n                        if (!to || !from) {\n                            throw Error('Both to and from must be provided');\n                        }\n                        // If no \"to\" directory is provided, use the \"from\" directory\n                        if (!toDirectory) {\n                            toDirectory = fromDirectory;\n                        }\n                        fromPath = this.getPath(fromDirectory, from);\n                        toPath = this.getPath(toDirectory, to);\n                        // Test that the \"to\" and \"from\" locations are different\n                        if (fromPath === toPath) {\n                            return [2 /*return*/, {}];\n                        }\n                        if (toPath.startsWith(fromPath)) {\n                            throw Error('To path cannot contain the from path');\n                        }\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([1, 3, , 6]);\n                        return [4 /*yield*/, this.stat({\n                                path: to,\n                                directory: toDirectory\n                            })];\n                    case 2:\n                        toObj = _b.sent();\n                        return [3 /*break*/, 6];\n                    case 3:\n                        e_1 = _b.sent();\n                        toPathComponents = to.split('/');\n                        toPathComponents.pop();\n                        toPath_1 = toPathComponents.join('/');\n                        if (!(toPathComponents.length > 0)) return [3 /*break*/, 5];\n                        return [4 /*yield*/, this.stat({\n                                path: toPath_1,\n                                directory: toDirectory,\n                            })];\n                    case 4:\n                        toParentDirectory = _b.sent();\n                        if (toParentDirectory.type !== 'directory') {\n                            throw new Error('Parent directory of the to path is a file');\n                        }\n                        _b.label = 5;\n                    case 5: return [3 /*break*/, 6];\n                    case 6:\n                        // Cannot overwrite a directory\n                        if (toObj && toObj.type === 'directory') {\n                            throw new Error('Cannot overwrite a directory with a file');\n                        }\n                        return [4 /*yield*/, this.stat({\n                                path: from,\n                                directory: fromDirectory,\n                            })];\n                    case 7:\n                        fromObj = _b.sent();\n                        updateTime = function (path, ctime, mtime) { return __awaiter(_this, void 0, void 0, function () {\n                            var fullPath, entry;\n                            return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                    case 0:\n                                        fullPath = this.getPath(toDirectory, path);\n                                        return [4 /*yield*/, this.dbRequest('get', [fullPath])];\n                                    case 1:\n                                        entry = _a.sent();\n                                        entry.ctime = ctime;\n                                        entry.mtime = mtime;\n                                        return [4 /*yield*/, this.dbRequest('put', [entry])];\n                                    case 2:\n                                        _a.sent();\n                                        return [2 /*return*/];\n                                }\n                            });\n                        }); };\n                        _a = fromObj.type;\n                        switch (_a) {\n                            case 'file': return [3 /*break*/, 8];\n                            case 'directory': return [3 /*break*/, 15];\n                        }\n                        return [3 /*break*/, 28];\n                    case 8: return [4 /*yield*/, this.readFile({\n                            path: from,\n                            directory: fromDirectory\n                        })];\n                    case 9:\n                        file = _b.sent();\n                        if (!doRename) return [3 /*break*/, 11];\n                        return [4 /*yield*/, this.deleteFile({\n                                path: from,\n                                directory: fromDirectory\n                            })];\n                    case 10:\n                        _b.sent();\n                        _b.label = 11;\n                    case 11: \n                    // Write the file to the new location\n                    return [4 /*yield*/, this.writeFile({\n                            path: to,\n                            directory: toDirectory,\n                            data: file.data\n                        })];\n                    case 12:\n                        // Write the file to the new location\n                        _b.sent();\n                        if (!doRename) return [3 /*break*/, 14];\n                        return [4 /*yield*/, updateTime(to, fromObj.ctime, fromObj.mtime)];\n                    case 13:\n                        _b.sent();\n                        _b.label = 14;\n                    case 14: \n                    // Resolve promise\n                    return [2 /*return*/, {}];\n                    case 15:\n                        if (toObj) {\n                            throw Error('Cannot move a directory over an existing object');\n                        }\n                        _b.label = 16;\n                    case 16:\n                        _b.trys.push([16, 20, , 21]);\n                        // Create the to directory\n                        return [4 /*yield*/, this.mkdir({\n                                path: to,\n                                directory: toDirectory,\n                                recursive: false,\n                            })];\n                    case 17:\n                        // Create the to directory\n                        _b.sent();\n                        if (!doRename) return [3 /*break*/, 19];\n                        return [4 /*yield*/, updateTime(to, fromObj.ctime, fromObj.mtime)];\n                    case 18:\n                        _b.sent();\n                        _b.label = 19;\n                    case 19: return [3 /*break*/, 21];\n                    case 20:\n                        e_2 = _b.sent();\n                        return [3 /*break*/, 21];\n                    case 21: return [4 /*yield*/, this.readdir({\n                            path: from,\n                            directory: fromDirectory,\n                        })];\n                    case 22:\n                        contents = (_b.sent()).files;\n                        _i = 0, contents_1 = contents;\n                        _b.label = 23;\n                    case 23:\n                        if (!(_i < contents_1.length)) return [3 /*break*/, 26];\n                        filename = contents_1[_i];\n                        // Move item from the from directory to the to directory\n                        return [4 /*yield*/, this._copy({\n                                from: from + \"/\" + filename,\n                                to: to + \"/\" + filename,\n                                directory: fromDirectory,\n                                toDirectory: toDirectory,\n                            }, doRename)];\n                    case 24:\n                        // Move item from the from directory to the to directory\n                        _b.sent();\n                        _b.label = 25;\n                    case 25:\n                        _i++;\n                        return [3 /*break*/, 23];\n                    case 26:\n                        if (!doRename) return [3 /*break*/, 28];\n                        return [4 /*yield*/, this.rmdir({\n                                path: from,\n                                directory: fromDirectory\n                            })];\n                    case 27:\n                        _b.sent();\n                        _b.label = 28;\n                    case 28: return [2 /*return*/, {}];\n                }\n            });\n        });\n    };\n    FilesystemPluginWeb._debug = true;\n    return FilesystemPluginWeb;\n}(WebPlugin));\nexport { FilesystemPluginWeb };\nvar Filesystem = new FilesystemPluginWeb();\nexport { Filesystem };\n//# sourceMappingURL=filesystem.js.map","import { __extends } from \"tslib\";\nimport { WebPlugin } from './index';\nvar AccessibilityPluginWeb = /** @class */ (function (_super) {\n    __extends(AccessibilityPluginWeb, _super);\n    function AccessibilityPluginWeb() {\n        return _super.call(this, {\n            name: 'Accessibility',\n            platforms: ['web']\n        }) || this;\n    }\n    AccessibilityPluginWeb.prototype.isScreenReaderEnabled = function () {\n        throw new Error('Feature not available in the browser');\n    };\n    AccessibilityPluginWeb.prototype.speak = function (options) {\n        if (!('speechSynthesis' in window)) {\n            return Promise.reject('Browser does not support the Speech Synthesis API');\n        }\n        var utterance = new SpeechSynthesisUtterance(options.value);\n        if (options.language) {\n            utterance.lang = options.language;\n        }\n        window.speechSynthesis.speak(utterance);\n        return Promise.resolve();\n    };\n    return AccessibilityPluginWeb;\n}(WebPlugin));\nexport { AccessibilityPluginWeb };\nvar Accessibility = new AccessibilityPluginWeb();\nexport { Accessibility };\n//# sourceMappingURL=accessibility.js.map","export var extend = function (target) {\n    var objs = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        objs[_i - 1] = arguments[_i];\n    }\n    objs.forEach(function (o) {\n        if (o && typeof (o) === 'object') {\n            for (var k in o) {\n                if (o.hasOwnProperty(k)) {\n                    target[k] = o[k];\n                }\n            }\n        }\n    });\n    return target;\n};\nexport var uuid4 = function () {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);\n        return v.toString(16);\n    });\n};\n//# sourceMappingURL=util.js.map","import { __extends } from \"tslib\";\nimport { WebPlugin } from './index';\nimport { extend } from '../util';\nvar GeolocationPluginWeb = /** @class */ (function (_super) {\n    __extends(GeolocationPluginWeb, _super);\n    function GeolocationPluginWeb() {\n        return _super.call(this, {\n            name: 'Geolocation',\n            platforms: ['web']\n        }) || this;\n    }\n    GeolocationPluginWeb.prototype.getCurrentPosition = function (options) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            return _this.requestPermissions().then(function (_result) {\n                window.navigator.geolocation.getCurrentPosition(function (pos) {\n                    resolve(pos);\n                }, function (err) {\n                    reject(err);\n                }, extend({\n                    enableHighAccuracy: true,\n                    timeout: 10000,\n                    maximumAge: 0\n                }, options));\n            });\n        });\n    };\n    GeolocationPluginWeb.prototype.watchPosition = function (options, callback) {\n        var id = window.navigator.geolocation.watchPosition(function (pos) {\n            callback(pos);\n        }, function (err) {\n            callback(null, err);\n        }, extend({\n            enableHighAccuracy: true,\n            timeout: 10000,\n            maximumAge: 0\n        }, options));\n        return \"\" + id;\n    };\n    GeolocationPluginWeb.prototype.clearWatch = function (options) {\n        window.navigator.geolocation.clearWatch(parseInt(options.id, 10));\n        return Promise.resolve();\n    };\n    return GeolocationPluginWeb;\n}(WebPlugin));\nexport { GeolocationPluginWeb };\nvar Geolocation = new GeolocationPluginWeb();\nexport { Geolocation };\n//# sourceMappingURL=geolocation.js.map","import { __awaiter, __extends, __generator } from \"tslib\";\nimport { WebPlugin } from './index';\nimport { uuid4 } from '../util';\nvar DevicePluginWeb = /** @class */ (function (_super) {\n    __extends(DevicePluginWeb, _super);\n    function DevicePluginWeb() {\n        return _super.call(this, {\n            name: 'Device',\n            platforms: ['web']\n        }) || this;\n    }\n    DevicePluginWeb.prototype.getInfo = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var ua, uaFields;\n            return __generator(this, function (_a) {\n                ua = navigator.userAgent;\n                uaFields = this.parseUa(ua);\n                return [2 /*return*/, Promise.resolve({\n                        model: uaFields.model,\n                        platform: 'web',\n                        appVersion: '',\n                        appBuild: '',\n                        appId: '',\n                        appName: '',\n                        operatingSystem: uaFields.operatingSystem,\n                        osVersion: uaFields.osVersion,\n                        manufacturer: navigator.vendor,\n                        isVirtual: false,\n                        uuid: this.getUid()\n                    })];\n            });\n        });\n    };\n    DevicePluginWeb.prototype.getBatteryInfo = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var battery, e_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        battery = {};\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, navigator.getBattery()];\n                    case 2:\n                        battery = _a.sent();\n                        return [3 /*break*/, 4];\n                    case 3:\n                        e_1 = _a.sent();\n                        return [3 /*break*/, 4];\n                    case 4: return [2 /*return*/, Promise.resolve({\n                            batteryLevel: battery.level,\n                            isCharging: battery.charging\n                        })];\n                }\n            });\n        });\n    };\n    DevicePluginWeb.prototype.getLanguageCode = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, {\n                        value: navigator.language\n                    }];\n            });\n        });\n    };\n    DevicePluginWeb.prototype.parseUa = function (_ua) {\n        var uaFields = {};\n        var start = _ua.indexOf('(') + 1;\n        var end = _ua.indexOf(') AppleWebKit');\n        if (_ua.indexOf(') Gecko') !== -1) {\n            end = _ua.indexOf(') Gecko');\n        }\n        var fields = _ua.substring(start, end);\n        if (_ua.indexOf('Android') !== -1) {\n            uaFields.model = fields.replace('; wv', '').split('; ').pop().split(' Build')[0];\n            uaFields.osVersion = fields.split('; ')[1];\n        }\n        else {\n            uaFields.model = fields.split('; ')[0];\n            if (navigator.oscpu) {\n                uaFields.osVersion = navigator.oscpu;\n            }\n            else {\n                if (_ua.indexOf('Windows') !== -1) {\n                    uaFields.osVersion = fields;\n                }\n                else {\n                    var lastParts = fields.split('; ').pop().replace(' like Mac OS X', '').split(' ');\n                    uaFields.osVersion = lastParts[lastParts.length - 1].replace(/_/g, '.');\n                }\n            }\n        }\n        if (/android/i.test(_ua)) {\n            uaFields.operatingSystem = 'android';\n        }\n        else if (/iPad|iPhone|iPod/.test(_ua) && !window.MSStream) {\n            uaFields.operatingSystem = 'ios';\n        }\n        else if (/Win/.test(_ua)) {\n            uaFields.operatingSystem = 'windows';\n        }\n        else if (/Mac/i.test(_ua)) {\n            uaFields.operatingSystem = 'mac';\n        }\n        else {\n            uaFields.operatingSystem = 'unknown';\n        }\n        return uaFields;\n    };\n    DevicePluginWeb.prototype.getUid = function () {\n        var uid = window.localStorage.getItem('_capuid');\n        if (uid) {\n            return uid;\n        }\n        uid = uuid4();\n        window.localStorage.setItem('_capuid', uid);\n        return uid;\n    };\n    return DevicePluginWeb;\n}(WebPlugin));\nexport { DevicePluginWeb };\nvar Device = new DevicePluginWeb();\nexport { Device };\n//# sourceMappingURL=device.js.map","import { __extends } from \"tslib\";\nimport { WebPlugin } from './index';\nvar LocalNotificationsPluginWeb = /** @class */ (function (_super) {\n    __extends(LocalNotificationsPluginWeb, _super);\n    function LocalNotificationsPluginWeb() {\n        var _this = _super.call(this, {\n            name: 'LocalNotifications',\n            platforms: ['web']\n        }) || this;\n        _this.pending = [];\n        return _this;\n    }\n    LocalNotificationsPluginWeb.prototype.createChannel = function (channel) {\n        throw new Error('Feature not available in the browser. ' + channel.id);\n    };\n    LocalNotificationsPluginWeb.prototype.deleteChannel = function (channel) {\n        throw new Error('Feature not available in the browser. ' + channel.id);\n    };\n    LocalNotificationsPluginWeb.prototype.listChannels = function () {\n        throw new Error('Feature not available in the browser');\n    };\n    LocalNotificationsPluginWeb.prototype.sendPending = function () {\n        var _this = this;\n        var toRemove = [];\n        var now = +new Date;\n        this.pending.forEach(function (localNotification) {\n            if (localNotification.schedule && localNotification.schedule.at) {\n                if (+localNotification.schedule.at <= now) {\n                    _this.buildNotification(localNotification);\n                    toRemove.push(localNotification);\n                }\n            }\n        });\n        console.log('Sent pending, removing', toRemove);\n        this.pending = this.pending.filter(function (localNotification) { return !toRemove.find(function (ln) { return ln === localNotification; }); });\n    };\n    LocalNotificationsPluginWeb.prototype.sendNotification = function (localNotification) {\n        var _this = this;\n        var l = localNotification;\n        if (localNotification.schedule && localNotification.schedule.at) {\n            var diff = +localNotification.schedule.at - +new Date;\n            this.pending.push(l);\n            setTimeout(function () {\n                _this.sendPending();\n            }, diff);\n            return;\n        }\n        this.buildNotification(localNotification);\n    };\n    LocalNotificationsPluginWeb.prototype.buildNotification = function (localNotification) {\n        var l = localNotification;\n        return new Notification(l.title, {\n            body: l.body\n        });\n    };\n    LocalNotificationsPluginWeb.prototype.schedule = function (options) {\n        var _this = this;\n        var notifications = [];\n        options.notifications.forEach(function (notification) {\n            notifications.push(_this.sendNotification(notification));\n        });\n        return Promise.resolve({\n            notifications: options.notifications.map(function (notification) { return { id: '' + notification.id }; })\n        });\n    };\n    LocalNotificationsPluginWeb.prototype.getPending = function () {\n        return Promise.resolve({\n            notifications: this.pending.map(function (localNotification) {\n                return {\n                    id: '' + localNotification.id\n                };\n            })\n        });\n    };\n    LocalNotificationsPluginWeb.prototype.registerActionTypes = function (_options) {\n        throw new Error('Method not implemented.');\n    };\n    LocalNotificationsPluginWeb.prototype.cancel = function (pending) {\n        console.log('Cancel these', pending);\n        this.pending = this.pending.filter(function (localNotification) { return !pending.notifications.find(function (ln) { return ln.id === '' + localNotification.id; }); });\n        return Promise.resolve();\n    };\n    LocalNotificationsPluginWeb.prototype.areEnabled = function () {\n        return Promise.resolve({\n            value: Notification.permission === 'granted'\n        });\n    };\n    LocalNotificationsPluginWeb.prototype.requestPermission = function () {\n        return new Promise(function (resolve) {\n            Notification.requestPermission(function (result) {\n                var granted = true;\n                if (result === 'denied' || result === 'default') {\n                    granted = false;\n                }\n                resolve({ granted: granted });\n            });\n        });\n    };\n    LocalNotificationsPluginWeb.prototype.requestPermissions = function () {\n        return new Promise(function (resolve, reject) {\n            Notification.requestPermission(function (result) {\n                if (result === 'denied' || result === 'default') {\n                    reject(result);\n                    return;\n                }\n                resolve({\n                    results: [result]\n                });\n            });\n        });\n    };\n    return LocalNotificationsPluginWeb;\n}(WebPlugin));\nexport { LocalNotificationsPluginWeb };\nvar LocalNotifications = new LocalNotificationsPluginWeb();\nexport { LocalNotifications };\n//# sourceMappingURL=local-notifications.js.map","import { __extends } from \"tslib\";\nimport { WebPlugin } from './index';\nvar SharePluginWeb = /** @class */ (function (_super) {\n    __extends(SharePluginWeb, _super);\n    function SharePluginWeb() {\n        return _super.call(this, {\n            name: 'Share',\n            platforms: ['web']\n        }) || this;\n    }\n    SharePluginWeb.prototype.share = function (options) {\n        if (!navigator.share) {\n            return Promise.reject('Web Share API not available');\n        }\n        return navigator.share({\n            title: options.title,\n            text: options.text,\n            url: options.url\n        });\n    };\n    return SharePluginWeb;\n}(WebPlugin));\nexport { SharePluginWeb };\nvar Share = new SharePluginWeb();\nexport { Share };\n//# sourceMappingURL=share.js.map","import { __awaiter, __extends, __generator } from \"tslib\";\nimport { WebPlugin } from './index';\nvar ModalsPluginWeb = /** @class */ (function (_super) {\n    __extends(ModalsPluginWeb, _super);\n    function ModalsPluginWeb() {\n        return _super.call(this, {\n            name: 'Modals',\n            platforms: ['web']\n        }) || this;\n    }\n    ModalsPluginWeb.prototype.alert = function (options) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                window.alert(options.message);\n                return [2 /*return*/, Promise.resolve()];\n            });\n        });\n    };\n    ModalsPluginWeb.prototype.prompt = function (options) {\n        return __awaiter(this, void 0, void 0, function () {\n            var val;\n            return __generator(this, function (_a) {\n                val = window.prompt(options.message, options.inputText || '');\n                return [2 /*return*/, Promise.resolve({\n                        value: val,\n                        cancelled: val === null\n                    })];\n            });\n        });\n    };\n    ModalsPluginWeb.prototype.confirm = function (options) {\n        return __awaiter(this, void 0, void 0, function () {\n            var val;\n            return __generator(this, function (_a) {\n                val = window.confirm(options.message);\n                return [2 /*return*/, Promise.resolve({\n                        value: val\n                    })];\n            });\n        });\n    };\n    ModalsPluginWeb.prototype.showActions = function (options) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n                return [2 /*return*/, new Promise(function (resolve, _reject) { return __awaiter(_this, void 0, void 0, function () {\n                        var actionSheet;\n                        var _this = this;\n                        return __generator(this, function (_a) {\n                            actionSheet = document.querySelector('pwa-action-sheet');\n                            if (!actionSheet) {\n                                actionSheet = document.createElement('pwa-action-sheet');\n                                document.body.appendChild(actionSheet);\n                            }\n                            actionSheet.header = options.title;\n                            actionSheet.cancelable = false;\n                            actionSheet.options = options.options;\n                            actionSheet.addEventListener('onSelection', function (e) { return __awaiter(_this, void 0, void 0, function () {\n                                var selection;\n                                return __generator(this, function (_a) {\n                                    selection = e.detail;\n                                    resolve({\n                                        index: selection\n                                    });\n                                    return [2 /*return*/];\n                                });\n                            }); });\n                            return [2 /*return*/];\n                        });\n                    }); })];\n            });\n        });\n    };\n    return ModalsPluginWeb;\n}(WebPlugin));\nexport { ModalsPluginWeb };\nvar Modals = new ModalsPluginWeb();\nexport { Modals };\n//# sourceMappingURL=modals.js.map","import { __extends } from \"tslib\";\nimport { WebPlugin } from './index';\nvar MotionPluginWeb = /** @class */ (function (_super) {\n    __extends(MotionPluginWeb, _super);\n    function MotionPluginWeb() {\n        var _this = _super.call(this, {\n            name: 'Motion'\n        }) || this;\n        _this.registerWindowListener('devicemotion', 'accel');\n        _this.registerWindowListener('deviceorientation', 'orientation');\n        return _this;\n    }\n    return MotionPluginWeb;\n}(WebPlugin));\nexport { MotionPluginWeb };\nvar Motion = new MotionPluginWeb();\nexport { Motion };\n//# sourceMappingURL=motion.js.map","import { __extends } from \"tslib\";\nimport { WebPlugin } from './index';\nvar NetworkPluginWeb = /** @class */ (function (_super) {\n    __extends(NetworkPluginWeb, _super);\n    function NetworkPluginWeb() {\n        var _this = _super.call(this, {\n            name: 'Network',\n            platforms: ['web']\n        }) || this;\n        _this.listenerFunction = null;\n        return _this;\n    }\n    NetworkPluginWeb.prototype.getStatus = function () {\n        return new Promise(function (resolve, reject) {\n            if (!window.navigator) {\n                reject('Network info not available');\n                return;\n            }\n            var connected = window.navigator.onLine;\n            var connection = window.navigator.connection || window.navigator.mozConnection || window.navigator.webkitConnection;\n            var connectionType = connection ? (connection.type || connection.effectiveType) : 'wifi';\n            resolve({\n                connected: connected,\n                connectionType: connected ? connectionType : 'none'\n            });\n        });\n    };\n    NetworkPluginWeb.prototype.addListener = function (eventName, listenerFunc) {\n        var thisRef = this;\n        var connection = window.navigator.connection || window.navigator.mozConnection || window.navigator.webkitConnection;\n        var connectionType = connection ? (connection.type || connection.effectiveType) : 'wifi';\n        var onlineBindFunc = listenerFunc.bind(thisRef, { connected: true, connectionType: connectionType });\n        var offlineBindFunc = listenerFunc.bind(thisRef, { connected: false, connectionType: 'none' });\n        if (eventName.localeCompare('networkStatusChange') === 0) {\n            window.addEventListener('online', onlineBindFunc);\n            window.addEventListener('offline', offlineBindFunc);\n            return {\n                remove: function () {\n                    window.removeEventListener('online', onlineBindFunc);\n                    window.removeEventListener('offline', offlineBindFunc);\n                }\n            };\n        }\n    };\n    return NetworkPluginWeb;\n}(WebPlugin));\nexport { NetworkPluginWeb };\nvar Network = new NetworkPluginWeb();\nexport { Network };\n//# sourceMappingURL=network.js.map","import { __awaiter, __extends, __generator } from \"tslib\";\nimport { WebPlugin } from './index';\nimport { PermissionType } from '../core-plugin-definitions';\nvar PermissionsPluginWeb = /** @class */ (function (_super) {\n    __extends(PermissionsPluginWeb, _super);\n    function PermissionsPluginWeb() {\n        return _super.call(this, {\n            name: 'Permissions'\n        }) || this;\n    }\n    PermissionsPluginWeb.prototype.query = function (options) {\n        return __awaiter(this, void 0, void 0, function () {\n            var navigator, name, ret;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        navigator = window.navigator;\n                        if (!navigator.permissions) {\n                            return [2 /*return*/, Promise.reject('This browser does not support the Permissions API')];\n                        }\n                        name = options.name === PermissionType.Photos ? 'camera' : options.name;\n                        return [4 /*yield*/, navigator.permissions.query({ name: name })];\n                    case 1:\n                        ret = _a.sent();\n                        return [2 /*return*/, {\n                                state: ret.state\n                            }];\n                }\n            });\n        });\n    };\n    return PermissionsPluginWeb;\n}(WebPlugin));\nexport { PermissionsPluginWeb };\nvar Permissions = new PermissionsPluginWeb();\nexport { Permissions };\n//# sourceMappingURL=permissions.js.map","import { __extends } from \"tslib\";\nimport { WebPlugin } from './index';\nvar SplashScreenPluginWeb = /** @class */ (function (_super) {\n    __extends(SplashScreenPluginWeb, _super);\n    function SplashScreenPluginWeb() {\n        return _super.call(this, {\n            name: 'SplashScreen',\n            platforms: ['web']\n        }) || this;\n    }\n    SplashScreenPluginWeb.prototype.show = function (_options, _callback) {\n        return Promise.resolve();\n    };\n    SplashScreenPluginWeb.prototype.hide = function (_options, _callback) {\n        return Promise.resolve();\n    };\n    return SplashScreenPluginWeb;\n}(WebPlugin));\nexport { SplashScreenPluginWeb };\nvar SplashScreen = new SplashScreenPluginWeb();\nexport { SplashScreen };\n//# sourceMappingURL=splash-screen.js.map","import { __extends } from \"tslib\";\nimport { WebPlugin } from './index';\nvar StoragePluginWeb = /** @class */ (function (_super) {\n    __extends(StoragePluginWeb, _super);\n    function StoragePluginWeb() {\n        var _this = _super.call(this, {\n            name: 'Storage',\n            platforms: ['web']\n        }) || this;\n        _this.KEY_PREFIX = '_cap_';\n        return _this;\n    }\n    StoragePluginWeb.prototype.get = function (options) {\n        var _this = this;\n        return new Promise(function (resolve, _reject) {\n            resolve({\n                value: window.localStorage.getItem(_this.makeKey(options.key))\n            });\n        });\n    };\n    StoragePluginWeb.prototype.set = function (options) {\n        var _this = this;\n        return new Promise(function (resolve, _reject) {\n            window.localStorage.setItem(_this.makeKey(options.key), options.value);\n            resolve();\n        });\n    };\n    StoragePluginWeb.prototype.remove = function (options) {\n        var _this = this;\n        return new Promise(function (resolve, _reject) {\n            window.localStorage.removeItem(_this.makeKey(options.key));\n            resolve();\n        });\n    };\n    StoragePluginWeb.prototype.keys = function () {\n        var _this = this;\n        return new Promise(function (resolve, _reject) {\n            resolve({\n                keys: Object.keys(localStorage).filter(function (k) { return _this.isKey(k); }).map(function (k) { return _this.getKey(k); })\n            });\n        });\n    };\n    StoragePluginWeb.prototype.clear = function () {\n        var _this = this;\n        return new Promise(function (resolve, _reject) {\n            Object.keys(localStorage)\n                .filter(function (k) { return _this.isKey(k); })\n                .forEach(function (k) { return window.localStorage.removeItem(k); });\n            resolve();\n        });\n    };\n    StoragePluginWeb.prototype.makeKey = function (key) {\n        return this.KEY_PREFIX + key;\n    };\n    StoragePluginWeb.prototype.isKey = function (key) {\n        return key.indexOf(this.KEY_PREFIX) === 0;\n    };\n    StoragePluginWeb.prototype.getKey = function (key) {\n        return key.substr(this.KEY_PREFIX.length);\n    };\n    return StoragePluginWeb;\n}(WebPlugin));\nexport { StoragePluginWeb };\nvar Storage = new StoragePluginWeb();\nexport { Storage };\n//# sourceMappingURL=storage.js.map","import { __awaiter, __extends, __generator } from \"tslib\";\nimport { WebPlugin } from './index';\nvar ToastPluginWeb = /** @class */ (function (_super) {\n    __extends(ToastPluginWeb, _super);\n    function ToastPluginWeb() {\n        return _super.call(this, {\n            name: 'Toast',\n            platforms: ['web']\n        }) || this;\n    }\n    ToastPluginWeb.prototype.show = function (options) {\n        return __awaiter(this, void 0, void 0, function () {\n            var duration, toast;\n            return __generator(this, function (_a) {\n                duration = 2000;\n                if (options.duration) {\n                    duration = options.duration === 'long' ? 3500 : 2000;\n                }\n                toast = document.createElement('pwa-toast');\n                toast.duration = duration;\n                toast.message = options.text;\n                document.body.appendChild(toast);\n                return [2 /*return*/];\n            });\n        });\n    };\n    return ToastPluginWeb;\n}(WebPlugin));\nexport { ToastPluginWeb };\nvar Toast = new ToastPluginWeb();\nexport { Toast };\n//# sourceMappingURL=toast.js.map","var WebPluginRegistry = /** @class */ (function () {\n    function WebPluginRegistry() {\n        this.plugins = {};\n        this.loadedPlugins = {};\n    }\n    WebPluginRegistry.prototype.addPlugin = function (plugin) {\n        this.plugins[plugin.config.name] = plugin;\n    };\n    WebPluginRegistry.prototype.getPlugin = function (name) {\n        return this.plugins[name];\n    };\n    WebPluginRegistry.prototype.loadPlugin = function (name) {\n        var plugin = this.getPlugin(name);\n        if (!plugin) {\n            console.error(\"Unable to load web plugin \" + name + \", no such plugin found.\");\n            return;\n        }\n        plugin.load();\n    };\n    WebPluginRegistry.prototype.getPlugins = function () {\n        var p = [];\n        for (var name_1 in this.plugins) {\n            p.push(this.plugins[name_1]);\n        }\n        return p;\n    };\n    return WebPluginRegistry;\n}());\nexport { WebPluginRegistry };\nvar WebPlugins = new WebPluginRegistry();\nexport { WebPlugins };\nvar WebPlugin = /** @class */ (function () {\n    function WebPlugin(config, pluginRegistry) {\n        this.config = config;\n        this.loaded = false;\n        this.listeners = {};\n        this.windowListeners = {};\n        if (!pluginRegistry) {\n            WebPlugins.addPlugin(this);\n        }\n        else {\n            pluginRegistry.addPlugin(this);\n        }\n    }\n    WebPlugin.prototype.addWindowListener = function (handle) {\n        window.addEventListener(handle.windowEventName, handle.handler);\n        handle.registered = true;\n    };\n    WebPlugin.prototype.removeWindowListener = function (handle) {\n        if (!handle) {\n            return;\n        }\n        window.removeEventListener(handle.windowEventName, handle.handler);\n        handle.registered = false;\n    };\n    WebPlugin.prototype.addListener = function (eventName, listenerFunc) {\n        var _this = this;\n        var listeners = this.listeners[eventName];\n        if (!listeners) {\n            this.listeners[eventName] = [];\n        }\n        this.listeners[eventName].push(listenerFunc);\n        // If we haven't added a window listener for this event and it requires one,\n        // go ahead and add it\n        var windowListener = this.windowListeners[eventName];\n        if (windowListener && !windowListener.registered) {\n            this.addWindowListener(windowListener);\n        }\n        return {\n            remove: function () {\n                _this.removeListener(eventName, listenerFunc);\n            }\n        };\n    };\n    WebPlugin.prototype.removeListener = function (eventName, listenerFunc) {\n        var listeners = this.listeners[eventName];\n        if (!listeners) {\n            return;\n        }\n        var index = listeners.indexOf(listenerFunc);\n        this.listeners[eventName].splice(index, 1);\n        // If there are no more listeners for this type of event,\n        // remove the window listener\n        if (!this.listeners[eventName].length) {\n            this.removeWindowListener(this.windowListeners[eventName]);\n        }\n    };\n    WebPlugin.prototype.removeAllListeners = function () {\n        this.listeners = {};\n        for (var listener in this.windowListeners) {\n            this.removeWindowListener(this.windowListeners[listener]);\n        }\n        this.windowListeners = {};\n    };\n    WebPlugin.prototype.notifyListeners = function (eventName, data) {\n        var listeners = this.listeners[eventName];\n        if (listeners) {\n            listeners.forEach(function (listener) { return listener(data); });\n        }\n    };\n    WebPlugin.prototype.hasListeners = function (eventName) {\n        return !!this.listeners[eventName].length;\n    };\n    WebPlugin.prototype.registerWindowListener = function (windowEventName, pluginEventName) {\n        var _this = this;\n        this.windowListeners[pluginEventName] = {\n            registered: false,\n            windowEventName: windowEventName,\n            pluginEventName: pluginEventName,\n            handler: function (event) {\n                _this.notifyListeners(pluginEventName, event);\n            }\n        };\n    };\n    WebPlugin.prototype.requestPermissions = function () {\n        if (Capacitor.isNative) {\n            return Capacitor.nativePromise(this.config.name, 'requestPermissions', {});\n        }\n        else {\n            return Promise.resolve({ results: [] });\n        }\n    };\n    WebPlugin.prototype.load = function () {\n        this.loaded = true;\n    };\n    return WebPlugin;\n}());\nexport { WebPlugin };\nvar shouldMergeWebPlugin = function (plugin) {\n    return plugin.config.platforms && plugin.config.platforms.indexOf(Capacitor.platform) >= 0;\n};\n/**\n * For all our known web plugins, merge them into the global plugins\n * registry if they aren't already existing. If they don't exist, that\n * means there's no existing native implementation for it.\n * @param knownPlugins the Capacitor.Plugins global registry.\n */\nexport var mergeWebPlugins = function (knownPlugins) {\n    var plugins = WebPlugins.getPlugins();\n    for (var _i = 0, plugins_1 = plugins; _i < plugins_1.length; _i++) {\n        var plugin = plugins_1[_i];\n        mergeWebPlugin(knownPlugins, plugin);\n    }\n};\nexport var mergeWebPlugin = function (knownPlugins, plugin) {\n    // If we already have a plugin registered (meaning it was defined in the native layer),\n    // then we should only overwrite it if the corresponding web plugin activates on\n    // a certain platform. For example: Geolocation uses the WebPlugin on Android but not iOS\n    if (knownPlugins.hasOwnProperty(plugin.config.name) && !shouldMergeWebPlugin(plugin)) {\n        return;\n    }\n    knownPlugins[plugin.config.name] = plugin;\n};\n//# sourceMappingURL=index.js.map","import VectorTileSource from 'mapbox-gl/src/source/vector_tile_source'\nimport pako from 'pako/lib/inflate'\nimport base64js from 'base64-js'\nimport { Plugins } from '@capacitor/core';\n\nconst CapacitorSQLite = { Plugins };\n\nclass MBTilesSource extends VectorTileSource {\n\n\n    constructor(id, options, dispatcher, eventedParent) {\n        super(id, options, dispatcher, eventedParent);\n        this.type = \"mbtiles\";\n        this.dbLocation = options.path;\n    }\n\n    openDatabase() {\n        return CapacitorSQLite.open({ database: this.dbLocation });\n    }\n\n    readTile(z, x, y, callback) {\n        const query = `SELECT BASE64(tile_data) AS base64_tile_data FROM tiles WHERE zoom_level=${z} AND tile_column=${x} AND tile_row=${y}`;\n        // const params = [z, x, y];\n        this.openDatabase().then(function() {\n            // db.transaction(function (txn) {\n            //     txn.executeSql(query, params, function (tx, res) {\n            //         if (res.rows.length) {\n            //             const base64Data = res.rows.item(0).base64_tile_data;\n            //             const rawData = pako.inflate(base64js.toByteArray(base64Data));\n            //             callback(undefined, base64js.fromByteArray(rawData)); // Tile contents read, callback success.\n            //         } else {\n            //             callback(new Error('tile ' + params.join(',') + ' not found'));\n            //         }\n            //     });\n            // }, function (error) {\n            //     callback(error); // Error executing SQL\n            // });\n            this.db.execute(query).then(result => {\n                console.log(result);\n            })\n        }).catch(function(err) {\n            callback(err);\n        });\n    }\n\n    loadTile(tile, callback) {\n        const coord = tile.tileID.canonical;\n        const overscaling = coord.z > this.maxzoom ? Math.pow(2, coord.z - this.maxzoom) : 1;\n\n        const z = Math.min(coord.z, this.maxzoom || coord.z); // Don't try to get data over maxzoom\n        const x = coord.x;\n        const y = Math.pow(2,z)-coord.y-1; // Tiles on database are tms (inverted y axis)\n\n        this.readTile(z, x, y, dispatch.bind(this));\n\n        function dispatch(err, base64Data) {\n            if (err) {\n                return callback(err);\n            }\n            if (base64Data === undefined) {\n              return callback(new Error(\"empty data\"));\n            }\n\n            const params = {\n                request: { url: \"data:application/x-protobuf;base64,\" + base64Data },\n                uid: tile.uid,\n                tileID: tile.tileID,\n                zoom: coord.z,\n                tileSize: this.tileSize * overscaling,\n                type: this.type,\n                source: this.id,\n                pixelRatio: window.devicePixelRatio || 1,\n                overscaling: overscaling,\n                showCollisionBoxes: this.map.showCollisionBoxes\n            };\n\n            if (!tile.workerID || tile.state === 'expired') {\n                tile.workerID = this.dispatcher.send('loadTile', params, done.bind(this));\n            } else if (tile.state === 'loading') {\n                // schedule tile reloading after it has been loaded\n                tile.reloadCallback = callback;\n            } else {\n                this.dispatcher.send('reloadTile', params, done.bind(this), tile.workerID);\n            }\n\n            function done(err, data) {\n                if (tile.aborted)\n                    return;\n\n                if (err) {\n                    return callback(err);\n                }\n\n                if (this.map._refreshExpiredTiles) tile.setExpiryData(data);\n                tile.loadVectorData(data, this.map.painter);\n\n                callback(null);\n\n                if (tile.reloadCallback) {\n                    this.loadTile(tile, tile.reloadCallback);\n                    tile.reloadCallback = null;\n                }\n            }\n        }\n    }\n}\n\nexport default MBTilesSource;\n","// @flow\n\n'use strict';\n\nimport MBTilesSource from './mbtiles_source'\nimport RasterTileSourceOffline from \"./raster_tile_offline_source\"\nimport Map from 'mapbox-gl/src/ui/map'\nimport {extend} from 'mapbox-gl/src/util/util'\nimport window from 'mapbox-gl/src/util/window'\n\nconst readJSON = (url) => new Promise((resolve, reject) => {\n    const xhr = new window.XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.setRequestHeader('Accept', 'application/json');\n    xhr.onerror = (e) => reject(e);\n    xhr.onload = () => {\n        const isFile = xhr.responseURL.indexOf('file://') === 0;\n        if (((xhr.status >= 200 && xhr.status < 300) || isFile) && xhr.response) {\n            try {\n                resolve(JSON.parse(xhr.response));\n            } catch (err) {\n                reject(err);\n            }\n        } else {\n            reject(new Error(xhr.statusText, xhr.status));\n        }\n    };\n    xhr.send();\n    return xhr;\n});\n\nconst dereferenceStyle = (options) => {\n    if (typeof options.style === 'string' || options.style instanceof String) {\n        return readJSON(options.style).then((style) => extend({}, options, {style: style}));\n    } else {\n        return Promise.resolve(options);\n    }\n};\n\nconst absoluteSpriteUrl = (options) => {\n    const style = options.style;\n    const hasProtocol = /^.+:\\/\\//;\n    const path = window.location.origin + window.location.pathname.split('/').slice(0, -1).join('/');\n\n    if (('sprite' in style) && !style.sprite.match(hasProtocol) &&\n        ('glyphs' in style) && !style.glyphs.match(hasProtocol)) {\n        style.sprite = path + '/' +  style.sprite; // eslint-disable-line prefer-template\n        style.glyphs = path + '/' +  style.glyphs; // eslint-disable-line prefer-template\n    }\n    return options;\n};\n\nconst createEmptyMap = (options) => new Promise((resolve) => {\n    const emptyMapStyle = extend({}, options.style, {\n        sources: {},\n        layers: []\n    });\n    const emptyMapOptions = extend({}, options, {style: emptyMapStyle});\n    const map = new Map(emptyMapOptions);\n    map.once('load', () => {\n        let mbTilesSourceLoaded = new Promise((resolve) => {\n            map.addSourceType('mbtiles', MBTilesSource, () => resolve())\n        })\n        // let rasterOfflineSourceLoaded = new Promise((resolve) => {\n        //     map.addSourceType('rasteroffline', RasterTileSourceOffline, () => resolve())\n        // })\n\n        Promise.all([mbTilesSourceLoaded/*, rasterOfflineSourceLoaded*/]).then(() => resolve(map))\n    });\n});\n\nconst loadSources = (style) => (map) => {\n    Object.keys(style.sources).map((sourceName) => map.addSource(sourceName, style.sources[sourceName]));\n    return map;\n};\n\nconst loadLayers = (style) => (map) => {\n    style.layers.map((layer) => map.addLayer(layer));\n    return map;\n};\n\nconst OfflineMap = (options) =>\n    dereferenceStyle(options).then(absoluteSpriteUrl).then((newOptions) =>\n        createEmptyMap(newOptions)\n            .then(loadSources(newOptions.style))\n            .then(loadLayers(newOptions.style))\n    );\n\nexport default OfflineMap\n","//\n// Our custom intro provides a specialized \"define()\" function, called by the\n// AMD modules below, that sets up the worker blob URL and then executes the\n// main module, storing its exported value as 'mapboxgl'\n\n// The three \"chunks\" imported here are produced by a first Rollup pass,\n// which outputs them as AMD modules.\n\n// Shared dependencies, i.e.:\n/*\ndefine(['exports'], function (exports) {\n    // Code for all common dependencies\n    // Each module's exports are attached attached to 'exports' (with\n    // names rewritten to avoid collisions, etc.)\n})\n*/\nimport './build/mapboxgl/shared';\n\n// Worker and its unique dependencies, i.e.:\n/*\ndefine(['./shared.js'], function (__shared__js) {\n    //  Code for worker script and its unique dependencies.\n    //  Expects the output of 'shared' module to be passed in as an argument,\n    //  since all references to common deps look like, e.g.,\n    //  __shared__js.shapeText().\n});\n*/\n// When this wrapper function is passed to our custom define() above,\n// it gets stringified, together with the shared wrapper (using\n// Function.toString()), and the resulting string of code is made into a\n// Blob URL that gets used by the main module to create the web workers.\nimport './build/mapboxgl/worker';\n\n// Main module and its unique dependencies\n/*\ndefine(['./shared.js'], function (__shared__js) {\n    //  Code for main GL JS module and its unique dependencies.\n    //  Expects the output of 'shared' module to be passed in as an argument,\n    //  since all references to common deps look like, e.g.,\n    //  __shared__js.shapeText().\n    //\n    //  Returns the actual mapboxgl (i.e. src/index.js)\n});\n*/\nimport './build/mapboxgl/index';\n\nexport default mapboxgl;\n"],"names":["val","low","high","Error","realloc","pbf","buf","pos","lsb","writeBigVarintHigh","this","writeSVarint","Boolean","str","String","startPos","lead","i","charCodeAt","c","length","makeRoomForExtraLength","writeVarint","len","writeBytes","buffer","obj","writeMessage","writePackedVarint","arr","tag","writePackedSVarint","writePackedBoolean","writePackedFloat","writePackedDouble","writePackedFixed32","writePackedSFixed32","writePackedFixed64","writePackedSFixed64","writeTag","Pbf","writeFixed64Field","Fixed64","writeFixed64","writeSFixed64","writeVarintField","Varint","Fixed32","writeFloat","writeDouble","readFontstacks","glyphs","readMessage","advance","id","width","height","border","bitmap","left","readVarint","glyph","top","GLYPH_PBF_BORDER","constructor","target","parent","mapId","callbacks","callbackID","addEventListener","getMercCoords","PI","Math","x","y","Actor","type","targetMapId","callback","const","buffers","postMessage","sourceMapId","data","receive","message","done","error","cancelable","keys","source","remove","sw","setSouthWest","ne","_ne","LngLat","lat","LngLatBounds","sw2","ne2","isArray","every","convert","extend","_sw","lng","min","max","getCenter","getSouthWest","toString","input","isNaN","circumferenceAtLatitude","latitude","mercatorYfromLat","latFromMercatorY","y2","atan","exp","latAccuracy","radius","cos","Number","z","lngLatLike","altitude","toLngLat","MercatorCoordinate","quadkey","urls","replace","pow","coord","tilesAtZoom","EXTENT","canonical","OverscaledTileID","wrap","overscaledZ","calculateKey","dim","equals","targetZ","zDifference","sourceMaxZoom","rhs","unwrapTo","getTilePoint","uid","stride","Int32Array","encoding","j","pixels","set","get","value","DEMData","_idx","g","b","_unpackTerrarium","r","dx","yMin","dy","yMax","ox","oy","xMin","xMax","borderTile","register","_stringToNumber","string","_numberToString","DictionaryCoder","encode","decode","Feature","_vectorTileFeature","vectorTileFeature","_z","_x","properties","undefined","_geometry","geometry","toJSON","state","deletedStates","SourceFeatureState","updateState","featureId","newState","feature","stateChanges","sourceLayer","ft","prop","key","changes","reconciledState","featureDeletions","initializeTileState","tiles","layerStates","featuresChanged","FeatureIndex","featureIndexArray","tileID","grid","let","Infinity","maxX","maxY","p","minX","minY","featureIndex","is3D","grid3D","bbox","insert","loadVTLayers","vtLayers","VectorTile","layers","sourceLayerCoder","Object","sort","sourceFeatureState","params","args","pixelsToTileUnits","filter","queryGeometry","queryPadding","bounds","query","getBounds","cameraBounds","by1","cameraQueryGeometry","previousIndex","index","matching","featureGeometry","result","match","loadGeometry","styleLayer","featureState","pixelPosMatrix","k","loadMatchingFeature","filterLayerIDs","styleLayers","bucketLayerIDs","l","layerIDs","sourceLayerName","indexOf","intersectionTest","layerResult","featureFilter","sourceLayerIndex","duration","timeAdded","fadeEndTime","wasRequested","painter","latestFeatureIndex","rawTileData","latestRawTileData","collisionBoxArray","bucket","stateDependentLayerIds","lId","layer","style","buckets","imageAtlas","destroy","glyphAtlasTexture","unloadDEMData","Texture","ALPHA","Tile","scale","tileSize","_geojsonTileLayer","EvaluationParameters","GeoJSONFeature","segments","context","mask","RasterBoundsArray","vertexExtent","tlVertex","maskCoord","brVertex","offset","indexArray","emplaceBack","vertexLength","primitiveLength","maskedBoundsBuffer","createVertexBuffer","hasData","setExpiryData","expirationTime","cacheControl","$2","$3","toLowerCase","header","expires","Date","getTime","delta","expiredRequestCount","sourceLayerStates","states","queryRadius","now","clearFadeHold","setHoldDuration","browser","horizontal","TaggedString","text","sectionIndex","fromFeature","section","push","sections","nextCharCode","output","verticalizePunctuation","whitespace","trailingWhitespace","beginningWhitespace","substring","start","getMaxScale","lineWidth","targetWidth","abs","nextCodePoint","penalty","codePoint","breakX","calculateBadness","potentialBreak","breakBadness","bestBreakBadness","determineLineBreaks","logicalInput","maxWidth","getSection","stringify","JSON","Array","getKey","refProperties","StyleLayerIndex","layerConfigs","checkMaxAngle","line","anchor","labelLength","windowSize","maxAngle","segment","anchorDistance","dist","recentCorners","recentAngleDelta","prev","current","next","angleDelta","angleTo","distance","shift","getLineLength","lineLength","getAngleWindowSize","shapedText","glyphSize","boxScale","getShapedLabelLength","shapedIcon","right","getCenterAnchor","angleWindowSize","prevDistance","centerDistance","a","segmentDistance","t","interpolate","Anchor","_round","getAnchors","spacing","overscaling","tileExtent","shapedLabelLength","isLineContinued","resample","placeAtMiddle","halfLabelLength","markedDistance","anchors","segmentDist","angle","_layerConfigs","_layers","update","removedIds","layerConfig","createStyleLayer","_featureFilter","familiesBySource","groups","group","groupByLayout","values","map","visibility","sourceId","sourceGroup","sourceLayerId","sourceLayerFamilies","CollisionFeature","bucketIndex","shaped","padding","alignLine","rotate","y1","bottom","x1","x2","boxStartIndex","_addLineCollisionCircles","tl","Point","tr","bl","br","rotateRadians","_rotate","boxEndIndex","boxSize","step","nBoxes","floor","overscalingPaddingFactor","log","LN2","nPitchPaddingBoxes","firstBoxOffset","labelStartDistance","paddingStartDistance","segmentLength","boxOffset","boxDistanceToAnchor","segmentBoxDistance","p0","boxAnchorPoint","sub","_unit","_mult","_add","paddedAnchorDistance","TinyQueue","compare","defaultCompare","_down","polygon","area","points","f","Cell","compareMax","h","d","inside","minDistSq","ring","distToSegmentSquared","sqrt","pointToPolygonDist","SQRT2","item","_up","pop","peek","halfLength","best","module","seed","remainder","bytes","h1","h1b","c1","c2","k1","murmur3","murmur2","performSymbolLayout","glyphMap","glyphPositions","imageMap","imagePositions","showCollisionBoxes","createArrays","tilePixelRatio","compareText","iconsNeedLinear","layout","unevaluatedLayoutValues","_unevaluatedLayout","_values","sizes","textSizeData","functionType","zoomRange","compositeTextSizes","possiblyEvaluate","iconSizeData","compositeIconSizes","layoutTextSize","zoom","layoutIconSize","textMaxSize","lineHeight","textAlongLine","keepUpright","features","fontstack","evaluate","join","glyphPositionMap","shapedTextOrientations","unformattedText","textOffset","spacingIfAllowed","allowsLetterSpacing","textAnchor","textJustify","shapeText","WritingMode","allowsVerticalWritingMode","vertical","icon","image","shapeIcon","sdfIcons","sdf","warnOnce","pixelRatio","constantOr","addFeature","generateCollisionDebugBuffers","iconOffset","fontScale","textBoxScale","textMaxBoxScale","iconBoxScale","symbolMinDistance","textPadding","iconPadding","textMaxAngle","iconAlongLine","symbolPlacement","textRepeatDistance","addSymbolAtAnchor","textCollisionFeature","iconCollisionFeature","lineArray","addToLineVertexArray","numIconVertices","numGlyphVertices","numVerticalGlyphVertices","placedTextSymbolIndices","textRotate","addTextVertices","horizontalOnly","textBoxStartIndex","textBoxEndIndex","iconQuads","alongLine","iconWidth","iconHeight","size","textLeft","textRight","textTop","textWidth","textHeight","padT","padR","padB","padL","offsetY","offsetX","sin","matrix","_matMult","tex","paddedRect","writingMode","glyphOffset","getIconQuads","iconRotate","sizeData","SIZE_PACK_FACTOR","MAX_PACKED_SIZE","layerIds","addSymbols","lineStartIndex","iconBoxStartIndex","iconBoxEndIndex","glyphOffsetArray","SymbolBucket","MAX_GLYPHS","symbolInstances","addSymbol","lines","clippedLines","clippedLine","p1","clipLine","anchorIsTooClose","classifyRings","poi","findPoleOfInaccessibility","point","glyphQuads","shaping","positions","positionedGlyphs","quads","positionedGlyph","fontStack","rect","rectBuffer","halfAdvance","metrics","builtInOffset","w","center","verticalRotation","xOffsetCorrection","_rotateAround","getGlyphQuads","placedSymbolArray","repeatDistance","otherAnchors","GlyphAtlas","stacks","bins","stack","stackPositions","src","bin","potpack","AlphaImage","copy","WorkerTile","overscaleFactor","collectResourceTiming","returnDependencies","recalculateLayers","parameters","recalculate","parse","layerIndex","actor","status","CollisionBoxArray","iconMap","patternMap","options","layerFamilies","version","family","minzoom","maxzoom","createBucket","sourceID","populate","mapObject","glyphDependencies","send","err","maybePrepare","call","icons","iconDependencies","patterns","patternDependencies","glyphAtlas","ImageAtlas","iconPositions","hasPattern","LineBucket","FillBucket","FillExtrusionBucket","addFeatures","patternPositions","isEmpty","glyphAtlasImage","performanceExists","performance","wrapper","url","getEntriesByName","name","mark","startMark","endMark","measure","clearMarks","clearMeasures","Performance","request","_marks","end","loadVectorTile","getArrayBuffer","vectorTile","vt","Protobuf","rawData","cancel","finish","resourceTimingData","VectorTileWorkerSource","loadVectorData","loading","loaded","loadTile","perf","workerTile","abort","response","resourceTiming","slice","reloadTile","vtSource","reloadCallback","abortTile","removeTile","RasterDEMTileWorkerSource","rawImageData","dem","polygonArea","coords","ringArea","p2","lowerIndex","middleIndex","upperIndex","coordsLength","rad","wgs84","RADIUS","_","coordinates","geometries","rewind","gj","outer","curryOuter","correctRings","correct","wind","dir","geojsonArea","cw","reverse","toGeoJSON","mvt","VectorTileFeature","prototype","FeatureWrapper","_feature","extent","tags","parseInt","newRing","GeoJSONWrapper","_features","require","rawGeometry","rings","fromVectorTileJs","tile","out","writeLayer","writeTile","writeStringField","keycache","valuecache","writeFeature","R","S","T","Z","]","`","e","m","s","u","}","draw","renderPass","disabled","colorModeForRenderPass","drawLayerSymbols","paint","colorMode","sourceCache","drawCollisionDebugGeometry","opacity","strokeWidth","strokeOpacity","gl","depthMode","ReadOnly","stencilMode","StencilMode","programConfigurations","indexBuffer","programConfiguration","DepthMode","ONE","Color","activeTexture","TEXTURE1","fbo","framebuffer","bindTexture","TEXTURE_2D","texParameteri","CLAMP_TO_EDGE","LINEAR","TEXTURE_MAG_FILTER","heatmapFbo","createFramebuffer","bindTextureToFramebuffer","texture","texImage2D","RGBA","extTextureHalfFloat","HALF_FLOAT_OES","checkFramebufferStatus","FRAMEBUFFER","FRAMEBUFFER_COMPLETE","setDirty","hasRenderableParent","transform","viewport","TEXTURE0","colorAttachment","colorRampTexture","colorRamp","bind","useProgram","TRIANGLES","CullFaceMode","heatmapTextureUniformValues","viewportBuffer","quadTriangleIndexBuffer","renderTextureToMap","dasharray","patternProperty","dbIndexRequest","entries","_a","sent","files","path","getUri","entry","label","getPath","dbRequest","directory","ctime","mtime","uri","_copy","__generator","FilesystemPluginWeb","doRename","to","from","fromDirectory","toDirectory","toObj","toPathComponents","toPath_1","fromObj","contents_1","filename","_this","_b","fromPath","toPath","split","updateTime","__awaiter","fullPath","readFile","file","trys","mkdir","readdir","contents","_i","objs","GeolocationPluginWeb","getCurrentPosition","Promise","then","geolocation","resolve","reject","enableHighAccuracy","timeout","maximumAge","window","watchPosition","clearWatch","WebPlugin","DevicePluginWeb","_super","platforms","__extends","ua","uaFields","navigator","parseUa","model","appVersion","appBuild","appId","operatingSystem","manufacturer","vendor","getUid","getBatteryInfo","battery","getBattery","charging","getLanguageCode","_ua","fields","osVersion","oscpu","lastParts","test","MSStream","getItem","random","LocalNotificationsPluginWeb","pending","createChannel","channel","deleteChannel","listChannels","sendPending","forEach","localNotification","schedule","at","console","toRemove","setTimeout","diff","notifications","sendNotification","notification","ln","areEnabled","granted","Notification","requestPermission","share","title","SharePluginWeb","ModalsPluginWeb","alert","prompt","showActions","document","querySelector","actionSheet","createElement","body","selection","registerWindowListener","MotionPluginWeb","NetworkPluginWeb","mozConnection","connection","effectiveType","connected","onlineBindFunc","listenerFunc","offlineBindFunc","connectionType","eventName","PermissionType","Photos","SplashScreenPluginWeb","StoragePluginWeb","makeKey","localStorage","_reject","removeItem","isKey","clear","ToastPluginWeb","toast","plugins_1","CapacitorSQLite","dispatcher","super","eventedParent","dbLocation","open","database","db","base64Data","devicePixelRatio","workerID","aborted","xhr","setRequestHeader","onerror","isFile","statusText","hasProtocol","pathname","sprite","absoluteSpriteUrl","emptyMapStyle","emptyMapOptions","sourceName","sources"],"mappings":"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"}